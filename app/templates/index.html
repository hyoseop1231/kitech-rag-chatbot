<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KITECH RAG Chatbot</title>
    <link rel="stylesheet" href="{{ url_for('static', path='/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– KITECH RAG Chatbot</h1>

        <div class="ollama-section">
            <h2>ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ ëŒ€ì‹œë³´ë“œ</h2>
            
            <!-- ì²« ë²ˆì§¸ ì¤„: LLM & ë¬¸ì„œì²˜ë¦¬ ìƒíƒœ (ê· ë“± ë°°ì¹˜) -->
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; align-items: center; margin-bottom: 15px;">
                <!-- Ollama ìƒíƒœ -->
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">ğŸ§ </span>
                    <div id="ollama-status" style="font-size: 0.9em;">Ollama ìƒíƒœ: í™•ì¸ ì¤‘...</div>
                </div>
                
                <!-- ëª¨ë¸ ì„ íƒ -->
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">âš™ï¸</span>
                    <label for="ollama-models" style="margin: 0; white-space: nowrap; font-size: 0.9em;">ëª¨ë¸:</label>
                    <select id="ollama-models" style="flex: 1; min-width: 0; font-size: 0.85em;">
                        <option value="">ë¡œë”© ì¤‘...</option>
                    </select>
                </div>
                
                <!-- LLM ì‘ë™ ìƒíƒœ -->
                <div id="model-info-container" style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.1em;">ğŸ’­</span>
                    <div id="model-activity" style="display: none; align-items: center; gap: 6px;">
                        <div id="activity-gauge" style="width: 18px; height: 18px; border-radius: 50%; background: conic-gradient(#28a745 0deg, #e9ecef 0deg); position: relative; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background: white; border-radius: 50%;"></div>
                        </div>
                        <span id="activity-text" style="font-size: 0.8em; color: #28a745; font-weight: 500;">ëŒ€ê¸°ì¤‘</span>
                    </div>
                    <div id="model-info" style="font-size: 0.8em; color: #495057; flex: 1; min-width: 0;">
                        ëª¨ë¸ ì •ë³´ ë¡œë”© ì¤‘...
                    </div>
                </div>
                
                <!-- ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœ -->
                <div id="processing-status-container" style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">ğŸ“„</span>
                    <div id="processing-activity" style="display: flex; align-items: center; gap: 6px;">
                        <div id="processing-gauge" style="width: 18px; height: 18px; border-radius: 50%; background: conic-gradient(#6c757d 0deg, #e9ecef 0deg); position: relative; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background: white; border-radius: 50%;"></div>
                        </div>
                        <span id="processing-text" style="font-size: 0.8em; color: #6c757d; font-weight: 500;">ëŒ€ê¸°ì¤‘</span>
                    </div>
                </div>
            </div>
            
            <!-- ë‘ ë²ˆì§¸ ì¤„: ì‹œìŠ¤í…œ í†µê³„ & ë¹ ë¥¸ ì„¤ì • -->
            <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap; padding: 12px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                <!-- ì‹œìŠ¤í…œ í†µê³„ -->
                <div style="display: flex; gap: 20px; flex: 1; min-width: 300px;">
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="doc-count">0</div>
                        <div style="font-size: 0.8em; color: #6c757d;">ë¬¸ì„œ</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="chunk-count">0</div>
                        <div style="font-size: 0.8em; color: #6c757d;">ì²­í¬</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="storage-size">0MB</div>
                        <div style="font-size: 0.8em; color: #6c757d;">ì €ì¥ê³µê°„</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; font-weight: 500; color: #6c757d;" id="last-update">ì—…ë°ì´íŠ¸ ì—†ìŒ</div>
                        <div style="font-size: 0.8em; color: #6c757d;">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸</div>
                    </div>
                </div>
                
                <!-- ë¹ ë¥¸ ì„¤ì • í† ê¸€ -->
                <div style="display: flex; gap: 15px; align-items: center; border-left: 1px solid #dee2e6; padding-left: 20px;">
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="ocr-correction-toggle" checked style="margin: 0;">
                        <span>ğŸ”§ OCR êµì •</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="llm-correction-toggle" checked style="margin: 0;">
                        <span>ğŸ¤– LLM êµì •</span>
                        <span style="font-size: 0.7em; color: #28a745; margin-left: 5px;" title="ê²½ëŸ‰ ëª¨ë¸(qwen2.5:3b) ì‚¬ìš©ìœ¼ë¡œ ë¹ ë¥¸ ì²˜ë¦¬">âš¡ ê²½ëŸ‰</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="auto-refresh-toggle" checked style="margin: 0;">
                        <span>ğŸ”„ ìë™ìƒˆë¡œê³ ì¹¨</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="external-access-toggle" checked style="margin: 0;">
                        <span>ğŸŒ ì™¸ë¶€ì ‘ì†</span>
                        <span id="external-access-badge" style="font-size: 0.7em; color: #28a745; margin-left: 5px; background: rgba(40, 167, 69, 0.1); padding: 2px 6px; border-radius: 10px; border: 1px solid rgba(40, 167, 69, 0.3);" title="ì™¸ë¶€ API/ì›¹ ê²€ìƒ‰ í—ˆìš©ë¨">ğŸŸ¢ í™œì„±</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="upload-section">
            <h2>ğŸ“ ë¬¸ì„œ ì—…ë¡œë“œ ë° ì²˜ë¦¬</h2>
            <form id="upload-form">
                <label for="pdf-file">ğŸ“„ PDF ì„ íƒ:</label>
                <input type="file" id="pdf-file" name="files" accept=".pdf" multiple required>
                
                <!-- ì„ íƒëœ íŒŒì¼ ëª©ë¡ í‘œì‹œ -->
                <div id="selected-files-container" style="display:none; margin-top:15px;">
                    <h4 style="margin: 10px 0; color: #495057;">ğŸ“‹ ì„ íƒëœ íŒŒì¼ ëª©ë¡:</h4>
                    <div id="selected-files-list" style="max-height: 200px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 8px; padding: 10px; background: #f8f9fa;">
                        <!-- ì„ íƒëœ íŒŒì¼ë“¤ì´ ì—¬ê¸°ì— ì²´í¬ë°•ìŠ¤ì™€ í•¨ê»˜ í‘œì‹œë©ë‹ˆë‹¤ -->
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                        <button type="button" id="select-all-btn" style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 0.9em;">ì „ì²´ ì„ íƒ</button>
                        <button type="button" id="deselect-all-btn" style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 0.9em;">ì „ì²´ í•´ì œ</button>
                        <span id="selected-count" style="font-size: 0.9em; color: #6c757d;">0ê°œ íŒŒì¼ ì„ íƒë¨</span>
                    </div>
                </div>
                
                <button type="submit" id="upload-submit-btn">ğŸš€ ì—…ë¡œë“œ ë° ì²˜ë¦¬</button>
            </form>
            <div id="upload-status" class="status-message"></div>
            <div id="progress-container" style="display:none; margin-top:15px; border:1px solid #ddd; border-radius:8px; padding:15px; background:#f8f9fa;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4 style="margin: 0; color: #495057;">â³ íŒŒì¼ ì²˜ë¦¬ ì§„í–‰ ìƒí™©</h4>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button id="stop-processing" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.8em; cursor: pointer;" title="í˜„ì¬ ì²˜ë¦¬ ì¤‘ë‹¨">â¹ ì¤‘ë‹¨</button>
                        <button id="hide-progress" style="background: none; border: none; font-size: 1.2em; cursor: pointer; color: #6c757d;" title="ì§„í–‰ë¥  ì°½ ìˆ¨ê¸°ê¸°">âœ•</button>
                    </div>
                </div>
                
                <!-- ì „ì²´ ì§„í–‰ë¥  -->
                <div id="overall-progress" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span id="overall-progress-text">ì „ì²´ ì§„í–‰ë¥ </span>
                        <span id="overall-progress-count">0/0 ì™„ë£Œ</span>
                    </div>
                    <div id="overall-progress-bar-container" style="height:8px; background:#e0e0e0; border-radius:4px; overflow:hidden; display: none;">
                        <div id="overall-progress-bar" style="height:100%; width:0%; background:#28a745; transition:width 0.3s;"></div>
                    </div>
                </div>
                
                <!-- ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ì»¨í…Œì´ë„ˆ -->
                <div id="individual-progress-container">
                    <!-- ê°œë³„ íŒŒì¼ ì§„í–‰ë¥ ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
                </div>
                
                <!-- ì™„ë£Œ í›„ ìë™ ìˆ¨ê¹€ ì„¤ì • -->
                <div style="margin-top: 10px; font-size: 0.9em; color: #6c757d; text-align: center;">
                    <label>
                        <input type="checkbox" id="auto-hide-progress" checked style="margin-right: 5px;">
                        ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ ì‹œ ìë™ìœ¼ë¡œ ìˆ¨ê¸°ê¸° (10ì´ˆ í›„)
                    </label>
                </div>
            </div>
        </div>

        <div class="document-management-section">
            <h2>ğŸ“š ë¬¸ì„œ ê´€ë¦¬ 
                <span id="auto-refresh-indicator" style="font-size: 0.8em; color: #28a745; margin-left: 10px;">
                    ğŸ”„ ìë™ ìƒˆë¡œê³ ì¹¨ í™œì„±í™”
                </span>
            </h2>
            <div style="margin-bottom:15px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                <button id="refresh-documents" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">ğŸ”„ ë¬¸ì„œìƒˆë¡œê³ ì¹¨</button>
                <button id="storage-stats" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">ğŸ“Š ë¬¸ì„œí†µê³„</button>
                <button id="cleanup-duplicates" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">ğŸ” ì¤‘ë³µì •ë¦¬</button>
                <button id="sort-documents" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">ğŸ“ ë¬¸ì„œì •ë ¬</button>
                <button id="cleanup-files" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">ğŸ§¹ íŒŒì¼ì •ë¦¬</button>
                <button id="delete-all-documents" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap; background:#dc3545; color:white;">ğŸ—‘ï¸ ì „ì²´ì‚­ì œ</button>
            </div>
            
            <div id="document-list" style="max-height:200px; overflow-y:auto; border:1px solid #ddd; padding:10px; margin-bottom:15px;">
                <!-- ë¬¸ì„œ ëª©ë¡ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
            
            <div id="management-status" class="status-message"></div>
        </div>

        <div class="chat-section">
            <h2>ğŸ’¬ ì±—ë´‡ì—ê²Œ ë¬¼ì–´ë³´ê¸°</h2>
            <!-- ë¬¸ì„œ ì„ íƒ ì˜ì—­ -->
            <div style="background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                    <span style="font-size: 1.1em;">ğŸ“‹</span>
                    <label style="font-weight: 600; color: #495057; margin: 0;">ë¬¸ì„œ ì„ íƒ</label>
                    <span id="document-info" style="font-size: 0.85em; color: #6c757d; margin-left: auto;"></span>
                </div>
                
                <!-- ì „ì²´ ë¬¸ì„œ ì„ íƒ -->
                <div style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 10px; margin: 0; cursor: pointer;">
                        <input type="checkbox" id="select-all-docs" checked style="margin: 0; transform: scale(1.1);">
                        <span style="font-weight: 600; color: #495057;">ğŸ“‘ ì „ì²´ ë¬¸ì„œ</span>
                        <span style="font-size: 0.8em; color: #6c757d; margin-left: auto;">ëª¨ë“  ì €ì¥ëœ ë¬¸ì„œ ì‚¬ìš©</span>
                    </label>
                </div>
                
                <!-- íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì„¹ì…˜ -->
                <div id="specific-doc-section" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 12px; margin-bottom: 10px; display: none;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <input type="checkbox" id="select-specific-docs" style="margin: 0; transform: scale(1.1);">
                        <span style="font-weight: 600; color: #495057;">ğŸ“„ íŠ¹ì • ë¬¸ì„œ ì„ íƒ</span>
                        <span style="font-size: 0.8em; color: #6c757d; margin-left: auto;">ì›í•˜ëŠ” ë¬¸ì„œë§Œ ì„ íƒ</span>
                    </div>
                    
                    <!-- ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ -->
                    <div id="individual-doc-container" style="display: none; margin-left: 24px; padding-top: 8px; border-top: 1px solid #e9ecef;">
                        <div style="font-size: 0.9em; color: #6c757d; margin-bottom: 8px;">
                            ğŸ¯ ë¬¸ì„œë¥¼ ì„ íƒí•˜ì„¸ìš”:
                        </div>
                        <div id="individual-doc-checkboxes" style="max-height: 140px; overflow-y: auto; padding-right: 4px;">
                            <!-- ê°œë³„ ë¬¸ì„œ ì²´í¬ë°•ìŠ¤ ë¦¬ìŠ¤íŠ¸ê°€ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Compact Horizontal Chat Progress Indicator -->
            <div id="chat-progress" class="chat-progress">
                <div class="progress-header">
                    <div class="progress-title">
                        <span class="progress-icon">ğŸ¤–</span>
                        <span id="progress-main-text">AI ë‹µë³€ ìƒì„± ì¤‘...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-time" id="progress-timer">0ì´ˆ</span>
                    </div>
                </div>
                
                <div class="progress-bar-container">
                    <div class="progress-bar" id="overall-progress-bar"></div>
                </div>
                
                <div class="chat-progress-steps">
                    <div class="progress-step" data-step="query">
                        <div class="progress-step-icon" data-step="1"></div>
                        <span class="step-title">ì§ˆë¬¸ë¶„ì„</span>
                        <div class="step-status" id="query-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="embedding">
                        <div class="progress-step-icon" data-step="2"></div>
                        <span class="step-title">ì„ë² ë”©</span>
                        <div class="step-status" id="embedding-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="search">
                        <div class="progress-step-icon" data-step="3"></div>
                        <span class="step-title">ë¬¸ì„œê²€ìƒ‰</span>
                        <div class="step-status" id="search-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="generate">
                        <div class="progress-step-icon" data-step="4"></div>
                        <span class="step-title">ë‹µë³€ìƒì„±</span>
                        <div class="step-status" id="generate-status">
                            <div class="response-length" id="response-length" style="display: none;">0ì</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="chat-history">
                <!-- ì±„íŒ… ë©”ì‹œì§€ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
            <div class="chat-input-container">
                <button id="new-chat-button" class="btn btn-success" title="ìƒˆ ëŒ€í™” ì‹œì‘í•˜ê¸°" style="background:#28a745; margin-right: 10px;">ğŸ”„ ìƒˆ ëŒ€í™”</button>
                <input type="text" id="chat-input" placeholder="ğŸ’­ ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”...">
                <button id="send-button" class="btn btn-primary">ğŸ’¬ ì „ì†¡</button>
            </div>
            <div id="chat-status" class="status-message"></div>
        </div>
    </div>

    <script>
        const uploadForm = document.getElementById('upload-form');
        const pdfFile = document.getElementById('pdf-file');
        const uploadStatus = document.getElementById('upload-status');

        const chatHistory = document.getElementById('chat-history');
        const chatMessages = document.getElementById('chat-history'); // Same as chatHistory for message container
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const chatStatus = document.getElementById('chat-status');

        // Streaming control
        let currentStreamAbortController = null;
        let isStreaming = false;
        
        // Conversation history management
        let conversationHistory = [];
        const MAX_HISTORY_LENGTH = 10; // ìµœê·¼ 10ê°œ ëŒ€í™”ë§Œ ìœ ì§€
        
        // Make functions global for debugging
        window.debugStopStreaming = function() {
            console.log('Manual stop streaming called');
            console.log('isStreaming:', isStreaming);
            console.log('currentStreamAbortController:', currentStreamAbortController);
            stopStreaming();
        };

        // Debug conversation history
        window.debugConversationHistory = function() {
            console.log('Current conversation history:', conversationHistory);
            console.log('Total messages:', conversationHistory.length);
            conversationHistory.forEach((msg, index) => {
                console.log(`${index + 1}. ${msg.role}: ${msg.content.substring(0, 100)}...`);
            });
        };

        // íŒŒì¼ ì—…ë¡œë“œ ì§„í–‰ë¥  ê´€ë¦¬
        function initializeUploadProgress(selectedFiles) {
            const progressContainer = document.getElementById('progress-container');
            const uploadStatus = document.getElementById('upload-status');
            
            // ì§„í–‰ë¥  ì»¨í…Œì´ë„ˆ í‘œì‹œ
            progressContainer.style.display = 'block';
            
            // ì „ì²´ ì§„í–‰ë¥  ì´ˆê¸°í™”
            updateOverallProgress(0, selectedFiles.length, 'ì—…ë¡œë“œ ì¤€ë¹„ ì¤‘...');
            
            // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ì´ˆê¸°í™”
            initializeFileProgressBars(selectedFiles);
            
            // ìƒíƒœ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
            uploadStatus.textContent = `${selectedFiles.length}ê°œ íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘...`;
            uploadStatus.className = 'status-message status-info';
        }

        function initializeFileProgressBars(files) {
            const progressList = document.getElementById('progress-list') || createProgressList();
            progressList.innerHTML = '';

            files.forEach((file, index) => {
                const progressItem = document.createElement('div');
                progressItem.className = 'file-progress-item';
                progressItem.id = `file-progress-${index}`;
                progressItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="file-icon">ğŸ“„</span>
                            <div>
                                <div class="file-name" style="font-weight: 500; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${file.name}</div>
                                <div class="file-size" style="font-size: 0.8em; color: #666;">${(file.size / 1024 / 1024).toFixed(1)} MB</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="upload-percentage">0%</span>
                            <span class="upload-status-text">ëŒ€ê¸° ì¤‘</span>
                        </div>
                    </div>
                    <div class="progress-bar-container" style="width: 100%; height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden;">
                        <div class="progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4CAF50, #45a049); transition: width 0.3s ease;"></div>
                    </div>
                `;
                progressList.appendChild(progressItem);
            });
        }

        function createProgressList() {
            const progressContainer = document.getElementById('progress-container');
            const progressList = document.createElement('div');
            progressList.id = 'progress-list';
            progressList.style.cssText = 'margin-top: 15px; max-height: 300px; overflow-y: auto;';
            
            // ì œëª© ì¶”ê°€
            const title = document.createElement('h5');
            title.textContent = 'ğŸ“ ê°œë³„ íŒŒì¼ ì—…ë¡œë“œ ì§„í–‰ë¥ ';
            title.style.cssText = 'margin: 0 0 10px 0; color: #495057; font-size: 0.95em;';
            
            progressContainer.appendChild(title);
            progressContainer.appendChild(progressList);
            return progressList;
        }

        function updateFileProgress(fileIndex, percentage, status = '') {
            const progressItem = document.getElementById(`file-progress-${fileIndex}`);
            if (!progressItem) return;

            const progressBar = progressItem.querySelector('.progress-bar');
            const percentageSpan = progressItem.querySelector('.upload-percentage');
            const statusSpan = progressItem.querySelector('.upload-status-text');
            const fileIcon = progressItem.querySelector('.file-icon');

            if (progressBar) progressBar.style.width = `${percentage}%`;
            if (percentageSpan) percentageSpan.textContent = `${Math.round(percentage)}%`;
            if (statusSpan && status) statusSpan.textContent = status;

            // ìƒíƒœì— ë”°ë¥¸ ì•„ì´ì½˜ ë³€ê²½
            if (fileIcon) {
                if (percentage === 100) {
                    fileIcon.textContent = 'âœ…';
                    if (statusSpan) statusSpan.textContent = 'ì™„ë£Œ';
                } else if (percentage > 0) {
                    fileIcon.textContent = 'ğŸ“¤';
                } else {
                    fileIcon.textContent = 'ğŸ“„';
                }
            }

            // í”„ë¡œê·¸ë ˆìŠ¤ ë°” ìƒ‰ìƒ ë³€ê²½
            if (progressBar) {
                if (percentage === 100) {
                    progressBar.style.background = 'linear-gradient(90deg, #4CAF50, #45a049)';
                } else if (status.includes('ì˜¤ë¥˜')) {
                    progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                } else {
                    progressBar.style.background = 'linear-gradient(90deg, #2196F3, #1976D2)';
                }
            }
        }

        function updateOverallProgress(completed, total, message = '') {
            const progressText = document.getElementById('overall-progress-text');
            const progressCount = document.getElementById('overall-progress-count');
            const uploadStatus = document.getElementById('upload-status');

            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

            if (progressText) progressText.textContent = `ì „ì²´ ì§„í–‰ë¥  (${percentage}%)`;
            if (progressCount) progressCount.textContent = `${completed}/${total} ì™„ë£Œ`;
            if (uploadStatus && message) {
                uploadStatus.textContent = message;
                uploadStatus.className = percentage === 100 ? 'status-message status-success' : 'status-message status-info';
            }
        }

        async function uploadWithProgress(formData, selectedFiles) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();

                // ì—…ë¡œë“œ ì§„í–‰ë¥  ì¶”ì 
                xhr.upload.addEventListener('progress', (event) => {
                    if (event.lengthComputable) {
                        const percentComplete = (event.loaded / event.total) * 100;
                        
                        // ëª¨ë“  íŒŒì¼ì— ë™ì¼í•œ ì§„í–‰ë¥  ì ìš© (ì‹¤ì œë¡œëŠ” ì „ì²´ FormData ì§„í–‰ë¥ )
                        selectedFiles.forEach((file, index) => {
                            updateFileProgress(index, percentComplete, 'ì—…ë¡œë“œ ì¤‘...');
                        });
                        
                        updateOverallProgress(0, selectedFiles.length, `ì—…ë¡œë“œ ì¤‘... ${Math.round(percentComplete)}%`);
                    }
                });

                // ì—…ë¡œë“œ ì™„ë£Œ
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            const result = JSON.parse(xhr.responseText);
                            
                            // ê° íŒŒì¼ ì™„ë£Œ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
                            selectedFiles.forEach((file, index) => {
                                updateFileProgress(index, 100, 'ì—…ë¡œë“œ ì™„ë£Œ');
                            });
                            
                            updateOverallProgress(selectedFiles.length, selectedFiles.length, 'ëª¨ë“  íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ!');
                            
                            resolve({
                                success: true,
                                results: result.results || result
                            });
                        } catch (error) {
                            console.error('Response parsing error:', error);
                            reject(new Error('ì„œë²„ ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨'));
                        }
                    } else {
                        reject(new Error(`ì—…ë¡œë“œ ì‹¤íŒ¨: ${xhr.status} ${xhr.statusText}`));
                    }
                });

                // ì˜¤ë¥˜ ì²˜ë¦¬
                xhr.addEventListener('error', () => {
                    selectedFiles.forEach((file, index) => {
                        updateFileProgress(index, 0, 'ì—…ë¡œë“œ ì˜¤ë¥˜');
                    });
                    reject(new Error('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'));
                });

                // ìš”ì²­ ì „ì†¡
                xhr.open('POST', '/api/upload_pdf/');
                xhr.send(formData);
            });
        }

        // í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í•¨ìˆ˜
        function showToastMessage(message, type = 'info') {
            // ê¸°ì¡´ í† ìŠ¤íŠ¸ ì œê±°
            const existingToast = document.querySelector('.toast-message');
            if (existingToast) {
                existingToast.remove();
            }

            // í† ìŠ¤íŠ¸ ì—˜ë¦¬ë¨¼íŠ¸ ìƒì„±
            const toast = document.createElement('div');
            toast.className = `toast-message toast-${type}`;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                max-width: 400px;
                padding: 16px;
                background: ${type === 'info' ? '#e3f2fd' : type === 'warning' ? '#fff3e0' : '#ffebee'};
                border: 1px solid ${type === 'info' ? '#2196f3' : type === 'warning' ? '#ff9800' : '#f44336'};
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-size: 14px;
                line-height: 1.4;
                color: #333;
                white-space: pre-line;
                transform: translateX(100%);
                transition: transform 0.3s ease;
            `;

            // ë©”ì‹œì§€ ì„¤ì •
            toast.textContent = message;

            // DOMì— ì¶”ê°€
            document.body.appendChild(toast);

            // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
            setTimeout(() => {
                toast.style.transform = 'translateX(0)';
            }, 10);

            // ìë™ ì œê±° (5ì´ˆ í›„)
            setTimeout(() => {
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 5000);

            // í´ë¦­ ì‹œ ì œê±°
            toast.addEventListener('click', () => {
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            });
        }

        // THINK ë¸”ë¡ ìŠ¤íƒ€ì¼ë§ í•¨ìˆ˜ - ì¶”ë¡  ëª¨ë¸ì˜ ì‚¬ê³  ê³¼ì •ì„ ì°¨ë³„í™”í•´ì„œ í‘œì‹œ
        function styleThinkBlocks(text) {
            try {
                let processed = text;
                
                // ì¶”ë¡  ë¸”ë¡ íŒ¨í„´ë“¤ê³¼ í•´ë‹¹ ìŠ¤íƒ€ì¼ ì²˜ë¦¬
                const thinkPatterns = [
                    // <think> íƒœê·¸ í˜•íƒœ - QwQ ëª¨ë¸ í˜•ì‹ (ì†Œë¬¸ì)
                    {
                        pattern: /<think>([\s\S]*?)<\/think>/gim,
                        replacement: (match, content) => `
<div class="thinking-section" style="
    margin: 12px 0;
    padding: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #6c757d;
    border-radius: 8px;
    font-size: 0.85em;
    color: #495057;
    font-style: italic;
    opacity: 0.85;
">
    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-weight: 600; color: #6c757d;">
        ğŸ§  <span>Thinking...</span>
    </div>
    <div style="white-space: pre-wrap; line-height: 1.4;">${content.trim()}</div>
</div>`
                    },
                    // <THINK> íƒœê·¸ í˜•íƒœ - ëŒ€ë¬¸ì ë²„ì „ (í˜¸í™˜ì„±)
                    {
                        pattern: /<THINK>([\s\S]*?)<\/THINK>/gim,
                        replacement: (match, content) => `
<div class="thinking-section" style="
    margin: 12px 0;
    padding: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #6c757d;
    border-radius: 8px;
    font-size: 0.85em;
    color: #495057;
    font-style: italic;
    opacity: 0.85;
">
    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-weight: 600; color: #6c757d;">
        ğŸ§  <span>Thinking...</span>
    </div>
    <div style="white-space: pre-wrap; line-height: 1.4;">${content.trim()}</div>
</div>`
                    },
                    // THINK: í•œì¤„ íŒ¨í„´
                    {
                        pattern: /^THINK:\s*(.+)$/gm,
                        replacement: (match, content) => `
<div class="thinking-line" style="
    margin: 8px 0;
    padding: 8px 12px;
    background: rgba(108, 117, 125, 0.1);
    border-radius: 6px;
    font-size: 0.8em;
    color: #6c757d;
    font-style: italic;
    border-left: 2px solid #6c757d;
">
    ğŸ’­ ${content.trim()}
</div>`
                    },
                    // ë©€í‹°ë¼ì¸ THINK ë¸”ë¡
                    {
                        pattern: /THINK:\s*([\s\S]*?)(?=\n\n[A-Zê°€-í£]|\n\d+\.|\n-|\n\*|\n#|$)/gim,
                        replacement: (match, content) => `
<div class="thinking-section" style="
    margin: 12px 0;
    padding: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #6c757d;
    border-radius: 8px;
    font-size: 0.85em;
    color: #495057;
    font-style: italic;
    opacity: 0.85;
">
    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-weight: 600; color: #6c757d;">
        ğŸ§  <span>Thinking...</span>
    </div>
    <div style="white-space: pre-wrap; line-height: 1.4;">${content.trim()}</div>
</div>`
                    }
                ];
                
                // ê° íŒ¨í„´ì— ëŒ€í•´ ìŠ¤íƒ€ì¼ë§ ì ìš©
                thinkPatterns.forEach(({ pattern, replacement }) => {
                    processed = processed.replace(pattern, replacement);
                });
                
                // í•œêµ­ì–´ ì¶”ë¡  íŒ¨í„´ë“¤ì„ ê°„ë‹¨í•œ ìŠ¤íƒ€ì¼ë¡œ ì²˜ë¦¬
                const koreanThinkPatterns = [
                    /^ìƒê°:\s*(.+)$/gm,
                    /^ë¶„ì„:\s*(.+)$/gm,
                    /^ì¶”ë¡ :\s*(.+)$/gm
                ];
                
                koreanThinkPatterns.forEach(pattern => {
                    processed = processed.replace(pattern, (match, content) => `
<div class="thinking-line" style="
    margin: 8px 0;
    padding: 8px 12px;
    background: rgba(108, 117, 125, 0.1);
    border-radius: 6px;
    font-size: 0.8em;
    color: #6c757d;
    font-style: italic;
    border-left: 2px solid #6c757d;
">
    ğŸ’­ ${content.trim()}
</div>`);
                });
                
                // ì—°ì†ëœ ë¹ˆ ì¤„ ì •ë¦¬
                processed = processed.replace(/\n{3,}/g, '\n\n').trim();
                
                return processed;
            } catch (error) {
                console.warn('THINK block styling failed:', error);
                return text; // ì‹¤íŒ¨ ì‹œ ì›ë³¸ í…ìŠ¤íŠ¸ ë°˜í™˜
            }
        }

        // ì•ˆì •ì ì¸ ì‹¤ì‹œê°„ THINK ë¸”ë¡ ë Œë”ë§ í•¨ìˆ˜
        function renderStreamingWithThinkBlocks(messageElement, fullText) {
            if (!window.marked) {
                messageElement.textContent = fullText;
                return;
            }

            try {
                // ë©”ì‹œì§€ ìš”ì†Œì— ì²˜ë¦¬ëœ THINK ë¸”ë¡ ê¸°ë¡ ì €ì¥
                if (!messageElement.processedThinkBlocks) {
                    messageElement.processedThinkBlocks = new Set();
                }
                if (!messageElement.isAnswerStarted) {
                    messageElement.isAnswerStarted = false;
                }
                
                // ì°¸ê³ ë¬¸í—Œì€ ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ í›„ í›„ì²˜ë¦¬ë¨

                let processedHTML = '';
                let remainingText = fullText;
                
                // ì™„ì„±ëœ <think> ë¸”ë¡ë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬
                const completedThinkMatches = fullText.match(/<think>[\s\S]*?<\/think>/gi) || [];
                
                completedThinkMatches.forEach((match, index) => {
                    const content = match.replace(/<\/?think>/gi, '').trim();
                    const thinkId = `think-block-${index}`;
                    
                    // ì´ë¯¸ ì²˜ë¦¬ëœ THINK ë¸”ë¡ì¸ì§€ í™•ì¸
                    if (!messageElement.processedThinkBlocks.has(thinkId)) {
                        // ë‹µë³€ì´ ì‹œì‘ë˜ì—ˆëŠ”ì§€ì— ë”°ë¼ open ì†ì„± ê²°ì •
                        const isOpen = !messageElement.isAnswerStarted;
                        const openAttr = isOpen ? 'open' : '';
                        const statusText = messageElement.isAnswerStarted ? '(ë‹µë³€ ì™„ë£Œë¨)' : '(ì™„ë£Œ)';
                        
                        // ìƒˆë¡œìš´ ì™„ì„±ëœ THINK ë¸”ë¡ ìƒì„±
                        const thinkHTML = `
<details class="thinking-accordion" id="${thinkId}" ${openAttr} style="
    margin: 12px 0;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    background: #f8f9fa;
">
    <summary style="
        cursor: pointer;
        padding: 12px;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 7px;
        font-weight: 600;
        color: #6c757d;
        display: flex;
        align-items: center;
        gap: 8px;
        user-select: none;
    ">
        ğŸ’­ <span>thinking process</span>
        <span style="font-size: 0.8em; margin-left: auto; opacity: 0.7;">${statusText}</span>
    </summary>
    <div style="
        padding: 12px;
        font-size: 0.85em;
        color: #495057;
        font-style: italic;
        line-height: 1.4;
        white-space: pre-wrap;
        border-top: 1px solid #dee2e6;
        background: #ffffff;
    ">${escapeHtml(content)}</div>
</details>`;
                        processedHTML += thinkHTML;
                        messageElement.processedThinkBlocks.add(thinkId);
                    } else {
                        // ì´ë¯¸ ì²˜ë¦¬ëœ ë¸”ë¡ì€ ê¸°ì¡´ DOMì—ì„œ ê°€ì ¸ì˜´
                        const existingBlock = messageElement.querySelector(`#${thinkId}`);
                        if (existingBlock) {
                            processedHTML += existingBlock.outerHTML;
                        }
                    }
                    
                    // ì²˜ë¦¬ëœ THINK ë¸”ë¡ì„ í…ìŠ¤íŠ¸ì—ì„œ ì œê±°
                    remainingText = remainingText.replace(match, '');
                });

                // ì§„í–‰ ì¤‘ì¸ THINK ë¸”ë¡ ì²˜ë¦¬ (ì™„ì„±ë˜ì§€ ì•Šì€ ê²ƒ)
                const incompleteThinkMatch = remainingText.match(/<think>[\s\S]*?$/i);
                if (incompleteThinkMatch) {
                    const incompleteContent = incompleteThinkMatch[0].replace(/<think>/i, '').trim();
                    processedHTML += `
<div class="thinking-section streaming" style="
    margin: 12px 0;
    padding: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #6c757d;
    border-radius: 8px;
    font-size: 0.85em;
    color: #495057;
    font-style: italic;
    opacity: 0.85;
">
    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-weight: 600; color: #6c757d;">
        ğŸ’­ <span>thinking...</span>
        <span class="typing-cursor">â–</span>
    </div>
    <div style="white-space: pre-wrap; line-height: 1.4;">${escapeHtml(incompleteContent)}</div>
</div>`;
                    // ì§„í–‰ ì¤‘ì¸ THINK ë¸”ë¡ë„ í…ìŠ¤íŠ¸ì—ì„œ ì œê±°
                    remainingText = remainingText.replace(incompleteThinkMatch[0], '');
                }

                // ì‹¤ì œ ë‹µë³€ì´ ì‹œì‘ë˜ì—ˆëŠ”ì§€ í™•ì¸
                const cleanAnswer = remainingText.trim();
                if (cleanAnswer.length > 30 && !messageElement.isAnswerStarted) {
                    messageElement.isAnswerStarted = true;
                    console.log('ë‹µë³€ ì‹œì‘ë¨ - THINK ë¸”ë¡ ì ‘ê¸° ì‹œì‘');
                }
                
                // ì¼ë°˜ ë‹µë³€ í…ìŠ¤íŠ¸ ì²˜ë¦¬ (ì°¸ê³ ë¬¸í—Œì€ ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ í›„ í›„ì²˜ë¦¬ë¨)
                let answerHTML = '';
                if (cleanAnswer) {
                    // ë¶ˆì™„ì „í•œ HTML íƒœê·¸ë“¤ í•„í„°ë§ (ì°¸ê³ ë¬¸í—Œ ì¡°ê°ë“¤ ì œê±°)
                    let filteredText = cleanAnswer;
                    
                    // ë‹¨ë…ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” HTML íƒœê·¸ë“¤ ì œê±° (ì¤„ ì „ì²´ê°€ íƒœê·¸ì¸ ê²½ìš°)
                    filteredText = filteredText.replace(/^\s*<\/?(?:details|summary|div|span)[^>]*>\s*$/gm, '');
                    
                    // ê³µë°±ë§Œ ë‚¨ì€ ì¤„ë“¤ ì œê±°
                    filteredText = filteredText.replace(/^\s*$/gm, '').trim();
                    
                    // í•„í„°ë§ í›„ ë¹ˆ ë‚´ìš©ì´ë©´ ìŠ¤í‚µ
                    if (!filteredText) {
                        return;
                    }
                    
                    // í•„í„°ë§ëœ í…ìŠ¤íŠ¸ë¡œ ê³„ì† ì²˜ë¦¬
                    const processedText = filteredText;
                    // ì½”ë“œ ë¸”ë¡ ê²½ê³„ ê°ì§€ (ë¶ˆì™„ì „í•œ ì½”ë“œ ë¸”ë¡ ì²˜ë¦¬)
                    const codeBlockPattern = /```[\s\S]*?```/g;
                    const incompleteCodeBlockPattern = /```[\s\S]*$/;
                    
                    // ë¶ˆì™„ì „í•œ ì½”ë“œ ë¸”ë¡ì´ ìˆëŠ”ì§€ í™•ì¸
                    const hasIncompleteCodeBlock = incompleteCodeBlockPattern.test(processedText);
                    
                    let textToRender = processedText;
                    let incompleteContent = '';
                    
                    if (hasIncompleteCodeBlock) {
                        // ë¶ˆì™„ì „í•œ ì½”ë“œ ë¸”ë¡ì„ ë¶„ë¦¬
                        const match = processedText.match(/^([\s\S]*?)(```[\s\S]*)$/);
                        if (match) {
                            textToRender = match[1]; // ì™„ì„±ëœ ë¶€ë¶„
                            incompleteContent = match[2]; // ë¶ˆì™„ì „í•œ ì½”ë“œ ë¸”ë¡
                        }
                    } else {
                        // ë§ˆì§€ë§‰ ì¤„ì€ ì•„ì§ ì‘ì„± ì¤‘ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë¶„ë¦¬
                        const answerLines = processedText.split('\n');
                        if (answerLines.length > 1) {
                            const completedAnswerLines = answerLines.slice(0, -1);
                            const currentAnswerLine = answerLines[answerLines.length - 1];
                            
                            textToRender = completedAnswerLines.join('\n');
                            incompleteContent = currentAnswerLine;
                        }
                    }

                    // ì™„ì„±ëœ ë¶€ë¶„ ë Œë”ë§
                    if (textToRender && textToRender.trim()) {
                        try {
                            answerHTML = window.marked.parse(textToRender);
                            answerHTML = cleanIncompleteHTML(answerHTML);
                            answerHTML = enhanceMarkdownRendering(answerHTML);
                        } catch (e) {
                            console.warn('Markdown parsing failed for completed text:', e);
                            answerHTML = `<p>${escapeHtml(textToRender)}</p>`;
                        }
                    }

                    // ë¶ˆì™„ì „í•œ ë¶€ë¶„ ì²˜ë¦¬ (ì½”ë“œ ë¸”ë¡ì´ê±°ë‚˜ í˜„ì¬ ì¤„)
                    if (incompleteContent && incompleteContent.trim()) {
                        if (hasIncompleteCodeBlock) {
                            // ë¶ˆì™„ì „í•œ ì½”ë“œ ë¸”ë¡ì„ ìŠ¤íƒ€ì¼ë§ëœ í”„ë¦¬ë·°ë¡œ í‘œì‹œ
                            const content = incompleteContent.replace(/^```\w*\n?/, '').trim();
                            answerHTML += `
<pre style="
    background-color: #f8f9fa; 
    padding: 1rem; 
    border-radius: 4px; 
    overflow-x: auto; 
    border-left: 4px solid #007bff;
    position: relative;
    border: 1px dashed #dee2e6;
"><code>${escapeHtml(content)}<span class="typing-cursor">â–</span></code>
<div style="
    position: absolute; 
    top: 5px; 
    right: 10px; 
    font-size: 0.8em; 
    color: #6c757d; 
    background: rgba(255,255,255,0.8); 
    padding: 2px 6px; 
    border-radius: 3px;
">ì‘ì„± ì¤‘...</div>
</pre>`;
                        } else {
                            // ì¼ë°˜ í…ìŠ¤íŠ¸ ì¤„ ì²˜ë¦¬
                            if (incompleteContent.includes('**') || incompleteContent.includes('*') || 
                                incompleteContent.includes('`') || incompleteContent.includes('#')) {
                                try {
                                    let currentLineHTML = window.marked.parse(incompleteContent);
                                    currentLineHTML = cleanIncompleteHTML(currentLineHTML);
                                    answerHTML += currentLineHTML.replace('</p>', '<span class="typing-cursor">â–</span></p>');
                                } catch (e) {
                                    answerHTML += `<p>${escapeHtml(incompleteContent)}<span class="typing-cursor">â–</span></p>`;
                                }
                            } else {
                                answerHTML += `<p>${escapeHtml(incompleteContent)}<span class="typing-cursor">â–</span></p>`;
                            }
                        }
                    }
                }

                // ìµœì¢… HTML ì„¤ì •
                messageElement.innerHTML = processedHTML + answerHTML;
                
                // DOM ì—…ë°ì´íŠ¸ í›„ THINK ë¸”ë¡ ì´ë²¤íŠ¸ ì„¤ì • (í•­ìƒ ì‹¤í–‰)
                setTimeout(() => {
                    const allAccordions = messageElement.querySelectorAll('.thinking-accordion');
                    allAccordions.forEach(accordion => {
                        setupThinkBlockToggle(accordion);
                        
                        // ë‹µë³€ì´ ì‹œì‘ë˜ì—ˆìœ¼ë©´ ì ‘í˜ ìƒíƒœ ë³´ì¥
                        if (messageElement.isAnswerStarted) {
                            accordion.removeAttribute('open');
                            accordion.open = false;
                        }
                    });
                }, 10);

            } catch (error) {
                console.warn('Markdown rendering error during streaming:', error);
                // ì˜¤ë¥˜ ì‹œ í…ìŠ¤íŠ¸ë¡œ fallback
                messageElement.textContent = fullText + 'â–';
            }
        }

        // THINK ë¸”ë¡ ì ‘í˜ ê´€ë¦¬ í•¨ìˆ˜
        function collapseThinkBlocks(messageElement) {
            const allAccordions = messageElement.querySelectorAll('.thinking-accordion');
            allAccordions.forEach(accordion => {
                // open ì†ì„±ê³¼ property ëª¨ë‘ ì œê±°í•˜ì—¬ ì ‘ê¸°
                accordion.removeAttribute('open');
                accordion.open = false;
                
                // ìƒíƒœ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                const statusSpan = accordion.querySelector('summary span:last-child');
                if (statusSpan && !statusSpan.textContent.includes('ë‹µë³€ ì™„ë£Œë¨')) {
                    statusSpan.textContent = '(ë‹µë³€ ì™„ë£Œë¨)';
                }
                
                // ìˆ˜ë™ í† ê¸€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (ì¤‘ë³µ ë°©ì§€)
                setupThinkBlockToggle(accordion);
            });
        }

        // THINK ë¸”ë¡ í† ê¸€ ì´ë²¤íŠ¸ ì„¤ì •
        function setupThinkBlockToggle(accordion) {
            const summary = accordion.querySelector('summary');
            if (summary && !summary.hasAttribute('data-event-attached')) {
                summary.setAttribute('data-event-attached', 'true');
                
                // ê¸°ë³¸ ë™ì‘ ë°©ì§€í•˜ê³  ìˆ˜ë™ ì œì–´
                summary.addEventListener('click', function(e) {
                    e.preventDefault(); // ê¸°ë³¸ details ë™ì‘ ë°©ì§€
                    e.stopPropagation(); // ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€
                    
                    // ë‹µë³€ ì™„ë£Œ í›„ì—ëŠ” í† ê¸€ í—ˆìš©
                    const statusSpan = accordion.querySelector('summary span:last-child');
                    const isCompleted = statusSpan && (
                        statusSpan.textContent.includes('ì™„ë£Œ') || 
                        statusSpan.textContent.includes('ë‹µë³€ ì™„ë£Œë¨')
                    );
                    
                    if (isCompleted) {
                        // ìˆ˜ë™ í† ê¸€ (DOM ì¡°ì‘ìœ¼ë¡œ ì§ì ‘ ì œì–´)
                        const isCurrentlyOpen = accordion.hasAttribute('open') || accordion.open;
                        
                        if (isCurrentlyOpen) {
                            accordion.removeAttribute('open');
                            accordion.open = false;
                            console.log('THINK ë¸”ë¡ì´ ìˆ˜ë™ìœ¼ë¡œ ì ‘í˜€ì§');
                        } else {
                            accordion.setAttribute('open', '');
                            accordion.open = true;
                            console.log('THINK ë¸”ë¡ì´ ìˆ˜ë™ìœ¼ë¡œ í¼ì³ì§');
                        }
                    } else {
                        console.log('THINK ë¸”ë¡ì´ ì•„ì§ ì™„ë£Œë˜ì§€ ì•ŠìŒ - í† ê¸€ ë¶ˆê°€');
                    }
                });
            }
        }

        // ë‹µë³€ ì™„ë£Œ í›„ THINK ë¸”ë¡ ìµœì¢… ìƒíƒœ ì„¤ì •
        function finalizeThinkBlocks(messageElement) {
            const allAccordions = messageElement.querySelectorAll('.thinking-accordion');
            allAccordions.forEach(accordion => {
                // ìµœì¢… ì ‘í˜ ìƒíƒœë¡œ ê³ ì • (DOM propertyì™€ attribute ëª¨ë‘ ì„¤ì •)
                accordion.removeAttribute('open');
                accordion.open = false;
                
                // í† ê¸€ ì´ë²¤íŠ¸ ì„¤ì • (ì•„ì§ ì„¤ì •ë˜ì§€ ì•Šì•˜ë‹¤ë©´)
                setupThinkBlockToggle(accordion);
                
                // ìµœì¢… ìƒíƒœ í…ìŠ¤íŠ¸ë¡œ ì—…ë°ì´íŠ¸
                const statusSpan = accordion.querySelector('summary span:last-child');
                if (statusSpan) {
                    statusSpan.textContent = '(ì™„ë£Œ)';
                    statusSpan.style.color = '#28a745';
                }
                
                // summary ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ (ì™„ë£Œ ìƒíƒœ)
                const summary = accordion.querySelector('summary');
                if (summary) {
                    summary.style.background = 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)';
                    summary.style.opacity = '0.8';
                }
            });
        }
        
        // ê¸°ì¡´ renderStreamingMarkdown í•¨ìˆ˜ëŠ” í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€
        function renderStreamingMarkdown(messageElement, fullText) {
            return renderStreamingWithThinkBlocks(messageElement, fullText);
        }

        // HTML íƒœê·¸ ì´ìŠ¤ì¼€ì´í”„ í•¨ìˆ˜
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ë§ˆí¬ë‹¤ìš´ ë Œë”ë§ í›„ì²˜ë¦¬ í•¨ìˆ˜
        function enhanceMarkdownRendering(html) {
            try {
                // ì„ì‹œ divì—ì„œ HTML ì²˜ë¦¬
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;

                // ìƒ‰ê¹” ê°•ì¡° ì²˜ë¦¬ - ì´ëª¨ì§€ê°€ í¬í•¨ëœ strong íƒœê·¸ë“¤
                const strongElements = tempDiv.querySelectorAll('strong');
                strongElements.forEach(strong => {
                    const text = strong.textContent;
                    
                    if (text.includes('ğŸ”´')) {
                        strong.style.cssText = 'color: #dc3545; background: rgba(220, 53, 69, 0.1); padding: 3px 8px; border-radius: 5px; border: 1px solid rgba(220, 53, 69, 0.2);';
                    } else if (text.includes('ğŸŸ¡')) {
                        strong.style.cssText = 'color: #fd7e14; background: rgba(255, 193, 7, 0.1); padding: 3px 8px; border-radius: 5px; border: 1px solid rgba(255, 193, 7, 0.3);';
                    } else if (text.includes('ğŸŸ¢')) {
                        strong.style.cssText = 'color: #28a745; background: rgba(40, 167, 69, 0.1); padding: 3px 8px; border-radius: 5px; border: 1px solid rgba(40, 167, 69, 0.2);';
                    } else if (text.includes('ğŸ”µ')) {
                        strong.style.cssText = 'color: #007bff; background: rgba(0, 123, 255, 0.1); padding: 3px 8px; border-radius: 5px; border: 1px solid rgba(0, 123, 255, 0.2);';
                    }
                    
                    // ì„¹ì…˜ ì œëª© ì´ëª¨ì§€ ê°•í™”
                    if (text.match(/^(ğŸ“Š|ğŸ¯|ğŸ“‹|ğŸ“ˆ|ğŸ’¡|âš¡|ğŸ”§|ğŸ­|ğŸ”¬|âœ¨)/)) {
                        strong.style.cssText += ' font-size: 1.1em; display: inline-block; margin-bottom: 0.5rem; padding: 0.3rem 0.8rem; border-radius: 6px;';
                    }
                });

                // ì´ëª¨ì§€ ê¸°ë°˜ ì„¹ì…˜ ì œëª© ì²˜ë¦¬
                const paragraphs = tempDiv.querySelectorAll('p');
                paragraphs.forEach(p => {
                    const text = p.textContent;
                    if (text.match(/^(ğŸ“Š|ğŸ¯|ğŸ“‹|ğŸ“ˆ|ğŸ’¡|âš¡|ğŸ”§|ğŸ­|ğŸ”¬|âœ¨)/)) {
                        p.style.cssText = 'font-weight: 600; color: #2c3e50; margin-top: 1.5rem; margin-bottom: 0.5rem; padding: 0.5rem 0; border-bottom: 2px solid #e9ecef;';
                    }
                });

                // ìˆ˜ì¹˜ ë°ì´í„° ì‹œê°í™” í”„ë¡œê·¸ë ˆìŠ¤ ë°” ì²˜ë¦¬ (ë§¤ìš° ì œí•œì ìœ¼ë¡œë§Œ ì ìš©)
                const codeBlocks = tempDiv.querySelectorAll('pre code');
                codeBlocks.forEach(code => {
                    const text = code.textContent;
                    // ë§¤ìš° ì—„ê²©í•œ ì¡°ê±´: í”„ë¡œê·¸ë ˆìŠ¤ ë°” íŒ¨í„´ì´ ëª…í™•íˆ ìˆê³ , ë‹¤ë¥¸ ì½”ë“œê°€ ì—†ì„ ë•Œë§Œ ì²˜ë¦¬
                    const hasProgressPattern = /(.+?):\s*(â–ˆ+â–‘*)\s*(\d+%)/g.test(text);
                    const looksLikeProgressOnly = text.split('\n').every(line => 
                        line.trim() === '' || 
                        line.includes('â–ˆ') && line.includes('%') ||
                        line.match(/^(íƒ•êµ¬ë¹„|ëŸ¬ë„ˆë¹„|ì¸ê²Œì´íŠ¸ë¹„|ë¹„ìœ¨|ì„¤ê³„|ì£¼ì¡°)/i)
                    );
                    
                    if (hasProgressPattern && looksLikeProgressOnly && text.length < 500) {
                        // í”„ë¡œê·¸ë ˆìŠ¤ ë°”ê°€ í¬í•¨ëœ ì½”ë“œ ë¸”ë¡ì„ íŠ¹ë³„ ì²˜ë¦¬
                        const lines = text.split('\n');
                        let enhancedHTML = '';
                        let hasValidProgress = false;
                        
                        lines.forEach(line => {
                            if (line.includes('â–ˆ') && line.includes('%')) {
                                // í”„ë¡œê·¸ë ˆìŠ¤ ë°” ë¼ì¸ ìŠ¤íƒ€ì¼ë§
                                const progressMatch = line.match(/(.+?):\s*(â–ˆ+â–‘*)\s*(\d+%)\s*(.*)/);
                                if (progressMatch) {
                                    hasValidProgress = true;
                                    const [, label, bar, percentage, desc] = progressMatch;
                                    const filledBlocks = (bar.match(/â–ˆ/g) || []).length;
                                    const totalBlocks = bar.length;
                                    const progressPercent = Math.round((filledBlocks / totalBlocks) * 100);
                                    
                                    enhancedHTML += `<div style="margin: 0.5rem 0; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #667eea;">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="font-weight: 500; min-width: 120px;">${label}:</span>
                                            <div style="flex: 1; background: #e9ecef; height: 8px; border-radius: 4px; overflow: hidden;">
                                                <div style="width: ${progressPercent}%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);"></div>
                                            </div>
                                            <span style="font-weight: 600; color: #667eea;">${percentage}</span>
                                            <span style="color: #6c757d; font-size: 0.9em;">${desc}</span>
                                        </div>
                                    </div>`;
                                } else {
                                    enhancedHTML += escapeHtml(line) + '<br>';
                                }
                            } else if (line.trim() !== '') {
                                enhancedHTML += escapeHtml(line) + '<br>';
                            }
                        });
                        
                        // ì‹¤ì œë¡œ ìœ íš¨í•œ í”„ë¡œê·¸ë ˆìŠ¤ ë°”ê°€ ìˆì—ˆì„ ë•Œë§Œ ì ìš©
                        if (hasValidProgress && enhancedHTML !== '') {
                            code.innerHTML = enhancedHTML;
                        }
                    }
                });

                // í‘œì— ì¶”ê°€ ìŠ¤íƒ€ì¼ ì ìš©
                const tables = tempDiv.querySelectorAll('table');
                tables.forEach(table => {
                    // í…Œì´ë¸” ì»¨í…Œì´ë„ˆ ë˜í•‘
                    const wrapper = document.createElement('div');
                    wrapper.style.cssText = 'overflow-x: auto; margin: 1.5rem 0; border-radius: 8px; box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);';
                    
                    table.style.cssText = 'width: 100%; border-collapse: collapse; background: white; min-width: 500px;';
                    
                    const ths = table.querySelectorAll('th');
                    ths.forEach(th => {
                        th.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: 600; padding: 12px 16px; text-align: left; border: none; font-size: 0.95rem;';
                    });
                    
                    const tds = table.querySelectorAll('td');
                    tds.forEach((td, index) => {
                        td.style.cssText = 'padding: 12px 16px; border-bottom: 1px solid #e9ecef; font-size: 0.9rem; vertical-align: top;';
                        
                        // ì§ìˆ˜ í–‰ ë°°ê²½ìƒ‰
                        const row = td.parentElement;
                        const rowIndex = Array.from(row.parentElement.children).indexOf(row);
                        if (rowIndex % 2 === 0) {
                            td.style.backgroundColor = '#f8f9fa';
                        }
                    });
                    
                    // í˜¸ë²„ íš¨ê³¼ ì¶”ê°€
                    const rows = table.querySelectorAll('tr');
                    rows.forEach(row => {
                        row.addEventListener('mouseenter', () => {
                            row.querySelectorAll('td').forEach(td => {
                                td.style.backgroundColor = '#e3f2fd';
                            });
                        });
                        row.addEventListener('mouseleave', () => {
                            row.querySelectorAll('td').forEach((td, index) => {
                                const rowIndex = Array.from(row.parentElement.children).indexOf(row);
                                td.style.backgroundColor = rowIndex % 2 === 0 ? '#f8f9fa' : 'white';
                            });
                        });
                    });
                    
                    // í…Œì´ë¸”ì„ ë˜í¼ë¡œ ê°ì‹¸ê¸°
                    table.parentNode.insertBefore(wrapper, table);
                    wrapper.appendChild(table);
                });

                // ë¦¬ìŠ¤íŠ¸ ê°œì„ 
                const lists = tempDiv.querySelectorAll('ul, ol');
                lists.forEach(list => {
                    list.style.cssText = 'margin: 1rem 0; padding-left: 1.5rem;';
                    
                    const items = list.querySelectorAll('li');
                    items.forEach(li => {
                        li.style.cssText = 'margin: 0.5rem 0; line-height: 1.6;';
                        
                        // ì²´í¬ë¦¬ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ - ì´ëª¨ì§€ë§Œ ìƒ‰ìƒ ì ìš©, ë‚˜ë¨¸ì§€ í…ìŠ¤íŠ¸ëŠ” ê¸°ë³¸ ìƒ‰ìƒ ìœ ì§€
                        const text = li.textContent;
                        if (text.includes('âœ…')) {
                            li.innerHTML = li.innerHTML.replace(/âœ…/g, '<span style="color: #28a745; display: inline;">âœ…</span>');
                            li.style.cssText += '; font-weight: 500; color: inherit;'; // ê¸°ë³¸ ìƒ‰ìƒ ìƒì† ë³´ì¥
                        } else if (text.includes('âŒ')) {
                            li.innerHTML = li.innerHTML.replace(/âŒ/g, '<span style="color: #dc3545; display: inline;">âŒ</span>');
                            li.style.cssText += '; font-weight: 500; color: inherit;'; // ê¸°ë³¸ ìƒ‰ìƒ ìƒì† ë³´ì¥
                        } else if (text.includes('âš™ï¸')) {
                            li.innerHTML = li.innerHTML.replace(/âš™ï¸/g, '<span style="color: #6c757d;">âš™ï¸</span>');
                            li.style.fontWeight = '500';
                        }
                    });
                });

                return tempDiv.innerHTML;
            } catch (error) {
                console.warn('Enhanced markdown rendering failed:', error);
                return html;
            }
        }

        // ë¶ˆì™„ì „í•œ HTML íƒœê·¸ ì •ë¦¬ í•¨ìˆ˜
        function cleanIncompleteHTML(html) {
            if (!html) return '';
            
            // HTML ì°¸ì¡° ë¬¸í—Œì¸ ê²½ìš° íƒœê·¸ ì •ë¦¬ë¥¼ ìŠ¤í‚µ
            if ((html.trim().startsWith('<details') && html.includes('ì°¸ì¡° ë¬¸í—Œ')) ||
                (html.includes('<details') && html.includes('ì°¸ì¡° ë¬¸í—Œ') && html.includes('</details>'))) {
                return html;
            }
            
            // ë‹«íˆì§€ ì•Šì€ íƒœê·¸ë“¤ì„ ì°¾ì•„ì„œ ì œê±°í•˜ê±°ë‚˜ ë‹«ê¸°
            let cleaned = html;
            
            // ì¼ë°˜ì ì¸ ë§ˆí¬ë‹¤ìš´ íƒœê·¸ë“¤ì˜ ë¶ˆì™„ì „í•œ í˜•íƒœ ì²˜ë¦¬
            const tagPairs = [
                ['<strong>', '</strong>'],
                ['<em>', '</em>'],
                ['<code>', '</code>'],
                ['<pre>', '</pre>'],
                ['<p>', '</p>'],
                ['<h1>', '</h1>'],
                ['<h2>', '</h2>'],
                ['<h3>', '</h3>'],
                ['<h4>', '</h4>'],
                ['<h5>', '</h5>'],
                ['<h6>', '</h6>'],
                ['<ul>', '</ul>'],
                ['<ol>', '</ol>'],
                ['<li>', '</li>'],
                ['<blockquote>', '</blockquote>'],
                ['<details>', '</details>'],
                ['<summary>', '</summary>'],
                ['<div>', '</div>'],
                ['<span>', '</span>']
            ];

            for (const [openTag, closeTag] of tagPairs) {
                const openCount = (cleaned.match(new RegExp(escapeRegex(openTag), 'g')) || []).length;
                const closeCount = (cleaned.match(new RegExp(escapeRegex(closeTag), 'g')) || []).length;
                
                // ì—´ë¦° íƒœê·¸ê°€ ë” ë§ìœ¼ë©´ ë‹«ëŠ” íƒœê·¸ ì¶”ê°€
                if (openCount > closeCount) {
                    cleaned += closeTag.repeat(openCount - closeCount);
                }
            }

            return cleaned;
        }

        // ì •ê·œì‹ ì´ìŠ¤ì¼€ì´í”„ í•¨ìˆ˜
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // ëŒ€í™” íˆìŠ¤í† ë¦¬ ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function addToConversationHistory(role, content) {
            conversationHistory.push({
                role: role, // 'user' or 'assistant'
                content: content,
                timestamp: new Date().toISOString()
            });
            
            // ìµœëŒ€ ê¸¸ì´ ì œí•œ
            if (conversationHistory.length > MAX_HISTORY_LENGTH * 2) { // user + assistant ìŒì´ë¯€ë¡œ *2
                conversationHistory = conversationHistory.slice(-MAX_HISTORY_LENGTH * 2);
            }
            
            console.log('Updated conversation history:', conversationHistory.length, 'messages');
        }

        function clearConversationHistory() {
            conversationHistory = [];
            console.log('Conversation history cleared');
        }

        function getConversationContext() {
            // ìµœê·¼ ëŒ€í™”ë“¤ì„ ë¬¸ë§¥ìœ¼ë¡œ ë°˜í™˜
            return conversationHistory.slice(-6) // ìµœê·¼ 3ìŒ(6ê°œ ë©”ì‹œì§€)ë§Œ ì‚¬ìš©
                .map(msg => `${msg.role}: ${msg.content}`)
                .join('\n');
        }

        // íŒŒì¼ ì„ íƒ ìƒíƒœ ê´€ë¦¬
        let selectedFilesForUpload = new Set();
        
        // íŒŒì¼ ì„ íƒ ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        pdfFile.addEventListener('change', function(event) {
            const files = Array.from(event.target.files);
            
            // íŒŒì¼ ê°œìˆ˜ ì œí•œ í™•ì¸ (ìµœëŒ€ 10ê°œ)
            const MAX_FILES = 10;
            if (files.length > MAX_FILES) {
                alert(`âš ï¸ ìµœëŒ€ ${MAX_FILES}ê°œì˜ íŒŒì¼ê¹Œì§€ë§Œ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\ní˜„ì¬ ì„ íƒëœ íŒŒì¼: ${files.length}ê°œ\n\nì²˜ë¦¬ ì„±ëŠ¥ìƒ ìµœëŒ€ 5ê°œ íŒŒì¼ê¹Œì§€ë§Œ ë™ì‹œì— ì²˜ë¦¬ë©ë‹ˆë‹¤.`);
                
                // íŒŒì¼ ì„ íƒ ì´ˆê¸°í™”
                event.target.value = '';
                displaySelectedFiles([]);
                return;
            }
            
            // 5ê°œ ì´ìƒ ì„ íƒ ì‹œ ì•ˆë‚´ ë©”ì‹œì§€
            if (files.length > 5) {
                const message = `ğŸ“‹ ${files.length}ê°œ íŒŒì¼ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.\n\nâš¡ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ìµœëŒ€ 5ê°œì”© ë™ì‹œ ì²˜ë¦¬ë©ë‹ˆë‹¤.\në‚˜ë¨¸ì§€ íŒŒì¼ë“¤ì€ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.`;
                
                // ê°„ë‹¨í•œ í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í‘œì‹œ
                showToastMessage(message, 'info');
            }
            
            displaySelectedFiles(files);
        });
        
        // ì„ íƒëœ íŒŒì¼ ëª©ë¡ í‘œì‹œ
        function displaySelectedFiles(files) {
            const container = document.getElementById('selected-files-container');
            const filesList = document.getElementById('selected-files-list');
            const selectedCount = document.getElementById('selected-count');
            
            if (files.length === 0) {
                container.style.display = 'none';
                selectedFilesForUpload.clear();
                return;
            }
            
            container.style.display = 'block';
            selectedFilesForUpload.clear();
            
            filesList.innerHTML = '';
            files.forEach((file, index) => {
                selectedFilesForUpload.add(index); // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  íŒŒì¼ ì„ íƒ
                
                const fileItem = document.createElement('div');
                fileItem.style.cssText = `
                    display: flex; 
                    align-items: center; 
                    padding: 8px 12px; 
                    margin-bottom: 6px; 
                    background: white; 
                    border: 1px solid #dee2e6; 
                    border-radius: 6px;
                    transition: all 0.2s ease;
                `;
                
                fileItem.innerHTML = `
                    <input type="checkbox" id="file-${index}" checked style="margin-right: 10px;">
                    <label for="file-${index}" style="flex: 1; margin: 0; cursor: pointer; font-size: 0.9rem;">
                        ğŸ“„ ${file.name}
                    </label>
                    <span style="font-size: 0.8rem; color: #6c757d;">
                        ${(file.size / 1024 / 1024).toFixed(2)} MB
                    </span>
                `;
                
                const checkbox = fileItem.querySelector(`#file-${index}`);
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        selectedFilesForUpload.add(index);
                        fileItem.style.backgroundColor = 'white';
                    } else {
                        selectedFilesForUpload.delete(index);
                        fileItem.style.backgroundColor = '#f8f9fa';
                    }
                    updateSelectedCount();
                });
                
                filesList.appendChild(fileItem);
            });
            
            updateSelectedCount();
        }
        
        // ì„ íƒëœ íŒŒì¼ ê°œìˆ˜ ì—…ë°ì´íŠ¸
        function updateSelectedCount() {
            const selectedCount = document.getElementById('selected-count');
            const submitBtn = document.getElementById('upload-submit-btn');
            
            selectedCount.textContent = `${selectedFilesForUpload.size}ê°œ íŒŒì¼ ì„ íƒë¨`;
            submitBtn.disabled = selectedFilesForUpload.size === 0;
            
            if (selectedFilesForUpload.size === 0) {
                submitBtn.style.opacity = '0.5';
                submitBtn.style.cursor = 'not-allowed';
            } else {
                submitBtn.style.opacity = '1';
                submitBtn.style.cursor = 'pointer';
            }
        }
        
        // ì „ì²´ ì„ íƒ/í•´ì œ ë²„íŠ¼
        document.getElementById('select-all-btn').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#selected-files-list input[type="checkbox"]');
            checkboxes.forEach((checkbox, index) => {
                checkbox.checked = true;
                selectedFilesForUpload.add(index);
                checkbox.closest('div').style.backgroundColor = 'white';
            });
            updateSelectedCount();
        });
        
        document.getElementById('deselect-all-btn').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#selected-files-list input[type="checkbox"]');
            checkboxes.forEach((checkbox, index) => {
                checkbox.checked = false;
                selectedFilesForUpload.delete(index);
                checkbox.closest('div').style.backgroundColor = '#f8f9fa';
            });
            updateSelectedCount();
        });

        uploadForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            
            // íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘ ì‹œ management ë©”ì‹œì§€ í´ë¦¬ì–´
            if (typeof clearManagementStatus === 'function') {
                clearManagementStatus();
            }
            
            const allFiles = Array.from(pdfFile.files);
            const selectedFiles = allFiles.filter((file, index) => selectedFilesForUpload.has(index));
            
            if (selectedFiles.length === 0) {
                uploadStatus.textContent = 'ì²˜ë¦¬í•  íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.';
                updateProcessingActivity('idle');
                return;
            }
            
            // ì—…ë¡œë“œ ì§„í–‰ë¥  UI ì´ˆê¸°í™” ë° í‘œì‹œ
            initializeUploadProgress(selectedFiles);
            
            // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì²˜ë¦¬ì¤‘'ìœ¼ë¡œ ë³€ê²½
            updateProcessingActivity('processing');
            
            const formData = new FormData();
            for (const f of selectedFiles) {
                formData.append('files', f);
            }
            // Include OCR correction flag from dashboard toggle
            const ocrToggle = document.getElementById('ocr-correction-toggle');
            formData.append('ocr_correction_enabled', ocrToggle.checked);
            
            // Include LLM correction flag from dashboard toggle
            const llmToggle = document.getElementById('llm-correction-toggle');
            formData.append('llm_correction_enabled', llmToggle.checked);
            try {
                // XMLHttpRequestë¥¼ ì‚¬ìš©í•˜ì—¬ ì—…ë¡œë“œ ì§„í–‰ë¥  ì¶”ì 
                const result = await uploadWithProgress(formData, selectedFiles);
                if (result.success) {
                    if (result.results && Array.isArray(result.results)) {
                        const successfulUploads = [];
                        const errorUploads = [];
                        
                        // íŒŒì¼ ê²°ê³¼ë³„ë¡œ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                        for (let i = 0; i < result.results.length; i++) {
                            const r = result.results[i];
                            if (r.error) {
                                errorUploads.push({filename: r.filename || 'íŒŒì¼ ì—†ìŒ', error: r.error});
                                updateFileProgress(i, 0, 'ì—…ë¡œë“œ ì‹¤íŒ¨');
                            } else {
                                if(r.document_id) {
                                    successfulUploads.push({
                                        documentId: r.document_id,
                                        filename: r.filename
                                    });
                                    updateFileProgress(i, 100, 'ì²˜ë¦¬ ì‹œì‘ë¨');
                                }
                            }
                        }
                        
                        // ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                        updateOverallProgress(successfulUploads.length, selectedFiles.length, 
                            `${successfulUploads.length}ê°œ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ, ${errorUploads.length}ê°œ ì‹¤íŒ¨`);
                        
                        // ì˜¤ë¥˜ê°€ ìˆëŠ” ê²½ìš°ë§Œ ë©”ì‹œì§€ í‘œì‹œ
                        if (errorUploads.length > 0) {
                            let errorMsg = '';
                            errorUploads.forEach(error => {
                                errorMsg += `âŒ ${error.filename}: ${error.error}\n`;
                            });
                            uploadStatus.textContent = errorMsg.trim();
                            uploadStatus.className = 'status-message status-error';
                            // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì˜¤ë¥˜'ë¡œ ë³€ê²½
                            updateProcessingActivity('error');
                        } else {
                            // ì„±ê³µí•œ ê²½ìš° ê°„ë‹¨í•œ ë©”ì‹œì§€ë§Œ
                            uploadStatus.textContent = `${successfulUploads.length}ê°œ íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘ë¨`;
                            uploadStatus.className = 'status-message status-success';
                            // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì™„ë£Œ'ë¡œ ë³€ê²½ (100% ì§„í–‰ë¥ )
                            updateProcessingActivity('completed', 100);
                        }
                        
                        // ë‹¤ì¤‘ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì  ì‹œì‘
                        if (successfulUploads.length > 0) {
                            startMultiFileProgressTracking(successfulUploads);
                            
                            // ì—…ë¡œë“œ ì™„ë£Œ í›„ ì—…ë¡œë“œ ê´€ë ¨ UI ì •ë¦¬ (3ì´ˆ í›„)
                            setTimeout(() => {
                                // ì—…ë¡œë“œ ìƒíƒœ ë©”ì‹œì§€ ì •ë¦¬
                                uploadStatus.textContent = '';
                                uploadStatus.className = 'status-message';
                                
                                // ì„ íƒëœ íŒŒì¼ ëª©ë¡ ìˆ¨ê¸°ê¸° (ë¬¸ì„œ ì²˜ë¦¬ê°€ ì‹œì‘ë˜ì—ˆìœ¼ë¯€ë¡œ)
                                const selectedFilesContainer = document.getElementById('selected-files-container');
                                if (selectedFilesContainer) {
                                    selectedFilesContainer.style.display = 'none';
                                    document.getElementById('selected-files-list').innerHTML = '';
                                    selectedFilesForUpload.clear();
                                    
                                    // íŒŒì¼ ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
                                    const pdfFileInput = document.getElementById('pdf-file');
                                    if (pdfFileInput) {
                                        pdfFileInput.value = '';
                                    }
                                    
                                    // ì—…ë¡œë“œ ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
                                    updateSelectedCount();
                                }
                                
                                // ì§„í–‰ë¥  ì°½ì— í¬ì»¤ìŠ¤ë¥¼ ì£¼ì–´ ì‚¬ìš©ìê°€ ì§„í–‰ ìƒí™©ì„ ë³¼ ìˆ˜ ìˆë„ë¡ í•¨
                                const progressContainer = document.getElementById('progress-container');
                                if (progressContainer) {
                                    progressContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }, 3000);
                        }
                        
                        // ë¬¸ì„œ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                        setTimeout(() => {
                            fetchDocumentList();
                        }, 2000);
                    } else {
                        uploadStatus.textContent = 'ì•Œ ìˆ˜ ì—†ëŠ” ì‘ë‹µ í˜•ì‹';
                        uploadStatus.className = 'status-message status-error';
                        // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì˜¤ë¥˜'ë¡œ ë³€ê²½
                        updateProcessingActivity('error');
                    }
                } else {
                    uploadStatus.textContent = `ì˜¤ë¥˜: ${result.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`;
                    uploadStatus.className = 'status-message status-error';
                    // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì˜¤ë¥˜'ë¡œ ë³€ê²½
                    updateProcessingActivity('error');
                }
            } catch (error) {
                console.error('Upload error:', error);
                
                // ê° íŒŒì¼ì„ ì˜¤ë¥˜ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
                selectedFiles.forEach((file, index) => {
                    updateFileProgress(index, 0, 'ì—…ë¡œë“œ ì‹¤íŒ¨');
                });
                
                updateOverallProgress(0, selectedFiles.length, 'ì—…ë¡œë“œ ì‹¤íŒ¨');
                uploadStatus.textContent = `ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                uploadStatus.className = 'status-message status-error';
                
                // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì˜¤ë¥˜'ë¡œ ë³€ê²½
                updateProcessingActivity('error');
            }
        });

        async function sendMessage() {
            const query = chatInput.value.trim();
            if (!query) return;

            // 1. ì¦‰ì‹œ ì´ì „ ìƒíƒœ ì •ë¦¬ (ë™ì¼ ì§ˆë¬¸ ì‹œ ê¹¨ë—í•œ ì‹œì‘ì„ ìœ„í•´)
            resetChatProgress();

            appendMessage('user', query);
            chatInput.value = '';
            
            // Show progress indicator
            showChatProgress();
            
            // ëª¨ë¸ í™œë™ ìƒíƒœë¥¼ 'ì²˜ë¦¬ì¤‘'ìœ¼ë¡œ ë³€ê²½
            updateModelActivity('processing');
            
            // Create streaming message container
            const streamingMessageDiv = document.createElement('div');
            streamingMessageDiv.classList.add('message', 'bot-message', 'streaming');
            const messageContent = document.createElement('div');
            messageContent.classList.add('streaming-content');
            streamingMessageDiv.appendChild(messageContent);
            chatMessages.appendChild(streamingMessageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            try {
                // Debug: Log request details
                console.log('Sending chat request:', {
                    query: query,
                    model_name: getSelectedModel(),
                    document_ids: getSelectedDocumentIds(),
                    conversation_history: conversationHistory.length
                });
                
                // Create AbortController for cancelling the request
                const abortController = new AbortController();
                currentStreamAbortController = abortController;

                // Show stop button
                showStopButton();

                // Use EventSource for Server-Sent Events
                const response = await fetch('/api/chat/stream/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        query: query, 
                        model_name: getSelectedModel(), 
                        document_ids: getSelectedDocumentIds(),
                        conversation_history: conversationHistory
                    }),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    // Handle error responses, especially 400 Bad Request with validation messages
                    if (response.status === 400) {
                        try {
                            const errorData = await response.json();
                            if (errorData.detail && errorData.detail.message) {
                                // Display the validation error message from backend
                                appendMessage('bot', `âŒ ${errorData.detail.message}`);
                                
                                // Also show suggestions if available
                                if (errorData.detail.suggestions && errorData.detail.suggestions.length > 0) {
                                    const suggestionsHtml = errorData.detail.suggestions
                                        .map(suggestion => `â€¢ ${suggestion}`)
                                        .join('\n');
                                    appendMessage('bot', `\nğŸ’¡ **ì¶”ì²œ ì§ˆë¬¸:**\n${suggestionsHtml}`);
                                }
                                
                                chatStatus.textContent = '';
                                chatStatus.className = 'status-message';
                                return; // Exit early, don't throw error
                            }
                        } catch (parseError) {
                            console.warn('Failed to parse 400 error response:', parseError);
                        }
                    }
                    
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // Handle streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullResponse = '';
                let contentSummary = null;
                let mediaReferences = null;
                let markdownTimeout = null;

                // Initialize with first step only
                updateChatProgressStep('embedding', 'ì§ˆë¬¸ì„ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤...');

                let buffer = '';
                
                // Add abort signal listener to force close reader
                abortController.signal.addEventListener('abort', () => {
                    console.log('Abort signal received, cancelling reader');
                    try {
                        reader.cancel();
                    } catch (e) {
                        console.log('Reader cancel failed:', e);
                    }
                });
                
                try {
                    while (true) {
                        // Check if abort was requested
                        if (abortController.signal.aborted) {
                            console.log('Streaming aborted by user');
                            break;
                        }
                        
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep incomplete line in buffer

                        for (const line of lines) {
                            if (line.trim().startsWith('data: ')) {
                                try {
                                    const jsonStr = line.trim().substring(6);
                                    if (jsonStr.trim()) {
                                        const data = JSON.parse(jsonStr);
                                        
                                        if (data.type === 'status') {
                                            // Update status message and progress step
                                            chatStatus.textContent = data.message;
                                            chatStatus.className = 'status-message';
                                            
                                            // Update progress step based on status message with sequential timing
                                            console.log('Status message received:', data.message); // Debug log
                                            
                                            // ë‹¨ìˆœí™”ëœ ë‹¨ê³„ë³„ ì§„í–‰ ë¡œì§ (ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€)
                                            if (data.message.includes('ì§ˆë¬¸ ë¶„ì„')) {
                                                updateChatProgressStep('query', data.message);
                                            } else if (data.message.includes('ìºì‹œì—ì„œ ë‹µë³€ì„ ë¶ˆëŸ¬ì˜¤ê³  ìˆìŠµë‹ˆë‹¤')) {
                                                updateChatProgressStep('embedding', 'ìºì‹œ í™•ì¸ ì¤‘...');
                                            } else if (data.message.includes('LLMìœ¼ë¡œ ë‹µë³€ì„ êµ¬ì¡°í™”í•˜ê³  ìˆìŠµë‹ˆë‹¤')) {
                                                updateChatProgressStep('generate', 'ğŸ’¾ ìºì‹œëœ ë‹µë³€ì„ êµ¬ì¡°í™”í•˜ê³  ìˆìŠµë‹ˆë‹¤...');
                                            } else if (data.message.includes('ê´€ë ¨ ë¬¸ì„œ ê²€ìƒ‰')) {
                                                updateChatProgressStep('search', data.message);
                                            } else if (data.message.includes('ë‹µë³€ ìƒì„±')) {
                                                updateChatProgressStep('generate', data.message);
                                            }
                                        } else if (data.type === 'content') {
                                            // First content chunk - we're definitely in generate phase
                                            if (fullResponse === '') {
                                                console.log('First content chunk received, starting generate step');
                                                updateChatProgressStep('generate', 'AIê°€ ë‹µë³€ì„ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...');
                                            }
                                            
                                            // Append content to streaming message
                                            fullResponse += data.content;
                                            console.log('Content appended, fullResponse length:', fullResponse.length);
                                            
                                            // ì°¸ê³ ë¬¸í—Œ ë””ë²„ê¹… - ëª¨ë“  content ë¡œê·¸
                                            if (data.content.includes('ì°¸ì¡°') || data.content.includes('details') || data.content.includes('ë¬¸í—Œ')) {
                                                console.log('ğŸ” ì°¸ê³ ë¬¸í—Œ ê´€ë ¨ ì½˜í…ì¸ :', data.content);
                                            }
                                            
                                            // ì‹¤ì‹œê°„ ë§ˆí¬ë‹¤ìš´ ë Œë”ë§ (ì¤„ ë‹¨ìœ„)
                                            renderStreamingMarkdown(messageContent, fullResponse);
                                            
                                            chatMessages.scrollTop = chatMessages.scrollHeight;
                                            
                                        } else if (data.type === 'final') {
                                            // Store metadata
                                            contentSummary = data.metadata.content_summary;
                                            mediaReferences = data.metadata.media_references;
                                            
                                            console.log('Final metadata received:', { contentSummary, mediaReferences });
                                            
                                            // Complete progress in final stage
                                            updateChatProgressStep('generate', 'ë‹µë³€ ìƒì„± ì™„ë£Œ!');
                                            
                                            // ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ ì‹œ ëª¨ë“  THINK ë¸”ë¡ ì ‘ê¸°
                                            setTimeout(() => {
                                                const allThinkAccordions = messageContent.querySelectorAll('.thinking-accordion');
                                                allThinkAccordions.forEach(accordion => {
                                                    accordion.removeAttribute('open');
                                                    const statusSpan = accordion.querySelector('summary span:last-child');
                                                    if (statusSpan && !statusSpan.textContent.includes('ë‹µë³€ ì™„ë£Œë¨')) {
                                                        statusSpan.textContent = '(ë‹µë³€ ì™„ë£Œë¨)';
                                                    }
                                                });
                                                console.log('ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ - ëª¨ë“  THINK ë¸”ë¡ ì ‘ê¸° ì²˜ë¦¬ë¨');
                                            }, 100);
                                        } else if (data.type === 'validation_error') {
                                            // Handle validation errors from backend
                                            console.log('Validation error received:', data);
                                            
                                            // Display validation error message
                                            let errorMessage = `âŒ ${data.message}`;
                                            appendMessage('bot', errorMessage);
                                            
                                            // Also show suggestions if available
                                            if (data.suggestions && data.suggestions.length > 0) {
                                                const suggestionsHtml = data.suggestions
                                                    .map(suggestion => `â€¢ ${suggestion}`)
                                                    .join('\n');
                                                appendMessage('bot', `\nğŸ’¡ **ì¶”ì²œ ì§ˆë¬¸:**\n${suggestionsHtml}`);
                                            }
                                            
                                            // Clear status and stop streaming
                                            chatStatus.textContent = '';
                                            chatStatus.className = 'status-message';
                                            
                                            // Remove the streaming message placeholder since we showed error
                                            if (streamingMessageDiv.parentNode) {
                                                streamingMessageDiv.parentNode.removeChild(streamingMessageDiv);
                                            }
                                            
                                            return; // Exit streaming loop
                                        } else if (data.type === 'error') {
                                            throw new Error(data.message);
                                        }
                                    }
                                } catch (parseError) {
                                    console.warn('Failed to parse SSE data:', line, parseError);
                                }
                            }
                        }
                    }
                } catch (streamError) {
                    console.error('Streaming read error:', streamError);
                    throw streamError;
                } finally {
                    // Ensure reader cleanup
                    try {
                        reader.releaseLock();
                    } catch (releaseError) {
                        console.warn('Failed to release reader lock:', releaseError);
                    }
                }

                // Remove streaming class and finalize message
                streamingMessageDiv.classList.remove('streaming');
                
                // Remove typing cursor and process references
                if (fullResponse && messageContent) {
                    // íƒ€ì´í•‘ ì»¤ì„œ ì œê±°
                    const typingCursors = messageContent.querySelectorAll('.typing-cursor');
                    typingCursors.forEach(cursor => cursor.remove());
                    
                    // ì°¸ê³ ë¬¸í—Œ í›„ì²˜ë¦¬ - ì „ì²´ ì‘ë‹µì—ì„œ ì°¸ê³ ë¬¸í—Œ ì¶”ì¶œ
                    const referenceMatch = fullResponse.match(/<details[^>]*>[\s\S]*?ì°¸ì¡° ë¬¸í—Œ[\s\S]*?<\/details>/i);
                    if (referenceMatch) {
                        const referenceHTML = referenceMatch[0];
                        console.log('ì°¸ê³ ë¬¸í—Œ ë°œê²¬, í›„ì²˜ë¦¬ ì¤‘:', referenceHTML.length, 'ì');
                        
                        // ê¸°ì¡´ ë‚´ìš©ì—ì„œ ì°¸ê³ ë¬¸í—Œ ì œê±° (ì¤‘ë³µ ë°©ì§€)
                        let cleanContent = messageContent.innerHTML;
                        
                        // 1. ê¸°ì¡´ ì°¸ê³ ë¬¸í—Œë§Œ ì œê±° (ì¤‘ë³µ ë°©ì§€)
                        cleanContent = cleanContent.replace(/<details[^>]*>[\s\S]*?ì°¸ì¡° ë¬¸í—Œ[\s\S]*?<\/details>/gi, '');
                        
                        // 2. í…ìŠ¤íŠ¸ë¡œ ë Œë”ë§ëœ ë¶ˆì™„ì „í•œ HTML ì¡°ê°ë“¤ë§Œ ì œê±° (ë§¤ìš° ì •êµí•œ íŒ¨í„´)
                        // - ë‹¨ë…ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” HTML íƒœê·¸ë“¤ë§Œ ì œê±°í•˜ê³ , ì‹¤ì œ HTML êµ¬ì¡°ëŠ” ë³´ì¡´
                        // - ì¤„ ë‹¨ìœ„ë¡œ í™•ì¸í•˜ì—¬ ê³ ë¦½ëœ íƒœê·¸ë§Œ ì œê±°
                        const lines = cleanContent.split('\n');
                        const filteredLines = lines.map(line => {
                            const trimmedLine = line.trim();
                            // í•œ ì¤„ì— ë‹¨ë…ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” HTML íƒœê·¸ë§Œ ì œê±° (í…ìŠ¤íŠ¸ ì—†ì´)
                            if (/^<\/?(?:details|summary|div|span)[^>]*>$/.test(trimmedLine)) {
                                return '';
                            }
                            return line;
                        });
                        cleanContent = filteredLines.join('\n');
                        
                        // ì°¸ê³ ë¬¸í—Œì„ ë§¨ ëì— ì¶”ê°€
                        messageContent.innerHTML = cleanContent + referenceHTML;
                        console.log('ì°¸ê³ ë¬¸í—Œ í›„ì²˜ë¦¬ ì™„ë£Œ');
                    } else {
                        console.log('ì°¸ê³ ë¬¸í—Œ ì—†ìŒ');
                    }
                }
                
                // Complete the generate progress step
                if (fullResponse) {
                    updateChatProgressStep('generate', 'ë‹µë³€ ìƒì„± ì™„ë£Œ!');
                }
                
                // ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ í›„ ëª¨ë“  THINK ë¸”ë¡ ì ‘ê¸° (ìµœì¢… ì²˜ë¦¬)
                setTimeout(() => {
                    if (messageContent) {
                        const finalThinkAccordions = messageContent.querySelectorAll('.thinking-accordion');
                        finalThinkAccordions.forEach(accordion => {
                            accordion.removeAttribute('open');
                            const statusSpan = accordion.querySelector('summary span:last-child');
                            if (statusSpan && !statusSpan.textContent.includes('ë‹µë³€ ì™„ë£Œë¨')) {
                                statusSpan.textContent = '(ë‹µë³€ ì™„ë£Œë¨)';
                            }
                        });
                        if (finalThinkAccordions.length > 0) {
                            console.log(`ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ - ${finalThinkAccordions.length}ê°œ THINK ë¸”ë¡ ìµœì¢… ì ‘ê¸° ì²˜ë¦¬ë¨`);
                        }
                    }
                }, 200);
                
                // Clear any pending markdown timeout
                if (markdownTimeout) {
                    clearTimeout(markdownTimeout);
                }
                
                // ìŠ¤íŠ¸ë¦¬ë° ë©”ì‹œì§€ë¥¼ enhanced multimodal í˜•íƒœë¡œ ë³€í™˜í•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ìœ ì§€
                // THINK ë¸”ë¡ ìƒíƒœë¥¼ ë³´ì¡´í•˜ê¸° ìœ„í•´ ì¶”ê°€ ë³€í™˜ ì‘ì—… ìŠ¤í‚µ
                if (fullResponse) {
                    console.log('ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ - ë©”ì‹œì§€ ë³€í™˜ ìŠ¤í‚µí•˜ì—¬ THINK ë¸”ë¡ ìƒíƒœ ë³´ì¡´');
                    
                    // ìŠ¤íŠ¸ë¦¬ë° ë©”ì‹œì§€ì˜ í´ë˜ìŠ¤ë§Œ ì •ë¦¬í•˜ê³  ë‚´ìš©ì€ ìœ ì§€
                    streamingMessageDiv.classList.remove('streaming');
                    streamingMessageDiv.classList.add('bot-message');
                    
                    // ìµœì¢…ì ìœ¼ë¡œ THINK ë¸”ë¡ë“¤ì´ ì ‘íŒ ìƒíƒœì¸ì§€ í™•ì¸
                    setTimeout(() => {
                        const allAccordions = streamingMessageDiv.querySelectorAll('.thinking-accordion');
                        allAccordions.forEach(accordion => {
                            accordion.removeAttribute('open');
                            accordion.open = false;
                            
                            // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
                            setupThinkBlockToggle(accordion);
                            
                            const statusSpan = accordion.querySelector('summary span:last-child');
                            if (statusSpan) {
                                statusSpan.textContent = '(ì™„ë£Œ)';
                                statusSpan.style.color = '#28a745';
                            }
                        });
                        if (allAccordions.length > 0) {
                            console.log(`ìµœì¢… ìƒíƒœ í™•ì¸ ì™„ë£Œ - ${allAccordions.length}ê°œ THINK ë¸”ë¡ ëª¨ë‘ ì ‘í˜€ìˆìŒ`);
                        }
                    }, 500);
                } else {
                    // Fallback for empty responses
                    if (window.marked && fullResponse) {
                        try {
                            let fallbackHTML = window.marked.parse(fullResponse);
                            fallbackHTML = enhanceMarkdownRendering(fallbackHTML);
                            messageContent.innerHTML = fallbackHTML;
                        } catch (markdownError) {
                            messageContent.textContent = fullResponse;
                        }
                    }
                }
                
                // ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ í›„ ëŒ€í™” íˆìŠ¤í† ë¦¬ì— ë´‡ ì‘ë‹µ ì €ì¥
                if (fullResponse && fullResponse.trim()) {
                    // ì—ëŸ¬ ë©”ì‹œì§€ë‚˜ ì‹œìŠ¤í…œ ë©”ì‹œì§€ê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì €ì¥
                    if (!fullResponse.includes('âš ï¸') && !fullResponse.includes('âŒ') && !fullResponse.includes('ë‹µë³€ì„ ë“œë¦´ ìˆ˜ ì—†')) {
                        addToConversationHistory('assistant', fullResponse);
                        console.log('Bot response added to conversation history');
                    }
                }

                // Update status with summary
                chatStatus.className = 'status-message status-success';
                if (contentSummary) {
                    const summaryText = `í…ìŠ¤íŠ¸: ${contentSummary.text_chunks || 0}ê°œ, ì´ë¯¸ì§€: ${contentSummary.images || 0}ê°œ, í‘œ: ${contentSummary.tables || 0}ê°œ`;
                    const cacheIndicator = '';
                    chatStatus.textContent = `âœ… ë‹µë³€ ìƒì„± ì™„ë£Œ (${summaryText})${cacheIndicator}`;
                } else {
                    const cacheIndicator = '';
                    chatStatus.textContent = `âœ… ë‹µë³€ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤${cacheIndicator}`;
                }
                
                setTimeout(() => {
                    chatStatus.textContent = '';
                    chatStatus.className = 'status-message';
                }, 5000);

            } catch (error) {
                console.error('Streaming error:', error);
                console.error('Error details:', error.stack);
                console.error('Request context:', {
                    query: query,
                    model_name: getSelectedModel(),
                    document_ids: getSelectedDocumentIds(),
                    timestamp: new Date().toISOString()
                });
                
                // Remove failed streaming message
                if (streamingMessageDiv.parentNode) {
                    streamingMessageDiv.parentNode.removeChild(streamingMessageDiv);
                }
                
                // Detailed error message based on error type
                let errorMessage = 'âŒ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ';
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMessage += 'ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.';
                } else if (error.name === 'AbortError' || error.message.includes('aborted')) {
                    // Don't show error for deliberate abortion - stopStreaming() already handles this
                    console.log('Stream was aborted by user');
                    return;
                } else if (error.message.includes('timeout')) {
                    errorMessage += 'ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
                } else if (error.message.includes('HTTP error')) {
                    errorMessage += `ì„œë²„ ì˜¤ë¥˜ (${error.message})`;
                } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                    errorMessage += 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.';
                } else {
                    errorMessage += error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
                }
                
                appendMessage('bot', errorMessage);
                chatStatus.className = 'status-message status-error';
                chatStatus.textContent = errorMessage;
            } finally {
                // Small delay to ensure progress update is visible before hiding
                setTimeout(() => {
                    hideChatProgress();
                }, 500);
                sendButton.disabled = false;
                
                // Hide stop button and restore send button
                hideStopButton();
                
                // ëª¨ë¸ í™œë™ ìƒíƒœë¥¼ 'ëŒ€ê¸°ì¤‘'ìœ¼ë¡œ ë³µê·€
                updateModelActivity('idle');
            }
        }

        sendButton.addEventListener('click', () => {
            console.log('Send button clicked, isStreaming:', isStreaming);
            if (isStreaming) {
                console.log('Calling stopStreaming()');
                stopStreaming();
            } else {
                console.log('Calling sendMessage()');
                sendMessage();
            }
        });
        
        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !isStreaming) {
                sendMessage();
            }
        });

        // New chat button functionality
        const newChatButton = document.getElementById('new-chat-button');
        newChatButton.addEventListener('click', startNewConversation);

        function startNewConversation() {
            // Clear chat history
            chatHistory.innerHTML = '';
            
            // Clear conversation history
            clearConversationHistory();
            
            // Clear any status messages
            const chatStatus = document.getElementById('chat-status');
            if (chatStatus) {
                chatStatus.textContent = '';
                chatStatus.className = 'status-message';
            }
            
            // Hide any progress indicators
            const progressEl = document.getElementById('chat-progress');
            if (progressEl) {
                progressEl.classList.remove('active');
                if (progressEl.timerInterval) {
                    clearInterval(progressEl.timerInterval);
                    progressEl.timerInterval = null;
                    progressEl.startTime = null;
                }
            }
            
            // Show welcome message again
            showWelcomeMessage();
            
            // Focus on input
            chatInput.focus();
        }

        async function showWelcomeMessage() {
            try {
                // APIì—ì„œ ëœë¤ í™˜ì˜ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
                const response = await fetch('/api/welcome-messages/random');
                const data = await response.json();
                
                if (response.ok && data.message) {
                    appendMessage('bot', data.message, true);
                    console.log('ğŸ¯ ë™ì  í™˜ì˜ë©”ì‹œì§€ ë¡œë“œë¨:', data.message.slice(0, 50) + '...');
                } else {
                    // API ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ë©”ì‹œì§€
                    showDefaultWelcomeMessage();
                }
            } catch (error) {
                console.error('í™˜ì˜ë©”ì‹œì§€ ë¡œë“œ ì‹¤íŒ¨:', error);
                // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ ë©”ì‹œì§€
                showDefaultWelcomeMessage();
            }
        }
        
        function showDefaultWelcomeMessage() {
            const welcomeMessage = `ğŸ“š ì•ˆë…•í•˜ì„¸ìš”! ì—…ë¡œë“œëœ ë¬¸ì„œë“¤ì— ëŒ€í•´ ê¶ê¸ˆí•œ ê²ƒì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  ë¬¼ì–´ë³´ì„¸ìš”.`;
            appendMessage('bot', welcomeMessage, true);
        }

        function showStopButton() {
            console.log('Showing stop button, setting isStreaming = true');
            isStreaming = true;
            sendButton.innerHTML = 'ğŸ›‘ ì¤‘ì§€';
            sendButton.style.backgroundColor = '#dc3545';
            sendButton.disabled = false; // Re-enable button for stop functionality
            
            // Debug button state
            console.log('Button element:', sendButton);
            console.log('Button disabled:', sendButton.disabled);
            console.log('Button innerHTML:', sendButton.innerHTML);
            console.log('Stop button shown, currentStreamAbortController:', currentStreamAbortController);
        }

        function hideStopButton() {
            console.log('Hiding stop button, setting isStreaming = false');
            isStreaming = false;
            sendButton.innerHTML = 'ğŸ’¬ ì „ì†¡';
            sendButton.style.backgroundColor = '';
            sendButton.disabled = false;
            currentStreamAbortController = null;
            
            // ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ ì‹œ ëª¨ë“  ë©”ì‹œì§€ì˜ THINK ë¸”ë¡ì„ ìµœì¢… ìƒíƒœë¡œ ì„¤ì • (ê°•ë ¥í•œ ì²˜ë¦¬)
            setTimeout(() => {
                const allMessages = chatHistory.querySelectorAll('.bot-message, .message');
                allMessages.forEach(messageElement => {
                    const accordions = messageElement.querySelectorAll('.thinking-accordion');
                    if (accordions.length > 0) {
                        accordions.forEach(accordion => {
                            // ê°•ì œë¡œ ì ‘í˜ ìƒíƒœ ì„¤ì •
                            accordion.removeAttribute('open');
                            accordion.open = false;
                            
                            // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
                            setupThinkBlockToggle(accordion);
                            
                            // ìƒíƒœ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                            const statusSpan = accordion.querySelector('summary span:last-child');
                            if (statusSpan) {
                                statusSpan.textContent = '(ì™„ë£Œ)';
                                statusSpan.style.color = '#28a745';
                            }
                        });
                        console.log(`hideStopButtonì—ì„œ ${accordions.length}ê°œ THINK ë¸”ë¡ ìµœì¢… ì²˜ë¦¬ ì™„ë£Œ`);
                    }
                });
            }, 200);
        }

        function stopStreaming() {
            console.log('stopStreaming called, currentStreamAbortController:', currentStreamAbortController);
            if (currentStreamAbortController) {
                console.log('Aborting current stream...');
                currentStreamAbortController.abort();
                
                // Remove any streaming message placeholders and clean up cursors
                const streamingMessages = document.querySelectorAll('.message.streaming');
                streamingMessages.forEach(msg => {
                    // Remove typing cursor from the message before removing the message
                    const cursor = msg.querySelector('.typing-cursor');
                    if (cursor) {
                        cursor.remove();
                    }
                    msg.remove();
                });
                
                // Show stopped message
                appendMessage('bot', 'âš ï¸ ì‘ë‹µ ìƒì„±ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                
                // Clean up UI
                hideStopButton();
                
                // Clear status and progress
                chatStatus.textContent = '';
                chatStatus.className = 'status-message';
                
                const progressEl = document.getElementById('chat-progress');
                if (progressEl) {
                    progressEl.classList.remove('active');
                    if (progressEl.timerInterval) {
                        clearInterval(progressEl.timerInterval);
                        progressEl.timerInterval = null;
                        progressEl.startTime = null;
                    }
                }
                
                // Re-enable input and model activity
                chatInput.disabled = false;
                sendButton.disabled = false;
                updateModelActivity('idle');
            }
        }

        function appendMessage(sender, text, isMarkdown=false) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
            if(isMarkdown && window.marked) {
                let parsedHTML = window.marked.parse(text);
                if (sender === 'bot') {
                    parsedHTML = enhanceMarkdownRendering(parsedHTML);
                }
                messageDiv.innerHTML = parsedHTML;
            } else {
                messageDiv.textContent = text;
            }
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight; // Scroll to bottom
            
            // ëŒ€í™” íˆìŠ¤í† ë¦¬ì— ì €ì¥ (ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì œì™¸)
            if (sender === 'user') {
                addToConversationHistory('user', text);
            } else if (sender === 'bot' && !text.includes('âš ï¸') && !text.includes('âŒ') && !text.includes('ì•ˆë…•í•˜ì„¸ìš”! ğŸ‘‹')) {
                // ì—ëŸ¬ ë©”ì‹œì§€ë‚˜ ì›°ì»´ ë©”ì‹œì§€ëŠ” íˆìŠ¤í† ë¦¬ì—ì„œ ì œì™¸
                addToConversationHistory('assistant', text);
            }
        }
        
        function createEnhancedMultimodalMessage(result) {
            console.log('Creating enhanced multimodal message:', { cached: result.cached, responseLength: result.response?.length });
            
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'bot-message', 'multimodal-message');
            
            // Add cache indicator if applicable
            if (result.cached) {
                messageDiv.classList.add('cached-message');
                const cacheIndicator = document.createElement('div');
                cacheIndicator.classList.add('cache-indicator');
                cacheIndicator.innerHTML = 'ğŸ’¾ ìºì‹œëœ ì‘ë‹µ (êµ¬ì¡°í™” ì™„ë£Œ)';
                messageDiv.appendChild(cacheIndicator);
            }
            
            // ë©”ì¸ ë‹µë³€ í…ìŠ¤íŠ¸ (ìºì‹œëœ ì‘ë‹µì— ëŒ€í•´ ê°•ì œ ë§ˆí¬ë‹¤ìš´ ì²˜ë¦¬)
            const responseDiv = document.createElement('div');
            responseDiv.classList.add('response-text');
            
            // Force markdown parsing for all responses, especially cached ones
            if (window.marked && result.response) {
                try {
                    console.log('Applying markdown to response:', { 
                        cached: result.cached, 
                        responseLength: result.response.length,
                        preview: result.response.substring(0, 100),
                        markedAvailable: !!window.marked
                    });
                    
                    // Configure marked with enhanced options for better formatting
                    if (window.marked.setOptions) {
                        window.marked.setOptions({
                            breaks: true,           // ì¤„ë°”ê¿ˆ ì²˜ë¦¬
                            gfm: true,             // GitHub Flavored Markdown
                            tables: true,          // í‘œ ì§€ì›
                            pedantic: false,       // ì—„ê²©í•˜ì§€ ì•Šì€ íŒŒì‹±
                            sanitize: false,       // HTML í—ˆìš©
                            smartLists: true,      // ë˜‘ë˜‘í•œ ë¦¬ìŠ¤íŠ¸ ì²˜ë¦¬
                            smartypants: false     // ë”°ì˜´í‘œ ë³€í™˜ ë¹„í™œì„±í™”
                        });
                    }
                    
                    // For cached responses, ensure proper markdown parsing - THINK ë¸”ë¡ í•„í„°ë§ ì ìš©
                    const filteredResponse = styleThinkBlocks(result.response);
                    let parsedHtml = window.marked.parse(filteredResponse);
                    parsedHtml = enhanceMarkdownRendering(parsedHtml);
                    responseDiv.innerHTML = parsedHtml;
                    
                    // Apply additional styling for tables and code blocks
                    responseDiv.querySelectorAll('table').forEach(table => {
                        table.style.cssText = 'border-collapse: collapse; width: 100%; margin: 1rem 0;';
                        table.querySelectorAll('th, td').forEach(cell => {
                            cell.style.cssText = 'border: 1px solid #ddd; padding: 8px; text-align: left;';
                        });
                        table.querySelectorAll('th').forEach(header => {
                            header.style.cssText += 'background-color: #f2f2f2; font-weight: bold;';
                        });
                    });
                    
                    // Style code blocks
                    responseDiv.querySelectorAll('pre').forEach(pre => {
                        pre.style.cssText = 'background-color: #f8f9fa; padding: 1rem; border-radius: 4px; overflow-x: auto; border-left: 4px solid #007bff;';
                    });
                    
                    console.log('Markdown parsing successful, HTML length:', parsedHtml.length);
                    
                } catch (markdownError) {
                    console.error('Markdown parsing failed:', markdownError);
                    const filteredResponse = styleThinkBlocks(result.response);
                    responseDiv.textContent = filteredResponse;
                }
            } else {
                console.warn('Marked not available or no response text');
                const filteredResponse = styleThinkBlocks(result.response || '');
                responseDiv.textContent = filteredResponse;
            }
            messageDiv.appendChild(responseDiv);
            
            // Content summary removed - now handled by streaming service with accordion format
            
            // Media references - í˜„ì¬ ê°œë°œ ì¤‘ìœ¼ë¡œ ìˆ¨ê¹€ ì²˜ë¦¬
            /* ì°¸ì¡° ì´ë¯¸ì§€/í‘œ ê¸°ëŠ¥ì€ í˜„ì¬ ê°œë°œ ì¤‘ì…ë‹ˆë‹¤
            if (result.media_references && result.media_references.has_media) {
                const mediaDiv = document.createElement('div');
                mediaDiv.classList.add('media-content');
                mediaDiv.style.display = 'none'; // ì„ì‹œ ìˆ¨ê¹€
                
                // Referenced images
                if (result.media_references.images && result.media_references.images.length > 0) {
                    const imagesDiv = document.createElement('div');
                    imagesDiv.classList.add('referenced-media');
                    imagesDiv.innerHTML = '<h4>ğŸ–¼ï¸ ì°¸ì¡°ëœ ì´ë¯¸ì§€</h4>';
                    
                    result.media_references.images.forEach(img => {
                        const imgContainer = document.createElement('div');
                        imgContainer.classList.add('media-item');
                        imgContainer.innerHTML = `
                            <img src="${img.path}" alt="${img.metadata || 'Referenced image'}" 
                                 loading="lazy" style="max-width: 300px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div class="media-caption">${img.metadata || 'ì´ë¯¸ì§€'}</div>
                        `;
                        imagesDiv.appendChild(imgContainer);
                    });
                    mediaDiv.appendChild(imagesDiv);
                }
                
                // Referenced tables
                if (result.media_references.tables && result.media_references.tables.length > 0) {
                    const tablesDiv = document.createElement('div');
                    tablesDiv.classList.add('referenced-media');
                    tablesDiv.innerHTML = '<h4>ğŸ“‹ ì°¸ì¡°ëœ í‘œ</h4>';
                    
                    result.media_references.tables.forEach(table => {
                        const tableContainer = document.createElement('div');
                        tableContainer.classList.add('media-item');
                        tableContainer.innerHTML = `
                            <img src="${table.path}" alt="${table.metadata || 'Referenced table'}" 
                                 loading="lazy" style="max-width: 400px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div class="media-caption">${table.metadata || 'í‘œ'}</div>
                        `;
                        tablesDiv.appendChild(tableContainer);
                    });
                    mediaDiv.appendChild(tablesDiv);
                }
                
                messageDiv.appendChild(mediaDiv);
            }
            */
            
            return messageDiv;
        }

        function appendMultimodalMessage(sender, result) {
            const messageDiv = createEnhancedMultimodalMessage(result);
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // Enhanced chat progress functions with real-time status updates
        function showChatProgress() {
            const progressEl = document.getElementById('chat-progress');
            const progressMessage = document.getElementById('chat-progress-message');
            
            progressEl.classList.add('active');
            
            // Reset all steps
            document.querySelectorAll('.progress-step').forEach(step => {
                step.classList.remove('active', 'completed');
            });
            
            // Start with query analysis step - wait for backend status
            updateProgressStep('query', 'ì§ˆë¬¸ì„ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...');
            
            // Don't auto-complete query step - let backend control progression
        }
        
        function updateProgressStep(stepName, message, details = {}) {
            // Ensure details is always an object
            if (!details || typeof details !== 'object') {
                details = {};
            }
            const progressEl = document.getElementById('chat-progress');
            const progressMainText = document.getElementById('progress-main-text');
            const steps = ['query', 'embedding', 'search', 'generate'];
            
            console.log(`ğŸ“Š Progress Update: ${stepName} - ${message}`, details);
            
            // Update main progress text
            if (progressMainText) {
                progressMainText.textContent = message;
            }
            
            // Update timer (ì²˜ìŒì—ë§Œ ì‹œì‘, ì´í›„ì—ëŠ” ìœ ì§€)
            if (!progressEl.startTime) {
                progressEl.startTime = Date.now();
                progressEl.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - progressEl.startTime) / 1000);
                    const timerEl = document.getElementById('progress-timer');
                    if (timerEl) {
                        timerEl.textContent = `${elapsed}ì´ˆ`;
                    }
                }, 1000);
            }
            
            // Mark previous steps as completed (ê°•ì œë¡œ ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ ì œê±°)
            const currentIndex = steps.indexOf(stepName);
            for (let i = 0; i < currentIndex; i++) {
                const stepEl = document.querySelector(`[data-step="${steps[i]}"]`);
                if (stepEl) {
                    // ê°•ì œë¡œ ëª¨ë“  ìƒíƒœ ì œê±°í•˜ê³  completed ìƒíƒœë¡œ ì„¤ì •
                    stepEl.classList.remove('active', 'pending');
                    stepEl.classList.add('completed');
                    
                    // ìŠ¤í”¼ë„ˆ ì œê±°í•˜ê³  ì²´í¬ ë§ˆí¬ë¡œ êµì²´
                    const statusEl = stepEl.querySelector('.step-status');
                    if (statusEl) {
                        statusEl.innerHTML = '<div class="step-check">âœ“</div>';
                    }
                    
                    // ì•„ì´ì½˜ì—ì„œë„ ì• ë‹ˆë©”ì´ì…˜ ì œê±°
                    const iconEl = stepEl.querySelector('.progress-step-icon');
                    if (iconEl) {
                        iconEl.style.animation = 'none';
                    }
                    
                    console.log(`âœ… Force completed ${steps[i]}`);
                }
            }
            
            // Mark current step as active or completed based on message
            const currentStepEl = document.querySelector(`[data-step="${stepName}"]`);
            if (currentStepEl) {
                // Check if this step is completed (based on message keywords)
                const isCompleted = message.includes('ì™„ë£Œ') || message.includes('Done') || message.includes('Completed');
                
                if (isCompleted) {
                    // Mark as completed
                    currentStepEl.classList.remove('active', 'pending');
                    currentStepEl.classList.add('completed');
                    
                    // Update status to completed (remove spinner, add check)
                    const statusEl = document.getElementById(`${stepName}-status`);
                    if (statusEl) {
                        statusEl.innerHTML = '<div class="step-check">âœ“</div>';
                    }
                    
                    console.log(`âœ… Marked ${stepName} as completed: ${message}`);
                } else {
                    // Mark as active (in progress)
                    currentStepEl.classList.remove('completed', 'pending');
                    currentStepEl.classList.add('active');
                    
                    // Update step status with spinner (í˜„ì¬ ë‹¨ê³„ë§Œ)
                    const statusEl = document.getElementById(`${stepName}-status`);
                    if (statusEl) {
                        const spinnerHtml = '<div class="step-spinner"></div>';
                        statusEl.innerHTML = spinnerHtml;
                    }
                    
                    // í˜„ì¬ ë‹¨ê³„ ì•„ì´ì½˜ì—ë§Œ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
                    const iconEl = currentStepEl.querySelector('.progress-step-icon');
                    if (iconEl) {
                        iconEl.style.animation = ''; // ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜ ë³µì›
                    }
                    
                    console.log(`ğŸ”„ Marked ${stepName} as active: ${message}`);
                }
                
                // Special handling for generate step
                if (stepName === 'generate' && details && details.responseLength) {
                    const responseLengthEl = document.getElementById('response-length');
                    if (responseLengthEl) {
                        responseLengthEl.textContent = `${details.responseLength}ì`;
                        responseLengthEl.style.display = 'inline-block';
                    }
                }
            }
            
            // Mark future steps as pending (ì• ë‹ˆë©”ì´ì…˜ ì—†ì´)
            for (let i = currentIndex + 1; i < steps.length; i++) {
                const stepEl = document.querySelector(`[data-step="${steps[i]}"]`);
                if (stepEl) {
                    stepEl.classList.remove('active', 'completed');
                    stepEl.classList.add('pending');
                    
                    // ë¯¸ë˜ ë‹¨ê³„ ì•„ì´ì½˜ ì• ë‹ˆë©”ì´ì…˜ ì œê±°
                    const iconEl = stepEl.querySelector('.progress-step-icon');
                    if (iconEl) {
                        iconEl.style.animation = 'none';
                    }
                    
                    // ë¯¸ë˜ ë‹¨ê³„ ìŠ¤í”¼ë„ˆ ì œê±°
                    const statusEl = stepEl.querySelector('.step-status');
                    if (statusEl) {
                        statusEl.innerHTML = '';
                    }
                }
            }
            
            // Update message with typing effect for generate step
            if (stepName === 'generate' && message.includes('ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤')) {
                if (progressMainText) {
                    showTypingEffect(progressMainText, message);
                }
            } else {
                if (progressMainText) {
                    progressMainText.textContent = message;
                }
            }
        }
        
        function showTypingEffect(element, baseMessage) {
            let dots = 0;
            const typingInterval = setInterval(() => {
                dots = (dots + 1) % 4;
                element.textContent = baseMessage + '.'.repeat(dots);
            }, 500);
            
            // Store interval for cleanup
            const progressEl = document.getElementById('chat-progress');
            progressEl.typingInterval = typingInterval;
        }
        
        function updateResponseProgress(wordCount, estimatedTotal) {
            const message = `ë‹µë³€ ìƒì„± ì¤‘... (${wordCount}/${estimatedTotal} ë‹¨ì–´)`;
            updateChatProgressStep('generate', message);
        }
        
        // ì¦‰ì‹œ ì§„í–‰ìƒí™© ì´ˆê¸°í™” í•¨ìˆ˜ (ë™ì¼ ì§ˆë¬¸ ì‹œ ê¹¨ë—í•œ ì‹œì‘ì„ ìœ„í•´)
        function resetChatProgress() {
            const progressEl = document.getElementById('chat-progress');
            if (!progressEl) return;
            
            // ì¦‰ì‹œ ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬
            if (progressEl.timerInterval) {
                clearInterval(progressEl.timerInterval);
                progressEl.timerInterval = null;
            }
            if (progressEl.stepInterval) {
                clearInterval(progressEl.stepInterval);
                progressEl.stepInterval = null;
            }
            if (progressEl.typingInterval) {
                clearInterval(progressEl.typingInterval);
                progressEl.typingInterval = null;
            }
            
            // ì¦‰ì‹œ ìƒíƒœ ì´ˆê¸°í™”
            progressEl.classList.remove('active', 'completing');
            progressEl.startTime = null;
            
            // ëª¨ë“  ë‹¨ê³„ ì´ˆê¸°í™” (ì• ë‹ˆë©”ì´ì…˜ ì™„ì „ ì œê±°)
            document.querySelectorAll('.progress-step').forEach(step => {
                step.classList.remove('active', 'completed', 'pending');
                
                // ëª¨ë“  ì•„ì´ì½˜ ì• ë‹ˆë©”ì´ì…˜ ê°•ì œ ì œê±°
                const iconEl = step.querySelector('.progress-step-icon');
                if (iconEl) {
                    iconEl.style.animation = 'none';
                }
                
                // ëª¨ë“  ìŠ¤í”¼ë„ˆ ì œê±°
                const statusEl = step.querySelector('.step-status');
                if (statusEl) {
                    statusEl.innerHTML = '';
                }
            });
            
            // ì§„í–‰ë¥  ì´ˆê¸°í™”
            const progressMainText = document.getElementById('progress-main-text');
            if (progressMainText) progressMainText.textContent = 'AI ë‹µë³€ ìƒì„± ì¤‘...';
        }

        function hideChatProgress() {
            const progressEl = document.getElementById('chat-progress');
            
            // Add completion animation before hiding
            progressEl.classList.add('completing');
            
            // Update final status
            const progressMainText = document.getElementById('progress-main-text');
            if (progressMainText) progressMainText.textContent = 'ë‹µë³€ ìƒì„± ì™„ë£Œ! ğŸ‰';
            
            // Mark all steps as completed
            document.querySelectorAll('.progress-step').forEach(step => {
                step.classList.remove('active', 'pending');
                step.classList.add('completed');
                const statusEl = step.querySelector('.step-status');
                if (statusEl) {
                    statusEl.innerHTML = '<div class="step-check">âœ“</div>';
                }
            });
            
            // Clear timers
            if (progressEl.timerInterval) {
                clearInterval(progressEl.timerInterval);
                progressEl.timerInterval = null;
            }
            if (progressEl.stepInterval) {
                clearInterval(progressEl.stepInterval);
                progressEl.stepInterval = null;
            }
            if (progressEl.typingInterval) {
                clearInterval(progressEl.typingInterval);
                progressEl.typingInterval = null;
            }
            
            // Hide after animation
            setTimeout(() => {
                progressEl.classList.remove('active', 'completing');
                
                // Reset for next use (ë™ì¼í•œ ë¡œì§ì„ resetChatProgressë¡œ ìœ„ì„)
                setTimeout(() => {
                    resetChatProgress();
                }, 500);
            }, 1500);
        }

        // ì±„íŒ… ì „ìš© ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ë‹¨ìˆœí™”)
        function updateChatProgressStep(step, message = '', details = {}) {
            // ì±„íŒ… ì§„í–‰ë¥ ì€ ë¬¸ì„œ ì²˜ë¦¬ ì§„í–‰ë¥ ê³¼ ë¶„ë¦¬í•˜ì—¬ ì—…ë°ì´íŠ¸
            if (document.getElementById('progress-container') && 
                document.getElementById('progress-container').style.display !== 'none') {
                // ë¬¸ì„œ ì²˜ë¦¬ ì¤‘ì´ë©´ ì±„íŒ… ì§„í–‰ë¥  ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŒ
                return;
            }
            
            // ìƒˆë¡œìš´ ë‹¨ê³„ë¡œ ì§„í–‰í•  ë•Œ ì´ì „ ë‹¨ê³„ë“¤ì„ ì¡°ìš©íˆ ì™„ë£Œ ì²˜ë¦¬
            const steps = ['query', 'embedding', 'search', 'generate'];
            const currentStepIndex = steps.indexOf(step);
            
            // í˜„ì¬ ë‹¨ê³„ ì´ì „ì˜ ëª¨ë“  ë‹¨ê³„ë¥¼ ì™„ë£Œ ìƒíƒœë¡œ ë§ˆí‚¹ (UI ì—…ë°ì´íŠ¸ ì—†ì´)
            for (let i = 0; i < currentStepIndex; i++) {
                const prevStep = document.querySelector(`.progress-step[data-step="${steps[i]}"]`);
                if (prevStep && !prevStep.classList.contains('completed')) {
                    prevStep.classList.remove('active');
                    prevStep.classList.add('completed');
                    console.log(`âœ… Silently completing previous step: ${steps[i]}`);
                }
            }
            
            // í˜„ì¬ ë‹¨ê³„ ì—…ë°ì´íŠ¸
            updateProgressStep(step, message, 0, details);
        }
        
        // ë‹¨ê³„ëª… ë°˜í™˜ í—¬í¼ í•¨ìˆ˜
        function getStepName(step) {
            const stepNames = {
                'query': 'ì§ˆë¬¸ë¶„ì„',
                'embedding': 'ì„ë² ë”©',
                'search': 'ë¬¸ì„œê²€ìƒ‰',
                'generate': 'ë‹µë³€ìƒì„±'
            };
            return stepNames[step] || step;
        }

        // Ollama ìƒíƒœ ë° ëª¨ë¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
        async function fetchOllamaStatusAndModels() {
            const statusEl = document.getElementById('ollama-status');
            // ìƒíƒœ
            try {
                const res = await fetch('/api/ollama/status');
                const data = await res.json();
                const status = data.status === 'running' ? 'âœ… ì‹¤í–‰ ì¤‘' : (data.status === 'not running' ? 'âŒ ì¤‘ì§€ë¨' : 'â“ ' + data.status);
                statusEl.textContent = 'Ollama ìƒíƒœ: ' + status;
                statusEl.className = 'status-display ' + (data.status === 'running' ? 'status-running' : 'status-stopped');
            } catch (e) {
                statusEl.textContent = 'Ollama ìƒíƒœ: âŒ í™•ì¸ ì‹¤íŒ¨';
                statusEl.className = 'status-display status-stopped';
            }
            // ëª¨ë¸ ëª©ë¡
            try {
                const res = await fetch('/api/ollama/models');
                const data = await res.json();
                const select = document.getElementById('ollama-models');
                
                // í˜„ì¬ ì„ íƒëœ ëª¨ë¸ ì €ì¥ (ìˆë‹¤ë©´)
                const currentSelected = select.value;
                
                select.innerHTML = '';
                if (data.models && data.models.length > 0) {
                    let qwenFound = false;
                    let defaultModel = null;
                    
                    data.models.forEach((model, index) => {
                        const opt = document.createElement('option');
                        opt.value = model;
                        opt.textContent = formatModelName(model);
                        select.appendChild(opt);
                        
                        // qwen3:30b-a3b ëª¨ë¸ ì°¾ê¸° (ìš°ì„  ì„ íƒ)
                        if (!qwenFound && model.toLowerCase().includes('qwen3:30b-a3b')) {
                            qwenFound = true;
                            defaultModel = model;
                        }
                        // qwen ê³„ì—´ ëª¨ë¸ ì°¾ê¸° (ë‘ ë²ˆì§¸ ìš°ì„ ìˆœìœ„)
                        else if (!qwenFound && !defaultModel && model.toLowerCase().includes('qwen')) {
                            defaultModel = model;
                        }
                        
                        // ì²« ë²ˆì§¸ ëª¨ë¸ì„ ë°±ì—…ìœ¼ë¡œ ì €ì¥
                        if (!defaultModel) {
                            defaultModel = model;
                        }
                        
                        // ì´ì „ì— ì„ íƒëœ ëª¨ë¸ì´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì„ íƒ
                        if (currentSelected && model === currentSelected) {
                            opt.selected = true;
                        }
                    });
                    
                    // ì´ì „ ì„ íƒì´ ì—†ìœ¼ë©´ Gemma ëª¨ë¸ ë˜ëŠ” ì²« ë²ˆì§¸ ëª¨ë¸ ì„ íƒ
                    if (!currentSelected && defaultModel) {
                        select.value = defaultModel;
                        // í•´ë‹¹ ì˜µì…˜ì„ ì„ íƒ ìƒíƒœë¡œ ë§Œë“¤ê¸°
                        const targetOption = select.querySelector(`option[value="${defaultModel}"]`);
                        if (targetOption) {
                            targetOption.selected = true;
                        }
                    }
                    
                    // í˜„ì¬ ì„ íƒëœ ëª¨ë¸ í‘œì‹œ ì—…ë°ì´íŠ¸
                    updateSelectedModelDisplay();
                } else {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = 'ëª¨ë¸ ì—†ìŒ';
                    select.appendChild(opt);
                }
            } catch (e) {
                const select = document.getElementById('ollama-models');
                select.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'ëª¨ë¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨';
                select.appendChild(opt);
            }
        }
        function getSelectedModel() {
            const select = document.getElementById('ollama-models');
            return select.value;
        }
        
        // ëª¨ë¸ëª… ê°„ë‹¨í•˜ê²Œ í¬ë§·
        function formatModelName(fullModelName) {
            if (!fullModelName) return fullModelName;
            
            // ì¼ë°˜ì ì¸ íŒ¨í„´ë“¤ ì²˜ë¦¬
            const patterns = [
                // llama2:7b -> Llama2 (7B)
                { regex: /^(\w+):(\d+\.?\d*b?)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // qwen2:1.5b -> Qwen2 (1.5B)
                { regex: /^(\w+\d*):(\d+\.?\d*b?)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // gemma:2b-instruct -> Gemma (2B-Instruct)
                { regex: /^(\w+):(\d+\.?\d*b?-?\w*)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // llama2:latest -> Llama2 (Latest)
                { regex: /^(\w+):latest$/i, format: (match) => `${capitalize(match[1])} (Latest)` },
                // codellama:13b-code -> CodeLlama (13B-Code)
                { regex: /^(\w+):(\d+\.?\d*b?-?\w*)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
            ];
            
            for (const pattern of patterns) {
                const match = fullModelName.match(pattern.regex);
                if (match) {
                    return pattern.format(match);
                }
            }
            
            // ë§¤ì¹­ë˜ì§€ ì•ŠëŠ” ê²½ìš° ì²« ë²ˆì§¸ ë¶€ë¶„ë§Œ ì‚¬ìš©í•˜ê±°ë‚˜ ì „ì²´ ì´ë¦„ ì‚¬ìš©
            if (fullModelName.includes(':')) {
                const parts = fullModelName.split(':');
                return `${capitalize(parts[0])} (${parts[1]})`;
            }
            
            return capitalize(fullModelName);
        }
        
        // ì²« ê¸€ìë¥¼ ëŒ€ë¬¸ìë¡œ ë³€í™˜
        function capitalize(str) {
            if (!str) return str;
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        // í˜„ì¬ ì„ íƒëœ ëª¨ë¸ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateSelectedModelDisplay() {
            const select = document.getElementById('ollama-models');
            const selectedModel = select.value;
            
            if (selectedModel) {
                select.style.color = '#495057';
                select.style.fontWeight = '500';
                
                // ëª¨ë¸ ì •ë³´ ì—…ë°ì´íŠ¸
                updateModelInfo(selectedModel);
            }
        }
        
        // ëª¨ë¸ ì •ë³´ ì—…ë°ì´íŠ¸ (ê°œì„ ëœ ë²„ì „)
        function updateModelInfo(modelName) {
            const modelInfoEl = document.getElementById('model-info');
            const activityEl = document.getElementById('model-activity');
            
            if (!modelName) {
                modelInfoEl.textContent = 'ëª¨ë¸ ì„ íƒë˜ì§€ ì•ŠìŒ';
                activityEl.style.display = 'none';
                return;
            }
            
            // ëª¨ë¸ ìƒì„¸ ì •ë³´ ì¶”ì •
            const modelInfo = getModelInfo(modelName);
            modelInfoEl.innerHTML = `
                <div style="line-height: 1.3;">
                    <div style="font-weight: 600; color: #2c3e50; font-size: 0.9em;">
                        ${modelInfo.vendor} â€¢ ${modelInfo.size}
                    </div>
                    <div style="font-size: 0.75em; color: #6c757d;">
                        ${modelInfo.type} â€¢ ${modelInfo.language}
                    </div>
                </div>
            `;
            
            // ì‘ë™ ìƒíƒœ í‘œì‹œ
            activityEl.style.display = 'flex';
            updateModelActivity('idle');
        }
        
        // ëª¨ë¸ ì •ë³´ ì¶”ì • (ê°œì„ ëœ ë²„ì „)
        function getModelInfo(modelName) {
            const name = modelName.toLowerCase();
            
            // ì œì‘ì‚¬ ì¶”ì •
            let vendor = 'Unknown';
            if (name.includes('llama')) vendor = 'Meta';
            else if (name.includes('gemma')) vendor = 'Google';
            else if (name.includes('qwen')) vendor = 'Alibaba';
            else if (name.includes('mistral')) vendor = 'Mistral AI';
            else if (name.includes('phi')) vendor = 'Microsoft';
            else if (name.includes('codellama')) vendor = 'Meta';
            else if (name.includes('vicuna')) vendor = 'LMSYS';
            else if (name.includes('alpaca')) vendor = 'Stanford';
            else if (name.includes('wizardlm')) vendor = 'WizardLM';
            else if (name.includes('nous')) vendor = 'Nous Research';
            
            // í¬ê¸° ì¶”ì •
            let size = 'í¬ê¸° ë¶ˆëª…';
            if (name.includes('0.5b')) size = '0.5B';
            else if (name.includes('1b')) size = '1B';
            else if (name.includes('1.5b')) size = '1.5B';
            else if (name.includes('2b')) size = '2B';
            else if (name.includes('3b')) size = '3B';
            else if (name.includes('7b')) size = '7B';
            else if (name.includes('8b')) size = '8B';
            else if (name.includes('9b')) size = '9B';
            else if (name.includes('13b')) size = '13B';
            else if (name.includes('14b')) size = '14B';
            else if (name.includes('20b')) size = '20B';
            else if (name.includes('30b') || name.includes('33b')) size = '30B+';
            else if (name.includes('70b')) size = '70B';
            else if (name.includes('180b')) size = '180B';
            
            // íƒ€ì… ì¶”ì •
            let type = 'ì¼ë°˜í˜•';
            if (name.includes('instruct')) type = 'ì§€ì‹œ íŠ¹í™”';
            else if (name.includes('chat')) type = 'ëŒ€í™” íŠ¹í™”';
            else if (name.includes('code')) type = 'ì½”ë”© íŠ¹í™”';
            else if (name.includes('vision')) type = 'ë¹„ì „ ëª¨ë¸';
            else if (name.includes('math')) type = 'ìˆ˜í•™ íŠ¹í™”';
            else if (name.includes('reasoning')) type = 'ì¶”ë¡  íŠ¹í™”';
            
            // ì–¸ì–´ ì§€ì› ì¶”ì •
            let language = 'ë‹¤êµ­ì–´';
            if (name.includes('ko') || name.includes('korean')) language = 'í•œêµ­ì–´ íŠ¹í™”';
            else if (name.includes('en') || name.includes('english')) language = 'ì˜ì–´ íŠ¹í™”';
            else if (name.includes('zh') || name.includes('chinese')) language = 'ì¤‘êµ­ì–´ íŠ¹í™”';
            else if (name.includes('jp') || name.includes('japanese')) language = 'ì¼ë³¸ì–´ íŠ¹í™”';
            
            return { vendor, size, type, language };
        }
        
        // ëª¨ë¸ í™œë™ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateModelActivity(status, progress = 0) {
            const gauge = document.getElementById('activity-gauge');
            const text = document.getElementById('activity-text');
            
            if (!gauge || !text) return;
            
            switch(status) {
                case 'idle':
                    gauge.style.background = 'conic-gradient(#6c757d 0deg, #e9ecef 0deg)';
                    text.textContent = 'ëŒ€ê¸°ì¤‘';
                    text.style.color = '#6c757d';
                    break;
                case 'active':
                    const angle = (progress / 100) * 360;
                    gauge.style.background = `conic-gradient(#28a745 ${angle}deg, #e9ecef ${angle}deg)`;
                    text.textContent = 'í™œì„±';
                    text.style.color = '#28a745';
                    break;
                case 'processing':
                    gauge.style.background = 'conic-gradient(#007bff 0deg, #007bff 90deg, #e9ecef 90deg, #e9ecef 180deg, #007bff 180deg, #007bff 270deg, #e9ecef 270deg)';
                    gauge.style.animation = 'spin 1s linear infinite';
                    text.textContent = 'ì²˜ë¦¬ì¤‘';
                    text.style.color = '#007bff';
                    break;
                case 'error':
                    gauge.style.background = 'conic-gradient(#dc3545 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = 'ì˜¤ë¥˜';
                    text.style.color = '#dc3545';
                    break;
            }
        }
        
        // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateProcessingActivity(status, progress = 0) {
            const gauge = document.getElementById('processing-gauge');
            const text = document.getElementById('processing-text');
            
            if (!gauge || !text) return;
            
            switch(status) {
                case 'idle':
                    gauge.style.background = 'conic-gradient(#6c757d 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = 'ëŒ€ê¸°ì¤‘';
                    text.style.color = '#6c757d';
                    break;
                case 'processing':
                    // ì§„í–‰ë¥ ì´ ì œê³µëœ ê²½ìš° ì§„í–‰ë¥  í‘œì‹œ, ì•„ë‹ˆë©´ ìŠ¤í”¼ë„ˆ ì• ë‹ˆë©”ì´ì…˜
                    if (progress > 0) {
                        const angle = (progress / 100) * 360;
                        gauge.style.background = `conic-gradient(#007bff ${angle}deg, #e9ecef ${angle}deg)`;
                        gauge.style.animation = 'none';
                        text.textContent = `ì²˜ë¦¬ì¤‘ ${Math.round(progress)}%`;
                    } else {
                        gauge.style.background = 'conic-gradient(#007bff 0deg, #007bff 90deg, #e9ecef 90deg, #e9ecef 180deg, #007bff 180deg, #007bff 270deg, #e9ecef 270deg)';
                        gauge.style.animation = 'spin 1s linear infinite';
                        text.textContent = 'ì²˜ë¦¬ì¤‘';
                    }
                    text.style.color = '#007bff';
                    break;
                case 'completed':
                    const angle = (progress / 100) * 360;
                    gauge.style.background = `conic-gradient(#28a745 ${angle}deg, #e9ecef ${angle}deg)`;
                    gauge.style.animation = 'none';
                    text.textContent = 'ì™„ë£Œ';
                    text.style.color = '#28a745';
                    break;
                case 'completed_with_errors':
                    const angleWarning = (progress / 100) * 360;
                    gauge.style.background = `conic-gradient(#ffc107 ${angleWarning}deg, #e9ecef ${angleWarning}deg)`;
                    gauge.style.animation = 'none';
                    text.textContent = 'ì™„ë£Œ(ì˜¤ë¥˜)';
                    text.style.color = '#ffc107';
                    break;
                case 'error':
                    gauge.style.background = 'conic-gradient(#dc3545 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = 'ì˜¤ë¥˜';
                    text.style.color = '#dc3545';
                    break;
            }
        }
        
        // ì‹œìŠ¤í…œ í†µê³„ ì—…ë°ì´íŠ¸
        async function updateSystemStats() {
            try {
                // ë¬¸ì„œ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                const docsRes = await fetch('/api/documents');
                const docsData = await docsRes.json();
                
                // ì €ì¥ì†Œ í†µê³„ ê°€ì ¸ì˜¤ê¸°
                const statsRes = await fetch('/api/storage/stats');
                const statsData = await statsRes.json();
                
                // UI ì—…ë°ì´íŠ¸
                const docCount = docsData.documents ? docsData.documents.length : 0;
                const totalChunks = docsData.documents ? 
                    docsData.documents.reduce((sum, doc) => sum + (doc.chunk_count || 0), 0) : 0;
                
                document.getElementById('doc-count').textContent = docCount;
                document.getElementById('chunk-count').textContent = totalChunks;
                
                if (statsRes.ok && statsData.file_storage) {
                    const sizeMB = Math.round(statsData.file_storage.total_size_mb || 0);
                    document.getElementById('storage-size').textContent = `${sizeMB}MB`;
                }
                
                // ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„
                const now = new Date();
                const timeStr = now.toLocaleTimeString('ko-KR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                document.getElementById('last-update').textContent = timeStr;
                
            } catch (error) {
                console.error('ì‹œìŠ¤í…œ í†µê³„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
            }
        }
        
        // ë¹ ë¥¸ ì„¤ì • í† ê¸€ ì´ë²¤íŠ¸
        function setupQuickSettings() {
            // OCR êµì • í† ê¸€
            const ocrToggle = document.getElementById('ocr-correction-toggle');
            ocrToggle.addEventListener('change', (e) => {
                console.log('OCR êµì •:', e.target.checked ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”');
                // ì‹¤ì œ ì„¤ì • ë³€ê²½ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
            });
            
            // LLM êµì • í† ê¸€
            const llmToggle = document.getElementById('llm-correction-toggle');
            llmToggle.addEventListener('change', (e) => {
                console.log('LLM êµì •:', e.target.checked ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”');
                // ì‹¤ì œ ì„¤ì • ë³€ê²½ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
            });
            
            // ìë™ ìƒˆë¡œê³ ì¹¨ í† ê¸€
            const autoRefreshToggle = document.getElementById('auto-refresh-toggle');
            autoRefreshToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    startDocumentListPolling();
                    updateAutoRefreshIndicator('í™œì„±í™”');
                } else {
                    stopDocumentListPolling();
                    updateAutoRefreshIndicator('ë¹„í™œì„±í™”');
                }
            });
            
            // ì™¸ë¶€ ì ‘ì† í† ê¸€
            const externalAccessToggle = document.getElementById('external-access-toggle');
            const externalAccessBadge = document.getElementById('external-access-badge');
            externalAccessToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    console.log('ì™¸ë¶€ ì ‘ì†: í™œì„±í™”');
                    externalAccessBadge.textContent = 'ğŸŸ¢ í™œì„±';
                    externalAccessBadge.style.color = '#28a745';
                    externalAccessBadge.style.background = 'rgba(40, 167, 69, 0.1)';
                    externalAccessBadge.style.borderColor = 'rgba(40, 167, 69, 0.3)';
                    externalAccessBadge.title = 'ì™¸ë¶€ API/ì›¹ ê²€ìƒ‰ í—ˆìš©ë¨';
                } else {
                    console.log('ì™¸ë¶€ ì ‘ì†: ë¹„í™œì„±í™”');
                    externalAccessBadge.textContent = 'ğŸ”´ ì°¨ë‹¨';
                    externalAccessBadge.style.color = '#dc3545';
                    externalAccessBadge.style.background = 'rgba(220, 53, 69, 0.1)';
                    externalAccessBadge.style.borderColor = 'rgba(220, 53, 69, 0.3)';
                    externalAccessBadge.title = 'ì™¸ë¶€ API/ì›¹ ê²€ìƒ‰ ì°¨ë‹¨ë¨';
                }
                // ì‹¤ì œ ì„¤ì • ë³€ê²½ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
            });
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ Ollama ìƒíƒœ/ëª¨ë¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°ëŠ” ì•„ë˜ DOMContentLoadedì—ì„œ ì²˜ë¦¬

        // í”„ë¡œê·¸ë ˆìŠ¤ë°” ë‹¨ê³„ë³„ ë§¤í•‘
        const progressSteps = [
            { step: 'Preparing', percent: 0 },
            { step: 'Starting', percent: 1 },
            { step: 'Analyzing', percent: 10 },
            { step: 'OCR', percent: 50 },
            { step: 'text_preprocessing', percent: 56 },
            { step: 'text_splitting', percent: 58 },
            { step: 'chunk_validation', percent: 60 },
            { step: 'chunk_correction', percent: 61 },
            { step: 'chunk_preparation', percent: 62 },
            { step: 'Chunking', percent: 62 },
            { step: 'Embedding', percent: 65 },
            { step: 'Metadata', percent: 75 },
            { step: 'Storing', percent: 80 },
            { step: 'TextCorrection', percent: 85 },
            { step: 'Done', percent: 100 },
            { step: 'Completed', percent: 100 },
            { step: 'Error', percent: 100 },
        ];
        
        // CSS-safe documentId ìƒì„± í•¨ìˆ˜
        function createSafeId(documentId) {
            // íŒŒì¼ëª…ì˜ ê³µë°±, íŠ¹ìˆ˜ë¬¸ìë¥¼ ì–¸ë”ìŠ¤ì½”ì–´ë¡œ ë³€í™˜í•˜ê³  CSS-safeí•˜ê²Œ ë§Œë“¦
            return documentId.replace(/[^a-zA-Z0-9_-]/g, '_');
        }
        
        // ë‹¤ì¤‘ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì  ë³€ìˆ˜ë“¤
        let multiFileTracking = {
            files: new Map(), // originalDocumentId -> {safeId, filename, status, interval, startTime}
            intervals: new Set(),
            hideTimeout: null
        };
        
        // ê²½ê³¼ì‹œê°„ í¬ë§·íŒ… í•¨ìˆ˜
        function formatElapsedTime(startTime) {
            if (!startTime) return '';
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // ì—…ë¡œë“œ ì§„í–‰ë¥  UI ìˆ¨ê¸°ê¸° í•¨ìˆ˜
        function hideUploadProgressUI() {
            // ê°œë³„ íŒŒì¼ ì—…ë¡œë“œ ì§„í–‰ë¥  ëª©ë¡ ì œê±°
            const progressList = document.getElementById('progress-list');
            if (progressList) {
                // ë¶€ë“œëŸ¬ìš´ í˜ì´ë“œì•„ì›ƒ íš¨ê³¼
                progressList.style.transition = 'opacity 0.5s ease';
                progressList.style.opacity = '0';
                
                setTimeout(() => {
                    progressList.remove();
                }, 500);
            }
            
            // ì—…ë¡œë“œ ì§„í–‰ë¥  ì œëª© ì œê±° (progress-listì™€ í•¨ê»˜ ìƒì„±ëœ ì œëª©)
            const progressContainer = document.getElementById('progress-container');
            if (progressContainer) {
                const titleElements = progressContainer.querySelectorAll('h5');
                titleElements.forEach(title => {
                    if (title.textContent.includes('ê°œë³„ íŒŒì¼ ì—…ë¡œë“œ ì§„í–‰ë¥ ')) {
                        title.style.transition = 'opacity 0.5s ease';
                        title.style.opacity = '0';
                        setTimeout(() => {
                            if (title.parentNode) {
                                title.remove();
                            }
                        }, 500);
                    }
                });
            }
            
            console.log('ì—…ë¡œë“œ ì§„í–‰ë¥  UI ìˆ¨ê¹€ ì²˜ë¦¬ ì™„ë£Œ');
        }
        
        // ë‹¤ì¤‘ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì  ì‹œì‘
        function startMultiFileProgressTracking(files) {
            console.log('ë‹¤ì¤‘ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì  ì‹œì‘:', files);
            
            // ì§„í–‰ë¥  ì»¨í…Œì´ë„ˆ í‘œì‹œ
            const progressContainer = document.getElementById('progress-container');
            progressContainer.style.display = 'block';
            
            // ì „ì²´ ì§„í–‰ë¥  ë°” í‘œì‹œ
            const overallProgressBarContainer = document.getElementById('overall-progress-bar-container');
            if (overallProgressBarContainer) {
                overallProgressBarContainer.style.display = 'block';
            }
            
            // ì—…ë¡œë“œ ì§„í–‰ë¥  ì°½ ìˆ¨ê¸°ê¸° (ë¬¸ì„œ ì²˜ë¦¬ ì‹œì‘) - 2ì´ˆ í›„ ë¶€ë“œëŸ½ê²Œ ì‚¬ë¼ì§
            setTimeout(() => {
                hideUploadProgressUI();
            }, 2000);
            
            // ê¸°ì¡´ ë°ì´í„° ì •ë¦¬
            clearMultiFileTracking();
            
            // ì „ì²´ ì§„í–‰ë¥  ì´ˆê¸°í™”
            updateOverallProgress(0, files.length);
            
            // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  UI ìƒì„± ë° ì¶”ì  ì‹œì‘
            files.forEach(file => {
                createIndividualProgressUI(file.documentId, file.filename);
                startIndividualFileTracking(file.documentId, file.filename);
            });
        }
        
        // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  UI ìƒì„± (ë™ì  ìŠ¤íƒ€ì¼)
        function createIndividualProgressUI(documentId, filename) {
            const container = document.getElementById('individual-progress-container');
            const safeId = createSafeId(documentId);
            
            const fileDiv = document.createElement('div');
            fileDiv.id = `progress-${safeId}`;
            fileDiv.className = 'file-progress-card';
            fileDiv.style.cssText = `
                margin-bottom: 15px; 
                padding: 15px; 
                border: 1px solid #dee2e6; 
                border-radius: 12px; 
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.05);
                transition: all 0.3s ease;
            `;
            
            fileDiv.innerHTML = `
                <!-- íŒŒì¼ í—¤ë” -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div id="file-icon-${safeId}" style="font-size: 1.2em;">ğŸ“„</div>
                        <div style="display: flex; flex-direction: column;">
                            <span style="font-weight: 600; color: #2c3e50; font-size: 1rem; max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${filename}">${filename}</span>
                            <span style="font-size: 0.8em; color: #6c757d;">ë¬¸ì„œ ì²˜ë¦¬ ì¤‘...</span>
                        </div>
                    </div>
                    <div id="status-badge-${safeId}" class="status-badge status-waiting">
                        <span id="status-text-${safeId}">ëŒ€ê¸° ì¤‘</span>
                    </div>
                </div>
                
                <!-- ì²˜ë¦¬ ë‹¨ê³„ í‘œì‹œ (ë™ì ) -->
                <div id="process-steps-${safeId}" class="process-steps-dynamic">
                    <!-- í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ë‹¨ê³„ë§Œ í‘œì‹œë©ë‹ˆë‹¤ -->
                </div>
                
                <!-- ì§„í–‰ë¥  ë°” (ì „ì²´) -->
                <div style="margin-top: 10px;">
                    <div style="height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">
                        <div id="progress-bar-${safeId}" style="height: 100%; width: 0%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.3s ease;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.85em; color: #6c757d;">
                        <span id="progress-text-${safeId}">0%</span>
                        <span id="time-info-${safeId}"></span>
                    </div>
                </div>
            `;
            
            container.appendChild(fileDiv);
        }
        
        // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì 
        function startIndividualFileTracking(documentId, filename) {
            const startTime = Date.now(); // ì²˜ë¦¬ ì‹œì‘ ì‹œê°„ ê¸°ë¡
            let retryCount = 0;
            const maxRetries = 20; // ìµœëŒ€ 20ë²ˆ ì¬ì‹œë„ë¡œ ì¦ê°€ (ì•½ 30ì´ˆ)
            const safeId = createSafeId(documentId); // CSS-safe ID ìƒì„±
            
            // ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ ì‹œì‘ì„ ìœ„í•´ 2ì´ˆ ì§€ì—° í›„ ìƒíƒœ ì¡°íšŒ ì‹œì‘ (3ì´ˆâ†’2ì´ˆ ë‹¨ì¶•)
            setTimeout(() => {
                const interval = setInterval(async () => {
                    try {
                        const res = await fetch(`/api/upload_status/${documentId}`);
                        const data = await res.json();
                        
                        // ë¬¸ì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš° ì¬ì‹œë„ ì²˜ë¦¬
                        if (data.step === 'Unknown' || data.message?.includes('ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤')) {
                            retryCount++;
                            
                            // ì§„í–‰ìƒí™© í‘œì‹œ ì—…ë°ì´íŠ¸
                            const progressElement = document.getElementById(`progress-${safeId}`);
                            if (progressElement) {
                                const processStepsContainer = progressElement.querySelector(`#process-steps-${safeId}`);
                                if (processStepsContainer) {
                                    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                                    processStepsContainer.innerHTML = `
                                        <div class="current-step-display waiting compact">
                                            <div class="step-icon waiting">â³</div>
                                            <div class="step-text-compact">
                                                <span class="main-text">ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ ì‹œì‘ ëŒ€ê¸° ì¤‘... (${retryCount}/${maxRetries} ì‹œë„, ${elapsedSeconds}ì´ˆ ê²½ê³¼)</span>
                                            </div>
                                        </div>
                                    `;
                                }
                            }
                            
                            console.log(`ğŸ“‹ Document ${documentId} not found, retry ${retryCount}/${maxRetries}... (${Math.floor((Date.now() - startTime) / 1000)}ì´ˆ ê²½ê³¼)`);
                            
                            // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œì—ë§Œ ì¤‘ë‹¨
                            if (retryCount >= maxRetries) {
                                console.warn(`âŒ Document ${documentId} not found after ${maxRetries} retries, stopping... (ì´ ${Math.floor((Date.now() - startTime) / 1000)}ì´ˆ ì†Œìš”)`);
                                clearInterval(interval);
                                multiFileTracking.intervals.delete(interval);
                                
                                // UIì— ì‹¤íŒ¨ ë©”ì‹œì§€ í‘œì‹œ
                                if (progressElement) {
                                    const processStepsContainer = progressElement.querySelector(`#process-steps-${safeId}`);
                                    if (processStepsContainer) {
                                        processStepsContainer.innerHTML = `
                                            <div class="current-step-display error compact">
                                                <div class="step-icon error">âŒ</div>
                                                <div class="step-text-compact">
                                                    <span class="main-text">ì²˜ë¦¬ ì‹œì‘ ì‹¤íŒ¨ - ë°±ì—”ë“œ ìƒíƒœ í™•ì¸ ë¶ˆê°€ (${Math.floor((Date.now() - startTime) / 1000)}ì´ˆ ì†Œìš”)</span>
                                                </div>
                                            </div>
                                        `;
                                    }
                                    
                                    // íŒŒì¼ ì¹´ë“œë¥¼ ì—ëŸ¬ ìƒíƒœë¡œ ë³€ê²½
                                    progressElement.className = 'file-progress-card error';
                                    
                                    const statusBadge = progressElement.querySelector(`#status-badge-${safeId}`);
                                    const statusText = progressElement.querySelector(`#status-text-${safeId}`);
                                    const fileIcon = progressElement.querySelector(`#file-icon-${safeId}`);
                                    const timeInfo = progressElement.querySelector(`#time-info-${safeId}`);
                                    
                                    if (statusBadge) statusBadge.className = 'status-badge status-error';
                                    if (statusText) statusText.textContent = 'ì²˜ë¦¬ ì‹¤íŒ¨';
                                    if (fileIcon) fileIcon.textContent = 'âŒ';
                                    if (timeInfo) timeInfo.textContent = 'ì‹¤íŒ¨';
                                }
                                
                                // íŒŒì¼ ì¶”ì ì—ì„œ ì—ëŸ¬ ìƒíƒœë¡œ ë§ˆí‚¹
                                const fileInfo = multiFileTracking.files.get(documentId);
                                if (fileInfo) {
                                    fileInfo.status = 'Error';
                                    fileInfo.completed = true; // ì—ëŸ¬ë„ ì™„ë£Œë¡œ ê°„ì£¼
                                }
                                updateOverallProgressFromFiles();
                                checkAllFilesCompleted(); // ì™„ë£Œ ìƒíƒœ ì²´í¬
                                return;
                            }
                            
                            // ì¬ì‹œë„ ì¤‘ì´ë¯€ë¡œ í•¨ìˆ˜ ì¢…ë£Œí•˜ê³  ë‹¤ìŒ interval ëŒ€ê¸°
                            return;
                        }
                        
                        // ì •ìƒ ì‘ë‹µ ì‹œ ì¬ì‹œë„ ì¹´ìš´í„° ë¦¬ì…‹
                        retryCount = 0;
                        
                        updateIndividualProgress(documentId, data);
                    
                    // íŒŒì¼ ìƒíƒœ ì—…ë°ì´íŠ¸ - ë°±ì—”ë“œ percent ê°’ ìš°ì„  ì‚¬ìš©
                    const actualPercent = data.percent !== undefined ? data.percent : (progressSteps.find(s => s.step === data.step) || { percent: 0 }).percent;
                    const fileInfo = multiFileTracking.files.get(documentId) || {};
                    multiFileTracking.files.set(documentId, {
                        ...fileInfo,
                        filename,
                        status: data.step,
                        progress: actualPercent,
                        completed: data.step === 'Done' || data.step === 'Completed' || data.step === 'Error',
                        startTime: fileInfo.startTime || startTime // ì‹œì‘ ì‹œê°„ ìœ ì§€
                    });
                        
                        // ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì‹¤ì‹œê°„)
                        updateOverallProgressFromFiles();
                        
                        if (data.step === 'Done' || data.step === 'Completed' || data.step === 'Error') {
                            clearInterval(interval);
                            multiFileTracking.intervals.delete(interval);
                            checkAllFilesCompleted();
                        }
                    } catch (error) {
                        console.error(`ì§„í–‰ë¥  ì¶”ì  ì˜¤ë¥˜ (${documentId}):`, error);
                        const progressElement = document.getElementById(`progress-${safeId}`);
                        if (progressElement) {
                            const processStepsContainer = progressElement.querySelector(`#process-steps-${safeId}`);
                            if (processStepsContainer) {
                                processStepsContainer.innerHTML = `
                                    <div class="current-step-display error compact">
                                        <div class="step-icon error">âš ï¸</div>
                                        <div class="step-text-compact">
                                            <span class="main-text">ìƒíƒœ í™•ì¸ ì‹¤íŒ¨: ${error.message}</span>
                                        </div>
                                    </div>
                                `;
                            }
                        }
                    }
                }, 1500);
                
                multiFileTracking.intervals.add(interval);
                multiFileTracking.files.set(documentId, {
                    filename,
                    status: 'starting',
                    interval,
                    completed: false,
                    startTime: startTime // ì‹œì‘ ì‹œê°„ ì €ì¥
                });
            }, 3000); // 3ì´ˆ ì§€ì—° í›„ ìƒíƒœ ì¡°íšŒ ì‹œì‘
        }
        
        // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ë™ì  ìŠ¤íƒ€ì¼)
        function updateIndividualProgress(documentId, data) {
            // ë°±ì—”ë“œ percent ê°’ì„ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ ë‹¨ê³„ë³„ ê°’ ì‚¬ìš©
            const percent = data.percent !== undefined ? data.percent : (progressSteps.find(s => s.step === data.step) || { percent: 0 }).percent;
            const safeId = createSafeId(documentId); // CSS-safe ID ìƒì„±
            
            // ë©”ì¸ UI ìš”ì†Œë“¤ (CSS-safe ID ì‚¬ìš©)
            const fileCard = document.getElementById(`progress-${safeId}`);
            const progressBar = document.getElementById(`progress-bar-${safeId}`);
            const statusBadge = document.getElementById(`status-badge-${safeId}`);
            const statusText = document.getElementById(`status-text-${safeId}`);
            const progressText = document.getElementById(`progress-text-${safeId}`);
            const timeInfo = document.getElementById(`time-info-${safeId}`);
            const fileIcon = document.getElementById(`file-icon-${safeId}`);
            
            // ì§„í–‰ë¥  ë°” ì—…ë°ì´íŠ¸ (ì‹¤ì œ percent ê°’ ì‚¬ìš©, 0-100 ë²”ìœ„ ì œí•œ)
            const displayPercent = Math.max(0, Math.min(100, Math.round(percent)));
            if (progressBar) progressBar.style.width = displayPercent + '%';
            if (progressText) {
                // í˜ì´ì§€ ì •ë³´ê°€ ìˆìœ¼ë©´ ì¶”ê°€ í‘œì‹œ
                if (data.current_page && data.total_pages) {
                    progressText.textContent = `${displayPercent}% (${data.current_page}/${data.total_pages} í˜ì´ì§€)`;
                } else {
                    progressText.textContent = `${displayPercent}%`;
                }
            }
            
            // multiFileTrackingì˜ íŒŒì¼ ì •ë³´ë„ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            if (multiFileTracking.files.has(documentId)) {
                const fileInfo = multiFileTracking.files.get(documentId);
                fileInfo.progress = displayPercent;
                fileInfo.status = data.step;
                const wasCompleted = fileInfo.completed;
                fileInfo.completed = data.step === 'Done' || data.step === 'Completed' || data.step === 'Error';
                if (!wasCompleted && fileInfo.completed) {
                    console.log(`íŒŒì¼ ${documentId} ì™„ë£Œë¨ (ìƒíƒœ: ${data.step})`);
                }
                multiFileTracking.files.set(documentId, fileInfo);
            }
            
            // í”„ë¡œì„¸ìŠ¤ ë‹¨ê³„ ì—…ë°ì´íŠ¸ (ìƒì„¸ ì •ë³´ í¬í•¨)
            updateProcessSteps(documentId, data.step, data);
            
            if (data.step === 'Done' || data.step === 'Completed') {
                // ì™„ë£Œ ìƒíƒœ
                if (fileCard) {
                    fileCard.className = 'file-progress-card completed';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-completed';
                }
                if (statusText) statusText.textContent = 'ì™„ë£Œ';
                if (fileIcon) fileIcon.textContent = 'âœ…';
                if (progressBar) {
                    progressBar.style.background = 'linear-gradient(90deg, #28a745 0%, #20c997 100%)';
                    progressBar.style.width = '100%';
                }
                if (progressText) progressText.textContent = '100%';
                if (timeInfo) timeInfo.textContent = 'ì™„ë£Œë¨';
                
            } else if (data.step === 'Error') {
                // ì˜¤ë¥˜ ìƒíƒœ
                if (fileCard) {
                    fileCard.className = 'file-progress-card error';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-error';
                }
                if (statusText) statusText.textContent = 'ì˜¤ë¥˜';
                if (fileIcon) fileIcon.textContent = 'âŒ';
                if (progressBar) {
                    progressBar.style.background = 'linear-gradient(90deg, #dc3545 0%, #e74c3c 100%)';
                }
                if (timeInfo) timeInfo.textContent = 'ì˜¤ë¥˜ ë°œìƒ';
                
            } else if (data.step === 'Queued') {
                // ëŒ€ê¸°ì—´ ìƒíƒœ
                if (fileCard) {
                    fileCard.className = 'file-progress-card queued';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-queued';
                }
                if (statusText) {
                    if (data.details && data.details.queue_position) {
                        statusText.textContent = `ëŒ€ê¸° ì¤‘ (${data.details.queue_position}ë²ˆì§¸)`;
                    } else {
                        statusText.textContent = 'ëŒ€ê¸° ì¤‘';
                    }
                }
                if (fileIcon) fileIcon.textContent = 'â³';
                if (timeInfo) timeInfo.textContent = 'ëŒ€ê¸° ì¤‘';
                
            } else {
                // ì²˜ë¦¬ ì¤‘ ìƒíƒœ
                if (fileCard) {
                    fileCard.className = 'file-progress-card processing';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-processing';
                }
                if (statusText) statusText.textContent = 'ì²˜ë¦¬ ì¤‘';
                if (fileIcon) fileIcon.textContent = 'âš™ï¸';
                if (timeInfo) {
                    const fileInfo = multiFileTracking.files.get(documentId);
                    if (fileInfo && fileInfo.startTime) {
                        timeInfo.textContent = formatElapsedTime(fileInfo.startTime);
                    } else {
                        timeInfo.textContent = '00:00';
                    }
                }
            }
        }
        
        // í”„ë¡œì„¸ìŠ¤ ë‹¨ê³„ ì‹œê°í™” ì—…ë°ì´íŠ¸ (ë™ì  ë°©ì‹)
        function updateProcessSteps(documentId, currentStep, data = {}) {
            const safeId = createSafeId(documentId); // CSS-safe ID ìƒì„±
            const processStepsContainer = document.getElementById(`process-steps-${safeId}`);
            if (!processStepsContainer) return;
            
            // ë””ë²„ê¹… ë¡œê·¸ ì¶”ê°€
            console.log(`ğŸ“‹ ë‹¨ê³„ ì—…ë°ì´íŠ¸: ${documentId} - ${currentStep}`, data);
            
            // ìƒì„¸í•œ ë‹¨ê³„ë³„ í‘œì‹œ ì •ë³´
            let stepText = '';
            let stepIcon = '';
            
            switch(currentStep) {
                case 'Queued':
                    stepIcon = 'â³';
                    if (data.details && data.details.queue_position) {
                        stepText = `ì²˜ë¦¬ ëŒ€ê¸°ì—´ì—ì„œ ìˆœì„œë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘... (ëŒ€ê¸°ìˆœì„œ: ${data.details.queue_position}ë²ˆì§¸)`;
                    } else {
                        stepText = 'ì²˜ë¦¬ ëŒ€ê¸°ì—´ì—ì„œ ìˆœì„œë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
                    }
                    break;
                case 'Preparing':
                    stepIcon = 'ğŸ“‹';
                    stepText = 'ë¬¸ì„œ ì²˜ë¦¬ ì¤€ë¹„ ì¤‘...';
                    break;
                case 'Starting':
                    stepIcon = 'ğŸš€';
                    stepText = data.details && data.details.was_queued ? 'íì—ì„œ ì²˜ë¦¬ ì‹œì‘ë¨' : 'ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ ì‹œì‘ë¨';
                    break;
                case 'Analyzing':
                    stepIcon = 'ğŸ”';
                    stepText = `PDF íŒŒì¼ ë¶„ì„ ì¤‘... ${data.total_pages ? `(${data.total_pages}í˜ì´ì§€)` : ''}`;
                    break;
                case 'OCR':
                    stepIcon = 'ğŸ‘ï¸';
                    if (data.current_page && data.total_pages) {
                        const details = data.details || {};
                        const stage = details.stage || '';
                        let stageText = '';
                        if (stage === 'text') stageText = 'í…ìŠ¤íŠ¸ ì¶”ì¶œ';
                        else if (stage === 'images') stageText = 'ì´ë¯¸ì§€ ì¶”ì¶œ';
                        else if (stage === 'tables') stageText = 'í‘œ ì¶”ì¶œ';
                        else stageText = 'OCR ì²˜ë¦¬';
                        
                        stepText = `${stageText} (${data.current_page}/${data.total_pages} í˜ì´ì§€)`;
                    } else if (data.message) {
                        // ë©”ì‹œì§€ì—ì„œ ì¤‘ë³µ 'ì¤‘...' ì œê±°
                        let cleanMessage = data.message;
                        if (cleanMessage.includes('ì¤‘...') && !cleanMessage.endsWith('ì¤‘...')) {
                            cleanMessage = cleanMessage.replace(/ì¤‘\.\.\./g, '');
                        }
                        stepText = cleanMessage;
                    } else {
                        stepText = 'OCR ì²˜ë¦¬';
                    }
                    break;
                case 'Chunking':
                    stepIcon = 'ğŸ“';
                    if (data.details && data.details.text_length) {
                        stepText = `í…ìŠ¤íŠ¸ ë¶„í•  (${data.details.text_length.toLocaleString()}ì)`;
                    } else if (data.message) {
                        stepText = data.message.replace(/ì¤‘\.\.\./g, '');
                    } else {
                        stepText = 'í…ìŠ¤íŠ¸ ì²­í¬ ë¶„í• ';
                    }
                    break;
                case 'text_preprocessing':
                    stepIcon = 'ğŸ”§';
                    stepText = data.message || 'í…ìŠ¤íŠ¸ ì „ì²˜ë¦¬ ë° ë¶„ì„';
                    break;
                case 'text_splitting':
                    stepIcon = 'âœ‚ï¸';
                    stepText = data.message || 'í…ìŠ¤íŠ¸ ë¶„í•  ì§„í–‰';
                    break;
                case 'chunk_validation':
                    stepIcon = 'âœ…';
                    stepText = data.message || 'ì²­í¬ ê²€ì¦ ë° ìµœì í™”';
                    break;
                case 'chunk_correction':
                    stepIcon = 'ğŸ¤–';
                    stepText = data.message || 'ì²­í¬ OCR êµì •';
                    break;
                case 'chunk_preparation':
                    stepIcon = 'ğŸ“¦';
                    stepText = data.message || 'ì²­í¬ ì¤€ë¹„ ì™„ë£Œ';
                    break;
                case 'Embedding':
                    stepIcon = 'ğŸ§ ';
                    if (data.details && data.details.chunks_to_process) {
                        stepText = `ì„ë² ë”© ìƒì„± (${data.details.chunks_to_process}ê°œ ì²­í¬)`;
                    } else if (data.message) {
                        stepText = data.message.replace(/ì¤‘\.\.\./g, '');
                    } else {
                        stepText = 'ë²¡í„° ì„ë² ë”© ìƒì„±';
                    }
                    break;
                case 'Storing':
                    stepIcon = 'ğŸ’¾';
                    if (data.details) {
                        const details = data.details;
                        const parts = [];
                        if (details.texts) parts.push(`í…ìŠ¤íŠ¸ ${details.texts}ê°œ`);
                        if (details.images) parts.push(`ì´ë¯¸ì§€ ${details.images}ê°œ`);
                        if (details.tables) parts.push(`í‘œ ${details.tables}ê°œ`);
                        stepText = `ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ (${parts.join(', ')})`;
                    } else if (data.message) {
                        stepText = data.message.replace(/ì¤‘\.\.\./g, '');
                    } else {
                        stepText = 'ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥';
                    }
                    break;
                case 'TextCorrection':
                    stepIcon = 'ğŸ¤–';
                    if (data.details && data.details.batch_current && data.details.batch_total) {
                        const { batch_current, batch_total, text_length } = data.details;
                        stepText = `LLM í…ìŠ¤íŠ¸ êµì • (${batch_current}/${batch_total} ë°°ì¹˜, ${text_length?.toLocaleString()}ì)`;
                    } else if (data.message) {
                        stepText = data.message.replace(/ì¤‘\.\.\./g, '');
                    } else {
                        stepText = 'LLM í…ìŠ¤íŠ¸ êµì •';
                    }
                    break;
                case 'Done':
                case 'Completed':
                    stepIcon = 'âœ…';
                    if (data.details) {
                        const details = data.details;
                        stepText = `ì²˜ë¦¬ ì™„ë£Œ (${details.total_pages || 0}í˜ì´ì§€, ${details.text_chunks || 0}ì²­í¬, ${details.images || 0}ì´ë¯¸ì§€, ${details.tables || 0}í‘œ)`;
                    } else if (data.message) {
                        stepText = data.message;
                    } else {
                        stepText = 'ëª¨ë“  ì²˜ë¦¬ ì™„ë£Œ';
                    }
                    break;
                case 'Error':
                    stepIcon = 'âŒ';
                    stepText = data.message || 'ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                    break;
                default:
                    stepIcon = 'â³';
                    stepText = data.message || 'ì¤€ë¹„ ì¤‘...';
            }
            
            // ìƒíƒœë³„ CSS í´ë˜ìŠ¤ ê²°ì •
            let statusClass = 'waiting';
            if (currentStep === 'Done' || currentStep === 'Completed') {
                statusClass = 'completed';
            } else if (currentStep === 'Error') {
                statusClass = 'error';
            } else if (currentStep === 'Queued') {
                statusClass = 'queued';
            } else if (['Preparing', 'Starting', 'Analyzing', 'OCR', 'Chunking', 'text_preprocessing', 'text_splitting', 'chunk_validation', 'chunk_correction', 'chunk_preparation', 'Embedding', 'Metadata', 'Storing', 'TextCorrection'].includes(currentStep)) {
                statusClass = 'processing';
            }
            
            // ê²½ê³¼ì‹œê°„ ì¶”ê°€ (ì˜µì…˜)
            const fileInfo = multiFileTracking.files.get(documentId);
            const elapsedTime = (fileInfo && fileInfo.startTime) ? formatElapsedTime(fileInfo.startTime) : '';
            
            // í•œ ì¤„ ê¹”ë”í•œ ë‹¨ê³„ í‘œì‹œ
            const compactDetails = getCompactDetails(data.details || {});
            const fullText = compactDetails ? `${stepText} ${compactDetails}` : stepText;
            
            processStepsContainer.innerHTML = `
                <div class="current-step-display ${statusClass} compact">
                    <div class="step-icon ${statusClass}">${stepIcon}</div>
                    <div class="step-text-compact">
                        <span class="main-text">${fullText}</span>
                        ${elapsedTime ? `<span class="elapsed-time">${elapsedTime}</span>` : ''}
                    </div>
                </div>
            `;
        }
        
        // í•œ ì¤„ ì••ì¶• ìƒì„¸ ì •ë³´ ìƒì„±
        function getCompactDetails(details) {
            const compactItems = [];
            
            // ì¤‘ë³µ ì •ë³´ ë°©ì§€ë¥¼ ìœ„í•´ ìš°ì„ ìˆœìœ„ë³„ë¡œ í‘œì‹œ
            if (details.text_length && details.chunks_created) {
                compactItems.push(`${details.text_length.toLocaleString()}ì â†’ ${details.chunks_created}ì²­í¬`);
            } else if (details.text_length) {
                compactItems.push(`${details.text_length.toLocaleString()}ì`);
            } else if (details.chunks_created) {
                compactItems.push(`${details.chunks_created}ì²­í¬`);
            }
            
            if (details.embeddings_created) {
                compactItems.push(`${details.embeddings_created}ì„ë² ë”©`);
            }
            
            if (details.stored_texts || details.stored_images || details.stored_tables) {
                const counts = [];
                if (details.stored_texts) counts.push(`í…ìŠ¤íŠ¸${details.stored_texts}`);
                if (details.stored_images) counts.push(`ì´ë¯¸ì§€${details.stored_images}`);
                if (details.stored_tables) counts.push(`í‘œ${details.stored_tables}`);
                if (counts.length > 0) {
                    compactItems.push(counts.join(' â€¢ '));
                }
            }
            
            return compactItems.length > 0 ? ` â€¢ ${compactItems.join(' â€¢ ')}` : '';
        }
        
        // ìƒì„¸ ì •ë³´ë¥¼ í¬ë§·íŒ…í•˜ì—¬ í‘œì‹œ (ë ˆê±°ì‹œ - ì‚¬ìš©ì•ˆí•¨)
        function getFormattedDetails(details) {
            const items = [];
            
            if (details.stage) {
                const stageNames = {
                    'text': 'í…ìŠ¤íŠ¸ ì¶”ì¶œ',
                    'images': 'ì´ë¯¸ì§€ ì¶”ì¶œ', 
                    'tables': 'í‘œ ì¶”ì¶œ'
                };
                items.push(`ì²˜ë¦¬ ë‹¨ê³„: ${stageNames[details.stage] || details.stage}`);
            }
            
            if (details.pages_processed !== undefined) {
                items.push(`ì²˜ë¦¬ëœ í˜ì´ì§€: ${details.pages_processed}ê°œ`);
            }
            
            if (details.text_length !== undefined) {
                items.push(`í…ìŠ¤íŠ¸ ê¸¸ì´: ${details.text_length.toLocaleString()}ì`);
            }
            
            if (details.chunks_created !== undefined) {
                items.push(`ìƒì„±ëœ ì²­í¬: ${details.chunks_created}ê°œ`);
            }
            
            if (details.embeddings_created !== undefined) {
                items.push(`ìƒì„±ëœ ì„ë² ë”©: ${details.embeddings_created}ê°œ`);
            }
            
            if (details.embedding_dimension !== undefined) {
                items.push(`ë²¡í„° ì°¨ì›: ${details.embedding_dimension}ì°¨ì›`);
            }
            
            return items.map(item => `<div class="detail-item">â€¢ ${item}</div>`).join('');
        }
        
        // ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ ìƒì„±
        function getFriendlyMessage(step, originalMessage) {
            const friendlyMessages = {
                'OCR': 'ğŸ‘ï¸ OCRë¡œ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'Chunking': 'ğŸ“ í…ìŠ¤íŠ¸ë¥¼ ì²­í¬ë¡œ ë¶„í• í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'Embedding': 'ğŸ§  ì„ë² ë”© ë²¡í„°ë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'Storing': 'ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'Done': 'âœ… ëª¨ë“  ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!'
            };
            
            return friendlyMessages[step] || originalMessage || 'ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...';
        }
        
        // ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì™„ë£Œ ê°œìˆ˜ ê¸°ë°˜)
        function updateOverallProgress(completedCount, totalCount) {
            const progressBar = document.getElementById('overall-progress-bar');
            const countSpan = document.getElementById('overall-progress-count');
            const textSpan = document.getElementById('overall-progress-text');
            
            const percentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;
            
            if (progressBar) progressBar.style.width = percentage + '%';
            if (countSpan) countSpan.textContent = `${completedCount}/${totalCount} ì™„ë£Œ`;
            if (textSpan) {
                if (completedCount === totalCount && totalCount > 0) {
                    textSpan.textContent = 'âœ… ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ';
                    progressBar.style.background = '#28a745';
                } else {
                    textSpan.textContent = 'ì „ì²´ ì§„í–‰ë¥ ';
                    progressBar.style.background = '#28a745';
                }
            }
        }
        
        // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ê¸°ë°˜ ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì‹¤ì‹œê°„)
        // ë””ë°”ìš´ì‹±ì„ ìœ„í•œ ì „ì—­ ë³€ìˆ˜
        let overallProgressUpdateTimeout = null;
        
        function updateOverallProgressFromFiles() {
            // ë””ë°”ìš´ì‹±: ë¹ ë¥¸ ì—°ì† ì—…ë°ì´íŠ¸ë¥¼ ë°©ì§€í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”
            if (overallProgressUpdateTimeout) {
                clearTimeout(overallProgressUpdateTimeout);
            }
            
            overallProgressUpdateTimeout = setTimeout(() => {
                updateOverallProgressFromFilesImmediate();
            }, 100); // 100ms ë””ë°”ìš´ìŠ¤
        }
        
        function updateOverallProgressFromFilesImmediate() {
            const progressBar = document.getElementById('overall-progress-bar');
            const countSpan = document.getElementById('overall-progress-count');
            const textSpan = document.getElementById('overall-progress-text');
            
            const files = Array.from(multiFileTracking.files.values());
            if (files.length === 0) return;
            
            // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥ ì˜ ê°€ì¤‘ í‰ê·  ê³„ì‚° (ì‹¤ì œ ì§„í–‰ë¥  ë°˜ì˜)
            const totalProgress = files.reduce((sum, file) => {
                // progress ê°’ì´ ìœ íš¨í•œì§€ í™•ì¸í•˜ê³  0-100 ë²”ìœ„ë¡œ ì œí•œ
                const fileProgress = Math.max(0, Math.min(100, file.progress || 0));
                return sum + fileProgress;
            }, 0);
            const averageProgress = Math.round(totalProgress / files.length);
            
            // ì™„ë£Œëœ íŒŒì¼ ê°œìˆ˜ (ì—ëŸ¬ ìƒíƒœë„ ì™„ë£Œë¡œ ê°„ì£¼)
            const completedFiles = files.filter(f => f.completed);
            const errorFiles = files.filter(f => f.status === 'Error');
            const successFiles = completedFiles.filter(f => f.status !== 'Error');
            const completedCount = completedFiles.length;
            const totalCount = files.length;
            
            // ì§„í–‰ë¥  ë°” ì—…ë°ì´íŠ¸ (í‰ê·  ì§„í–‰ë¥  ê¸°ë°˜, ì™„ë£Œ ìƒíƒœ ê³ ë ¤)
            let displayProgress = averageProgress;
            
            // ëª¨ë“  íŒŒì¼ì´ ì™„ë£Œë˜ë©´ 100%ë¡œ ì„¤ì •
            if (completedCount === totalCount && totalCount > 0) {
                displayProgress = 100;
            }
            
            if (progressBar) progressBar.style.width = displayProgress + '%';
            if (countSpan) {
                // ì—ëŸ¬ê°€ ìˆëŠ” ê²½ìš° êµ¬ë¶„í•˜ì—¬ í‘œì‹œ
                if (errorFiles.length > 0) {
                    countSpan.textContent = `${completedCount}/${totalCount} ì™„ë£Œ (âš ï¸ ${errorFiles.length}ê°œ ì˜¤ë¥˜)`;
                } else {
                    countSpan.textContent = `${completedCount}/${totalCount} ì™„ë£Œ`;
                }
            }
            if (textSpan) {
                if (completedCount === totalCount && totalCount > 0) {
                    if (errorFiles.length > 0) {
                        textSpan.textContent = `âš ï¸ ì²˜ë¦¬ ì™„ë£Œ (${errorFiles.length}ê°œ íŒŒì¼ ì˜¤ë¥˜)`;
                        if (progressBar) progressBar.style.background = '#ffc107'; // ë…¸ë€ìƒ‰ (ê²½ê³ )
                    } else {
                        textSpan.textContent = 'âœ… ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ';
                        if (progressBar) progressBar.style.background = '#28a745'; // ì´ˆë¡ìƒ‰ (ì„±ê³µ)
                    }
                } else {
                    textSpan.textContent = `ì „ì²´ ì§„í–‰ë¥  (${displayProgress}%)`;
                    if (progressBar) progressBar.style.background = '#007bff'; // íŒŒë€ìƒ‰ (ì§„í–‰ì¤‘)
                    // ì‹¤ì‹œê°„ ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì²˜ë¦¬ ì¤‘, ì§„í–‰ë¥  ë°˜ì˜)
                    if (totalCount > 0) {
                        updateProcessingActivity('processing', displayProgress);
                    }
                }
            }
            
            // ìƒíƒœë³„ íŒŒì¼ ê°œìˆ˜ ë””ë²„ê¹… ë¡œê·¸
            console.log(`ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸: ${displayProgress}% (ì™„ë£Œ: ${completedCount}/${totalCount}, ì„±ê³µ: ${successFiles.length}, ì˜¤ë¥˜: ${errorFiles.length})`);
        }
        
        // ì™„ë£Œ í™•ì¸ ë””ë°”ìš´ì‹±ì„ ìœ„í•œ ì „ì—­ ë³€ìˆ˜
        let completionCheckTimeout = null;
        
        // ëª¨ë“  íŒŒì¼ ì™„ë£Œ í™•ì¸ (ë””ë°”ìš´ì‹± ì ìš©)
        function checkAllFilesCompleted() {
            // ë””ë°”ìš´ì‹±: ë¹ ë¥¸ ì—°ì† ì™„ë£Œ ì²´í¬ë¥¼ ë°©ì§€
            if (completionCheckTimeout) {
                clearTimeout(completionCheckTimeout);
            }
            
            completionCheckTimeout = setTimeout(() => {
                checkAllFilesCompletedImmediate();
            }, 200); // 200ms ë””ë°”ìš´ìŠ¤
        }
        
        function checkAllFilesCompletedImmediate() {
            const files = Array.from(multiFileTracking.files.values());
            const completedFiles = files.filter(f => f.completed);
            const errorFiles = files.filter(f => f.status === 'Error');
            const successFiles = completedFiles.filter(f => f.status !== 'Error');
            const totalFiles = files.length;
            
            console.log('checkAllFilesCompleted: ì™„ë£Œëœ íŒŒì¼', completedFiles.length, '/ ì „ì²´ íŒŒì¼', totalFiles, '(ì„±ê³µ:', successFiles.length, ', ì˜¤ë¥˜:', errorFiles.length, ')');
            updateOverallProgress(completedFiles.length, totalFiles);
            
            if (completedFiles.length === totalFiles && totalFiles > 0) {
                console.log('ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ!');
                
                // ì˜¤ë¥˜ ìˆëŠ” ê²½ìš°ì™€ ì„±ê³µí•œ ê²½ìš°ë¥¼ êµ¬ë¶„í•˜ì—¬ ìƒíƒœ ì—…ë°ì´íŠ¸
                if (errorFiles.length > 0) {
                    console.log(`âš ï¸ ì²˜ë¦¬ ì™„ë£Œë˜ì—ˆìœ¼ë‚˜ ${errorFiles.length}ê°œ íŒŒì¼ì— ì˜¤ë¥˜ ë°œìƒ`);
                    updateProcessingActivity('completed_with_errors', 100);
                } else {
                    console.log('âœ… ëª¨ë“  íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë¨');
                    updateProcessingActivity('completed', 100);
                }
                
                // ë¬¸ì„œ ëª©ë¡ ìƒˆë¡œê³ ì¹¨ (ì„±ê³µí•œ íŒŒì¼ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ)
                if (successFiles.length > 0) {
                    setTimeout(() => {
                        fetchDocumentList();
                        console.log('ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ: ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨');
                    }, 1000);
                }
                
                // ìë™ ìˆ¨ê¹€ ì„¤ì • í™•ì¸
                const autoHide = document.getElementById('auto-hide-progress');
                console.log('ìë™ ìˆ¨ê¹€ ì²´í¬ë°•ìŠ¤ ìƒíƒœ:', autoHide ? autoHide.checked : 'not found');
                if (autoHide && autoHide.checked) {
                    console.log('ìë™ ìˆ¨ê¹€ ì˜ˆì•½ ì¤‘...');
                    scheduleProgressHide();
                } else {
                    console.log('ìë™ ìˆ¨ê¹€ ë¹„í™œì„±í™”ë¨');
                }
            }
        }
        
        // ì§„í–‰ë¥  ì°½ ìë™ ìˆ¨ê¹€ ì˜ˆì•½
        function scheduleProgressHide() {
            console.log('scheduleProgressHide í˜¸ì¶œë¨ - 10ì´ˆ í›„ ìˆ¨ê¹€ ì˜ˆì•½');
            if (multiFileTracking.hideTimeout) {
                clearTimeout(multiFileTracking.hideTimeout);
                console.log('ê¸°ì¡´ íƒ€ì´ë¨¸ ì œê±°ë¨');
            }
            
            multiFileTracking.hideTimeout = setTimeout(() => {
                console.log('ìë™ ìˆ¨ê¹€ ì‹¤í–‰ ì¤‘...');
                const progressContainer = document.getElementById('progress-container');
                const selectedFilesContainer = document.getElementById('selected-files-container');
                
                if (progressContainer) {
                    progressContainer.style.display = 'none';
                    clearMultiFileTracking();
                    // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ëŒ€ê¸°ì¤‘'ìœ¼ë¡œ ë³µê·€
                    updateProcessingActivity('idle');
                }
                
                // ì„ íƒëœ íŒŒì¼ ëª©ë¡ë„ ìˆ¨ê¸°ê³  ì´ˆê¸°í™”
                if (selectedFilesContainer) {
                    selectedFilesContainer.style.display = 'none';
                    document.getElementById('selected-files-list').innerHTML = '';
                    selectedFilesForUpload.clear();
                    
                    // íŒŒì¼ ì…ë ¥ ì´ˆê¸°í™”
                    const pdfFileInput = document.getElementById('pdf-file');
                    if (pdfFileInput) {
                        pdfFileInput.value = '';
                    }
                    
                    // ì—…ë¡œë“œ ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
                    updateSelectedCount();
                }
            }, 10000); // 10ì´ˆ í›„ ìˆ¨ê¹€
        }
        
        // ë‹¤ì¤‘ íŒŒì¼ ì¶”ì  ì •ë¦¬
        function clearMultiFileTracking() {
            // ëª¨ë“  ì¸í„°ë²Œ ì •ë¦¬
            multiFileTracking.intervals.forEach(interval => clearInterval(interval));
            multiFileTracking.intervals.clear();
            
            // ìˆ¨ê¹€ íƒ€ì´ë¨¸ ì •ë¦¬
            if (multiFileTracking.hideTimeout) {
                clearTimeout(multiFileTracking.hideTimeout);
                multiFileTracking.hideTimeout = null;
            }
            
            // ë””ë°”ìš´ì‹± íƒ€ì´ë¨¸ë“¤ ì •ë¦¬
            if (overallProgressUpdateTimeout) {
                clearTimeout(overallProgressUpdateTimeout);
                overallProgressUpdateTimeout = null;
            }
            
            if (completionCheckTimeout) {
                clearTimeout(completionCheckTimeout);
                completionCheckTimeout = null;
            }
            
            // íŒŒì¼ ë°ì´í„° ì •ë¦¬
            multiFileTracking.files.clear();
            
            // ê°œë³„ ì§„í–‰ë¥  UI ì •ë¦¬
            const container = document.getElementById('individual-progress-container');
            if (container) container.innerHTML = '';
            
            console.log('ë‹¤ì¤‘ íŒŒì¼ ì¶”ì  ë°ì´í„° ë° íƒ€ì´ë¨¸ ëª¨ë‘ ì •ë¦¬ë¨');
        }
        
        // ê¸°ì¡´ ë‹¨ì¼ íŒŒì¼ ì§„í–‰ë¥  í•¨ìˆ˜ (í•˜ìœ„ í˜¸í™˜ì„±)
        function startProgressPolling(documentId) {
            const progressContainer = document.getElementById('progress-container');
            const progressBarInner = document.getElementById('progress-bar-inner');
            const progressMessage = document.getElementById('progress-message');
            progressContainer.style.display = 'block';
            progressBarInner.style.width = '0%';
            progressMessage.textContent = 'ì²˜ë¦¬ ëŒ€ê¸° ì¤‘...';
            if(progressInterval) clearInterval(progressInterval);
            progressInterval = setInterval(async () => {
                try {
                    const res = await fetch(`/api/upload_status/${documentId}`);
                    const data = await res.json();
                    const stepInfo = progressSteps.find(s => s.step === data.step) || { percent: 0 };
                    progressBarInner.style.width = stepInfo.percent + '%';
                    progressMessage.textContent = data.message || '';
                    if(data.step === 'Done' || data.step === 'Completed') {
                        progressMessage.textContent = 'âœ… ' + data.message;
                        clearInterval(progressInterval);
                        // ì²˜ë¦¬ ì™„ë£Œ ì‹œ ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨
                        setTimeout(() => {
                            fetchDocumentList();
                            console.log('ë¬¸ì„œ ì²˜ë¦¬ ì™„ë£Œ: ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨');
                        }, 1000);
                    } else if(data.step === 'Error') {
                        progressMessage.textContent = 'âŒ ' + data.message;
                        progressBarInner.style.background = '#dc3545';
                        clearInterval(progressInterval);
                    }
                } catch (e) {
                    progressMessage.textContent = 'ìƒíƒœ í™•ì¸ ì‹¤íŒ¨';
                }
            }, 1500);
        }

        // ë¬¸ì„œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ë° ë“œë¡­ë‹¤ìš´ ê°±ì‹ 
        async function fetchDocumentList() {
            try {
                const res = await fetch('/api/documents');
                const data = await res.json();
                
                // ì±„íŒ…ìš© ë¬¸ì„œ ì²´í¬ë°•ìŠ¤ ì—…ë°ì´íŠ¸
                const info = document.getElementById('document-info');
                const selectAllCheckbox = document.getElementById('select-all-docs');
                const individualDocCheckboxes = document.getElementById('individual-doc-checkboxes');
                const documentList = document.getElementById('document-list');
                
                if (!individualDocCheckboxes || !documentList) {
                    console.error('Required DOM elements not found');
                    return;
                }
                
                individualDocCheckboxes.innerHTML = '';
                documentList.innerHTML = '';
                
                // ê¸°ë³¸ ì „ì²´ ë¬¸ì„œ ì„ íƒ
                if (selectAllCheckbox) {
                    selectAllCheckbox.checked = true;
                }
                
                // ê°œë³„ ë¬¸ì„œ ì²´í¬ë°•ìŠ¤ ìƒì„± (ìƒˆë¡œìš´ ìœ„ì¹˜ì—)
                if (data.documents && data.documents.length > 0) {
                    // ì €ì¥ëœ ì •ë ¬ ìˆœì„œê°€ ìˆìœ¼ë©´ ì ìš©
                    let documentsToDisplay = [...data.documents];
                    const savedSortOrder = localStorage.getItem('documentSortOrder');
                    const savedSortAscending = localStorage.getItem('documentSortAscending');
                    
                    if (savedSortOrder) {
                        try {
                            const sortOrder = JSON.parse(savedSortOrder);
                            window.documentSortAscending = savedSortAscending === 'true';
                            
                            // ì €ì¥ëœ ìˆœì„œëŒ€ë¡œ ë¬¸ì„œ ì •ë ¬
                            documentsToDisplay.sort((a, b) => {
                                const indexA = sortOrder.indexOf(a.document_id);
                                const indexB = sortOrder.indexOf(b.document_id);
                                
                                // ë‘˜ ë‹¤ ì €ì¥ëœ ìˆœì„œì— ìˆìœ¼ë©´ ê·¸ ìˆœì„œëŒ€ë¡œ
                                if (indexA !== -1 && indexB !== -1) {
                                    return indexA - indexB;
                                }
                                // í•˜ë‚˜ë§Œ ì €ì¥ëœ ìˆœì„œì— ìˆìœ¼ë©´ ì €ì¥ëœ ê²ƒì„ ì•ìœ¼ë¡œ
                                if (indexA !== -1) return -1;
                                if (indexB !== -1) return 1;
                                // ë‘˜ ë‹¤ ì €ì¥ëœ ìˆœì„œì— ì—†ìœ¼ë©´ ê¸°ë³¸ ì •ë ¬
                                return a.document_id.localeCompare(b.document_id);
                            });
                            
                            console.log('ğŸ“‹ ì €ì¥ëœ ì •ë ¬ ìˆœì„œ ì ìš©ë¨:', savedSortAscending === 'true' ? 'ì˜¤ë¦„ì°¨ìˆœ' : 'ë‚´ë¦¼ì°¨ìˆœ');
                        } catch (e) {
                            console.warn('ì €ì¥ëœ ì •ë ¬ ìˆœì„œ íŒŒì‹± ì‹¤íŒ¨:', e);
                        }
                    }
                    
                    documentsToDisplay.forEach(doc => {
                        // ì±„íŒ…ìš© ì²´í¬ë°•ìŠ¤ (ìƒˆë¡œìš´ êµ¬ì¡°)
                        const div = document.createElement('div');
                        div.style.cssText = 'margin-bottom: 6px; display: flex; align-items: center; gap: 8px; padding: 4px 8px; border-radius: 4px; transition: background-color 0.2s;';
                        div.innerHTML = `
                            <input type="checkbox" id="doc-checkbox-${doc.document_id}" value="${doc.document_id}" data-preview="${doc.first_chunk_preview || ''}" style="margin: 0; transform: scale(0.9);">
                            <label for="doc-checkbox-${doc.document_id}" style="font-size: 0.85em; color: #495057; cursor: pointer; flex: 1; margin: 0;">
                                ğŸ“„ ${doc.document_id} <span style="color: #6c757d;">(${doc.chunk_count}ì²­í¬)</span>
                            </label>
                        `;
                        
                        // í˜¸ë²„ íš¨ê³¼
                        div.addEventListener('mouseenter', () => {
                            div.style.backgroundColor = '#f8f9fa';
                        });
                        div.addEventListener('mouseleave', () => {
                            div.style.backgroundColor = 'transparent';
                        });
                        
                        individualDocCheckboxes.appendChild(div);
                        
                        // ë¬¸ì„œ ê´€ë¦¬ ëª©ë¡ (ì¹´í…Œê³ ë¦¬í™”ëœ ì •ë³´ í‘œì‹œ)
                        const docDiv = document.createElement('div');
                        docDiv.className = 'document-item';
                        
                        // ë¬¸ì„œ ìœ í˜• ë¶„ì„
                        const fileName = doc.document_id;
                        let docType = 'ê¸°ìˆ ë¬¸ì„œ';
                        let docCategory = '';
                        
                        if (fileName.includes('ì£¼ë¬¼ê¸°ìˆ ì´ì„œ')) {
                            docType = 'ì£¼ë¬¼ê¸°ìˆ ì´ì„œ';
                            if (fileName.includes('Vol.')) {
                                const volMatch = fileName.match(/Vol\.\s*(\d+)/);
                                if (volMatch) {
                                    docCategory = `ì œ${volMatch[1]}ê¶Œ`;
                                }
                            }
                        } else if (fileName.includes('ì£¼ë¬¼')) {
                            docType = 'ì£¼ë¬¼ê¸°ìˆ ';
                        } else if (fileName.includes('ê¸°ìˆ ')) {
                            docType = 'ê¸°ìˆ ë¬¸ì„œ';
                        }
                        
                        // ì£¼ì œ ì¶”ì¶œ
                        let topic = '';
                        if (fileName.includes('ê²°í•¨')) topic = 'ê²°í•¨ë¶„ì„';
                        else if (fileName.includes('íƒ•êµ¬')) topic = 'íƒ•êµ¬ì„¤ê³„';
                        else if (fileName.includes('ì£¼ì¡°')) topic = 'ì£¼ì¡°ê³µì •';
                        else if (fileName.includes('ì‹œí—˜')) topic = 'ì‹œí—˜ë²•';
                        else if (fileName.includes('ë¶„ì„')) topic = 'ë¶„ì„ë²•';
                        else if (fileName.includes('ì£¼í˜•')) topic = 'ì£¼í˜•ê¸°ìˆ ';
                        else if (fileName.includes('ì›ê°€')) topic = 'ì›ê°€ê´€ë¦¬';
                        else if (fileName.includes('ê°•ë„')) topic = 'ê°•ë„ì¸¡ì •';
                        
                        // ì²­í¬ ìˆ˜ ê¸°ë°˜ ë¬¸ì„œ í¬ê¸°
                        let sizeInfo = '';
                        if (doc.chunk_count > 100) sizeInfo = 'ëŒ€ìš©ëŸ‰';
                        else if (doc.chunk_count > 50) sizeInfo = 'ì¤‘ìš©ëŸ‰';
                        else if (doc.chunk_count > 20) sizeInfo = 'ì†Œìš©ëŸ‰';
                        else sizeInfo = 'ë‹¨í¸';
                        
                        docDiv.innerHTML = `
                            <div class="document-info">
                                <div class="document-title">ğŸ“„ ${doc.document_id}</div>
                                <div class="text-muted" style="display: flex; gap: 10px; flex-wrap: wrap; margin: 5px 0;">
                                    <span style="background: #e3f2fd; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${docType}</span>
                                    ${docCategory ? `<span style="background: #f3e5f5; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${docCategory}</span>` : ''}
                                    ${topic ? `<span style="background: #e8f5e8; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${topic}</span>` : ''}
                                    <span style="background: #fff3e0; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${sizeInfo} ${doc.chunk_count}ì²­í¬</span>
                                </div>
                                ${doc.first_chunk_preview ? `<div class="document-preview" style="font-size: 0.8em; color: #666; margin-top: 5px; line-height: 1.3;">${doc.first_chunk_preview.slice(0, 120)}...</div>` : ''}
                            </div>
                            <div class="document-actions">
                                <button onclick="deleteDocument('${doc.document_id}')" class="btn btn-danger" style="padding: 6px 12px; font-size: 0.9rem;">
                                    ğŸ—‘ï¸ ì‚­ì œ
                                </button>
                            </div>
                        `;
                        documentList.appendChild(docDiv);
                    });
                    
                    // ì²« ë¬¸ì„œ ì •ë³´ í‘œì‹œ
                    if (info) {
                        info.textContent = data.documents[0].first_chunk_preview ? 
                            `ë¯¸ë¦¬ë³´ê¸°: ${data.documents[0].first_chunk_preview.slice(0, 60)}...` : '';
                    }
                    
                    // í´ë§ìš© ë¬¸ì„œ ê°œìˆ˜ ì—…ë°ì´íŠ¸
                    lastDocumentCount = data.documents.length;
                } else {
                    if (info) info.textContent = '';
                    documentList.innerHTML = '<div class="text-center text-muted">ğŸ“­ ì €ì¥ëœ ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                    lastDocumentCount = 0;
                }
                
                // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
                if (selectAllCheckbox) {
                    selectAllCheckbox.addEventListener('change', () => {
                        const checked = selectAllCheckbox.checked;
                        const boxes = individualDocCheckboxes.querySelectorAll('input[type="checkbox"]');
                        boxes.forEach(cb => { 
                            cb.disabled = checked; 
                            if (checked) cb.checked = false; 
                        });
                        updateChatPreview();
                    });
                }
                
                individualDocCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.addEventListener('change', updateChatPreview);
                });
                
            } catch (e) {
                console.error('ë¬¸ì„œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
                const documentList = document.getElementById('document-list');
                if (documentList) {
                    documentList.innerHTML = '<div class="status-message status-error">âŒ ë¬¸ì„œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨</div>';
                }
                if (document.getElementById('document-info')) {
                    document.getElementById('document-info').textContent = '';
                }
            }
        }
        // ì±—ë´‡ìš© ë¬¸ì„œ ì„ íƒ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
        function updateChatPreview() {
            const info = document.getElementById('document-info');
            const selectAll = document.getElementById('select-all-docs').checked;
            if (selectAll) {
                info.textContent = '';
                return;
            }
            const checked = Array.from(
                document.querySelectorAll('#individual-doc-checkboxes input[type="checkbox"]:checked')
            );
            const previews = checked.map(cb => cb.getAttribute('data-preview')).filter(Boolean);
            info.textContent = previews.length > 0
                ? `ë¯¸ë¦¬ë³´ê¸°: ${previews.map(p => p.slice(0, 60)).join(' | ')}...`
                : '';
        }
        // ì„ íƒëœ ë¬¸ì„œ ID ë°°ì—´ ë°˜í™˜ (ë¹ˆ ë°°ì—´ì€ ì „ì²´ ë¬¸ì„œ ì˜ë¯¸)
        // ë¬¸ì„œ ì„ íƒ UI ìƒí˜¸ì‘ìš© ì„¤ì •
        function setupDocumentSelectionInteraction() {
            const selectAllCheckbox = document.getElementById('select-all-docs');
            const specificDocSection = document.getElementById('specific-doc-section');
            const selectSpecificCheckbox = document.getElementById('select-specific-docs');
            const individualDocContainer = document.getElementById('individual-doc-container');

            console.log('Document selection interaction setup:', {
                selectAllCheckbox: !!selectAllCheckbox,
                specificDocSection: !!specificDocSection,
                selectSpecificCheckbox: !!selectSpecificCheckbox,
                individualDocContainer: !!individualDocContainer
            });

            if (!selectAllCheckbox || !specificDocSection || !selectSpecificCheckbox || !individualDocContainer) {
                console.error('Some document selection elements are missing');
                return;
            }

            // ì „ì²´ ë¬¸ì„œ ì„ íƒ ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸
            selectAllCheckbox.addEventListener('change', function() {
                console.log('ì „ì²´ ë¬¸ì„œ ì„ íƒ ë³€ê²½:', this.checked);
                if (this.checked) {
                    // ì „ì²´ ì„ íƒ ì‹œ íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì„¹ì…˜ ìˆ¨ê¸°ê¸°
                    specificDocSection.style.display = 'none';
                    selectSpecificCheckbox.checked = false;
                    individualDocContainer.style.display = 'none';
                } else {
                    // ì „ì²´ ì„ íƒ í•´ì œ ì‹œ íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì„¹ì…˜ê³¼ ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ ë°”ë¡œ í‘œì‹œ
                    specificDocSection.style.display = 'block';
                    selectSpecificCheckbox.checked = true;
                    individualDocContainer.style.display = 'block';
                    console.log('ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ ìë™ í‘œì‹œë¨');
                }
            });

            // íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸
            selectSpecificCheckbox.addEventListener('change', function() {
                console.log('íŠ¹ì • ë¬¸ì„œ ì„ íƒ ë³€ê²½:', this.checked);
                if (this.checked) {
                    // íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì‹œ ì „ì²´ ì„ íƒ í•´ì œí•˜ê³  ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
                    selectAllCheckbox.checked = false;
                    individualDocContainer.style.display = 'block';
                    console.log('ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ í‘œì‹œë¨');
                } else {
                    // íŠ¹ì • ë¬¸ì„œ ì„ íƒ í•´ì œ ì‹œ ë¦¬ìŠ¤íŠ¸ ìˆ¨ê¸°ê¸°
                    individualDocContainer.style.display = 'none';
                    // ì•„ë¬´ê²ƒë„ ì„ íƒë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì „ì²´ ì„ íƒìœ¼ë¡œ ë³µê·€
                    selectAllCheckbox.checked = true;
                    specificDocSection.style.display = 'none';
                    console.log('ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ ìˆ¨ê¹€');
                }
            });
        }

        function getSelectedDocumentIds() {
            const selectAll = document.getElementById('select-all-docs').checked;
            if (selectAll) return [];
            const checked = document.querySelectorAll('#individual-doc-checkboxes input[type="checkbox"]:checked');
            return Array.from(checked).map(cb => cb.value);
        }

        // ë¬¸ì„œ ê´€ë¦¬ ê¸°ëŠ¥ë“¤
        async function deleteDocument(documentId) {
            if (!confirm(`ë¬¸ì„œ "${documentId}"ë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }
            
            // ê¸°ì¡´ ë©”ì‹œì§€ í´ë¦¬ì–´
            clearManagementStatus();
            
            try {
                const response = await fetch(`/api/documents/${documentId}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âœ… ë¬¸ì„œ "${documentId}" ì‚­ì œ ì™„ë£Œ`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    
                    // ì„±ê³µ ë©”ì‹œì§€ë¥¼ 3ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 3000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âŒ ì‚­ì œ ì‹¤íŒ¨: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        // ë©”ì‹œì§€ í´ë¦¬ì–´ í—¬í¼ í•¨ìˆ˜
        function clearManagementStatus() {
            const statusEl = document.getElementById('management-status');
            statusEl.textContent = '';
            statusEl.className = 'status-message';
        }
        
        // ê´€ë¦¬ ìƒíƒœ ë©”ì‹œì§€ ì„¤ì • í•¨ìˆ˜
        function setManagementStatus(message, type = 'info') {
            const statusEl = document.getElementById('management-status');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `status-message status-${type}`;
            }
        }

        async function deleteAllDocuments() {
            if (!confirm('ëª¨ë“  ë¬¸ì„œë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
                return;
            }
            
            // ê¸°ì¡´ ë©”ì‹œì§€ í´ë¦¬ì–´
            clearManagementStatus();
            
            try {
                const response = await fetch('/api/documents', {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = 
                        `âœ… ëª¨ë“  ë¬¸ì„œ ì‚­ì œ ì™„ë£Œ (ë¬¸ì„œ: ${result.deleted_documents_count}ê°œ, íŒŒì¼: ${result.deleted_files_count}ê°œ)`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    
                    // ì„±ê³µ ë©”ì‹œì§€ë¥¼ 5ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 5000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âŒ ì‚­ì œ ì‹¤íŒ¨: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        // ì¤‘ë³µ ë¬¸ì„œ ì •ë¦¬ í•¨ìˆ˜
        async function cleanupDuplicateDocuments() {
            try {
                clearManagementStatus();
                
                // í˜„ì¬ ë¬¸ì„œ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                const response = await fetch('/api/documents');
                const data = await response.json();
                const documents = data.documents || data; // data.documents ë˜ëŠ” data ì§ì ‘ ì‚¬ìš©
                
                if (!Array.isArray(documents) || documents.length === 0) {
                    setManagementStatus('ğŸ“„ ì •ë¦¬í•  ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤.', 'info');
                    return;
                }
                
                // ë§¤ìš° ë³´ìˆ˜ì ì¸ ì¤‘ë³µ ì°¾ê¸° (ì •í™•íˆ ê°™ì€ íŒŒì¼ë§Œ)
                const duplicateGroups = {};
                documents.forEach(doc => {
                    // ë§¤ìš° ì—„ê²©í•œ ì¤‘ë³µ ê¸°ì¤€: ê±°ì˜ ë™ì¼í•œ ì´ë¦„ë§Œ ì¤‘ë³µìœ¼ë¡œ ì²˜ë¦¬
                    let normalizedName = doc.document_id
                        .replace(/\s*\(\d+\)$/i, '')                       // ë³µì‚¬ë³¸ ë²ˆí˜¸ë§Œ ì œê±° (1), (2) ë“±
                        .replace(/\s*-\s*copy$/i, '')                      // " - copy" ì œê±°
                        .replace(/\s*_copy$/i, '')                         // "_copy" ì œê±°  
                        .replace(/\s*-\s*ë³µì‚¬ë³¸$/i, '')                      // " - ë³µì‚¬ë³¸" ì œê±°
                        .replace(/\s*_ë³µì‚¬ë³¸$/i, '')                        // "_ë³µì‚¬ë³¸" ì œê±°
                        .toLowerCase()
                        .trim();
                    
                    // ë§¤ìš° ë³´ìˆ˜ì : íŒŒì¼ëª…ì´ ê±°ì˜ ë™ì¼í•œ ê²½ìš°ë§Œ ì¤‘ë³µìœ¼ë¡œ ê°„ì£¼
                    console.log(`ğŸ” ë³´ìˆ˜ì  íŒŒì¼ëª… ì •ê·œí™”: "${doc.document_id}" â†’ "${normalizedName}"`);
                    
                    if (!duplicateGroups[normalizedName]) {
                        duplicateGroups[normalizedName] = [];
                    }
                    duplicateGroups[normalizedName].push(doc);
                });
                
                // ì¤‘ë³µëœ ê·¸ë£¹ë§Œ í•„í„°ë§ (2ê°œ ì´ìƒ)
                const duplicates = Object.values(duplicateGroups).filter(group => group.length > 1);
                
                if (duplicates.length === 0) {
                    setManagementStatus('âœ… ì¤‘ë³µ íŒŒì¼ì´ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.', 'success');
                    return;
                }
                
                // ì¤‘ë³µ íŒŒì¼ ì •ë¦¬ í™•ì¸
                const duplicateCount = duplicates.reduce((sum, group) => sum + (group.length - 1), 0);
                if (!confirm(`${duplicates.length}ê°œ ê·¸ë£¹ì—ì„œ ì´ ${duplicateCount}ê°œì˜ ì¤‘ë³µ íŒŒì¼ì„ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.\n\nê° ê·¸ë£¹ì—ì„œ ê°€ì¥ ìµœê·¼ íŒŒì¼ì„ ì œì™¸í•˜ê³  ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                    return;
                }
                
                setManagementStatus('ğŸ” ì¤‘ë³µ íŒŒì¼ ì •ë¦¬ ì¤‘...', 'info');
                
                let deletedCount = 0;
                let errorCount = 0;
                
                // ê° ì¤‘ë³µ ê·¸ë£¹ ì²˜ë¦¬
                for (const group of duplicates) {
                    console.log(`ğŸ” ì¤‘ë³µ ê·¸ë£¹ ì²˜ë¦¬:`, group.map(doc => ({
                        id: doc.document_id,
                        chunks: doc.chunk_count,
                        created: doc.created_at,
                        hasCreatedAt: !!doc.created_at
                    })));
                    
                    // ì•ˆì „ì¥ì¹˜: ê·¸ë£¹ì— ìµœì†Œ 2ê°œ ì´ìƒì˜ íŒŒì¼ì´ ìˆì–´ì•¼ ì¤‘ë³µìœ¼ë¡œ ê°„ì£¼
                    if (group.length < 2) {
                        console.warn(`âš ï¸ ê·¸ë£¹ì— íŒŒì¼ì´ ${group.length}ê°œë§Œ ìˆìŒ, ê±´ë„ˆëœ€`);
                        continue;
                    }
                    
                    // ì •ë ¬ ê¸°ì¤€: 
                    // 1. ì²­í¬ ìˆ˜ê°€ ë§ì€ ìˆœ (ë” ì™„ì „í•œ ë¬¸ì„œ)
                    // 2. created_atì´ ìˆìœ¼ë©´ ìµœì‹  ìˆœ
                    // 3. document_id ì•ŒíŒŒë²³ ìˆœ (fallback)
                    group.sort((a, b) => {
                        // 1ìˆœìœ„: ì²­í¬ ìˆ˜ (ë§ì€ ê²ƒì´ ë” ì™„ì „í•œ ë¬¸ì„œ)
                        const chunkDiff = (b.chunk_count || 0) - (a.chunk_count || 0);
                        if (chunkDiff !== 0) return chunkDiff;
                        
                        // 2ìˆœìœ„: created_at (ìµœì‹  ê²ƒ)
                        if (a.created_at && b.created_at) {
                            return new Date(b.created_at) - new Date(a.created_at);
                        }
                        
                        // 3ìˆœìœ„: document_id (ì•ŒíŒŒë²³ ìˆœ)
                        return a.document_id.localeCompare(b.document_id);
                    });
                    
                    const keepFile = group[0]; // ìœ ì§€í•  íŒŒì¼
                    const deleteFiles = group.slice(1); // ì‚­ì œí•  íŒŒì¼ë“¤
                    
                    console.log(`âœ… ìœ ì§€í•  íŒŒì¼:`, {
                        id: keepFile.document_id,
                        chunks: keepFile.chunk_count,
                        created: keepFile.created_at
                    });
                    console.log(`ğŸ—‘ï¸ ì‚­ì œí•  íŒŒì¼ë“¤:`, deleteFiles.map(f => ({
                        id: f.document_id,
                        chunks: f.chunk_count,
                        created: f.created_at
                    })));
                    
                    // ì‚­ì œ ì‹¤í–‰ (ì²« ë²ˆì§¸ íŒŒì¼ ì œì™¸)
                    for (const fileToDelete of deleteFiles) {
                        try {
                            console.log(`ğŸ—‘ï¸ ì‚­ì œ ì¤‘: ${fileToDelete.document_id}`);
                            const deleteResponse = await fetch(`/api/documents/${fileToDelete.document_id}`, {
                                method: 'DELETE'
                            });
                            
                            if (deleteResponse.ok) {
                                deletedCount++;
                                console.log(`âœ… ì‚­ì œ ì„±ê³µ: ${fileToDelete.document_id}`);
                            } else {
                                errorCount++;
                                console.error(`âŒ ì‚­ì œ ì‹¤íŒ¨: ${fileToDelete.document_id}`, deleteResponse.status);
                            }
                        } catch (error) {
                            errorCount++;
                            console.error(`âŒ ì‚­ì œ ì˜¤ë¥˜: ${fileToDelete.document_id}`, error);
                        }
                    }
                }
                
                // ê²°ê³¼ ë©”ì‹œì§€ í‘œì‹œ
                if (deletedCount > 0) {
                    setManagementStatus(
                        `âœ… ì¤‘ë³µ íŒŒì¼ ì •ë¦¬ ì™„ë£Œ: ${deletedCount}ê°œ ì‚­ì œ${errorCount > 0 ? `, ${errorCount}ê°œ ì‹¤íŒ¨` : ''}`, 
                        errorCount > 0 ? 'warning' : 'success'
                    );
                    
                    // ë¬¸ì„œ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    setTimeout(() => {
                        fetchDocumentList();
                    }, 1000);
                } else {
                    setManagementStatus('âŒ ì¤‘ë³µ íŒŒì¼ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                }
                
            } catch (error) {
                console.error('ì¤‘ë³µ íŒŒì¼ ì •ë¦¬ ì˜¤ë¥˜:', error);
                setManagementStatus(`âŒ ì¤‘ë³µ íŒŒì¼ ì •ë¦¬ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }
        
        // ë¬¸ì„œ ì´ë¦„ìˆœ ì •ë ¬ í•¨ìˆ˜
        async function sortDocumentsByName() {
            try {
                clearManagementStatus();
                setManagementStatus('ğŸ“ ë¬¸ì„œ ëª©ë¡ì„ ì´ë¦„ìˆœìœ¼ë¡œ ì •ë ¬ ì¤‘...', 'info');
                
                // í˜„ì¬ ì •ë ¬ ìƒíƒœ ê´€ë¦¬ (ì²« ë²ˆì§¸ ì‹¤í–‰ì€ í•­ìƒ ì˜¤ë¦„ì°¨ìˆœ)
                if (window.documentSortAscending === undefined) {
                    window.documentSortAscending = true; // ì²« ë²ˆì§¸ ì‹¤í–‰ì€ ì˜¤ë¦„ì°¨ìˆœ
                } else {
                    window.documentSortAscending = !window.documentSortAscending; // í† ê¸€
                }
                
                const sortOrder = window.documentSortAscending ? 'ì˜¤ë¦„ì°¨ìˆœ' : 'ë‚´ë¦¼ì°¨ìˆœ';
                
                // ë¬¸ì„œ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                const response = await fetch('/api/documents');
                const data = await response.json();
                const documents = data.documents || data; // data.documents ë˜ëŠ” data ì§ì ‘ ì‚¬ìš©
                
                if (!Array.isArray(documents) || documents.length === 0) {
                    setManagementStatus('ğŸ“„ ì •ë ¬í•  ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤.', 'info');
                    return;
                }
                
                // í•œê¸€ëª… + ìˆ«ì ì •ë ¬ (ìì—°ìŠ¤ëŸ¬ìš´ ì •ë ¬)
                documents.sort((a, b) => {
                    const nameA = a.document_id;
                    const nameB = b.document_id;
                    
                    // í•œê¸€ëª…ê³¼ ìˆ«ìë¥¼ ë¶„ë¦¬í•˜ì—¬ ì •ë ¬í•˜ëŠ” í•¨ìˆ˜
                    const naturalSort = (str1, str2) => {
                        // ì •ê·œí‘œí˜„ì‹ìœ¼ë¡œ í…ìŠ¤íŠ¸ì™€ ìˆ«ì ë¶„ë¦¬
                        const chunks1 = str1.match(/(\d+|\D+)/g) || [];
                        const chunks2 = str2.match(/(\d+|\D+)/g) || [];
                        
                        const maxLength = Math.max(chunks1.length, chunks2.length);
                        
                        for (let i = 0; i < maxLength; i++) {
                            const chunk1 = chunks1[i] || '';
                            const chunk2 = chunks2[i] || '';
                            
                            // ë‘˜ ë‹¤ ìˆ«ìì¸ ê²½ìš° ìˆ«ìë¡œ ë¹„êµ
                            const num1 = parseInt(chunk1);
                            const num2 = parseInt(chunk2);
                            
                            if (!isNaN(num1) && !isNaN(num2)) {
                                if (num1 !== num2) {
                                    return num1 - num2;
                                }
                            } else {
                                // í…ìŠ¤íŠ¸ ë¹„êµ (í•œê¸€ í¬í•¨)
                                const textCompare = chunk1.localeCompare(chunk2, 'ko', { 
                                    numeric: true, 
                                    sensitivity: 'base',
                                    ignorePunctuation: true 
                                });
                                if (textCompare !== 0) {
                                    return textCompare;
                                }
                            }
                        }
                        return 0;
                    };
                    
                    const result = naturalSort(nameA, nameB);
                    return window.documentSortAscending ? result : -result;
                });
                
                // ì •ë ¬ëœ ìˆœì„œë¥¼ ì €ì¥ (localStorageì— ì €ì¥í•˜ì—¬ ì§€ì†ì„± í™•ë³´)
                const sortedOrder = documents.map(doc => doc.document_id);
                localStorage.setItem('documentSortOrder', JSON.stringify(sortedOrder));
                localStorage.setItem('documentSortAscending', window.documentSortAscending);
                
                // ì •ë ¬ëœ ëª©ë¡ìœ¼ë¡œ UI ì—…ë°ì´íŠ¸
                displayDocumentList(documents);
                
                setManagementStatus(`âœ… ë¬¸ì„œ ëª©ë¡ì´ ì´ë¦„ìˆœ ${sortOrder}ìœ¼ë¡œ ì •ë ¬ë˜ì—ˆìŠµë‹ˆë‹¤. (${documents.length}ê°œ ë¬¸ì„œ)`, 'success');
                
                // ì„±ê³µ ë©”ì‹œì§€ë¥¼ 3ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
                setTimeout(() => {
                    clearManagementStatus();
                }, 3000);
                
            } catch (error) {
                console.error('ë¬¸ì„œ ì •ë ¬ ì˜¤ë¥˜:', error);
                setManagementStatus(`âŒ ë¬¸ì„œ ì •ë ¬ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }
        
        // ë¬¸ì„œ ëª©ë¡ í‘œì‹œ í•¨ìˆ˜ (ì •ë ¬ëœ ëª©ë¡ìš©)
        function displayDocumentList(documents) {
            const documentList = document.getElementById('document-list');
            const individualDocCheckboxes = document.getElementById('individual-doc-checkboxes');
            const info = document.getElementById('document-info');
            
            if (!documentList || !individualDocCheckboxes) {
                console.error('Required DOM elements not found');
                return;
            }
            
            // ê¸°ì¡´ ëª©ë¡ í´ë¦¬ì–´
            documentList.innerHTML = '';
            individualDocCheckboxes.innerHTML = '';
            
            if (documents && documents.length > 0) {
                documents.forEach(doc => {
                    // ì±„íŒ…ìš© ì²´í¬ë°•ìŠ¤ ìƒì„±
                    const div = document.createElement('div');
                    div.style.cssText = 'margin-bottom: 6px; display: flex; align-items: center; gap: 8px; padding: 4px 8px; border-radius: 4px; transition: background-color 0.2s;';
                    div.innerHTML = `
                        <input type="checkbox" id="doc-checkbox-${doc.document_id}" value="${doc.document_id}" data-preview="${doc.first_chunk_preview || ''}" style="margin: 0; transform: scale(0.9);">
                        <label for="doc-checkbox-${doc.document_id}" style="font-size: 0.85em; color: #495057; cursor: pointer; flex: 1; margin: 0;">
                            ğŸ“„ ${doc.document_id} <span style="color: #6c757d;">(${doc.chunk_count}ì²­í¬)</span>
                        </label>
                    `;
                    
                    // í˜¸ë²„ íš¨ê³¼
                    div.addEventListener('mouseenter', () => {
                        div.style.backgroundColor = '#f8f9fa';
                    });
                    div.addEventListener('mouseleave', () => {
                        div.style.backgroundColor = 'transparent';
                    });
                    
                    individualDocCheckboxes.appendChild(div);
                    
                    // ë¬¸ì„œ ê´€ë¦¬ ëª©ë¡
                    const docDiv = document.createElement('div');
                    docDiv.className = 'document-item';
                    
                    // ë¬¸ì„œ ìœ í˜• ë¶„ì„
                    const fileName = doc.document_id;
                    let docType = 'ê¸°ìˆ ë¬¸ì„œ';
                    let docCategory = '';
                    
                    if (fileName.includes('ì£¼ë¬¼ê¸°ìˆ ì´ì„œ')) {
                        docType = 'ì£¼ë¬¼ê¸°ìˆ ì´ì„œ';
                        if (fileName.includes('Vol.')) {
                            const volMatch = fileName.match(/Vol\.\s*(\d+)/);
                            if (volMatch) {
                                docCategory = `ì œ${volMatch[1]}ê¶Œ`;
                            }
                        }
                    } else if (fileName.includes('ì£¼ë¬¼')) {
                        docType = 'ì£¼ë¬¼ê¸°ìˆ ';
                    } else if (fileName.includes('ê¸°ìˆ ')) {
                        docType = 'ê¸°ìˆ ë¬¸ì„œ';
                    }
                    
                    // ì£¼ì œ ì¶”ì¶œ
                    let topic = '';
                    if (fileName.includes('ê²°í•¨')) topic = 'ê²°í•¨ë¶„ì„';
                    else if (fileName.includes('íƒ•êµ¬')) topic = 'íƒ•êµ¬ì„¤ê³„';
                    else if (fileName.includes('ì£¼ì¡°')) topic = 'ì£¼ì¡°ê³µì •';
                    else if (fileName.includes('ì‹œí—˜')) topic = 'ì‹œí—˜ë²•';
                    else if (fileName.includes('ë¶„ì„')) topic = 'ë¶„ì„ë²•';
                    else if (fileName.includes('ì£¼í˜•')) topic = 'ì£¼í˜•ê¸°ìˆ ';
                    else if (fileName.includes('ì›ê°€')) topic = 'ì›ê°€ê´€ë¦¬';
                    else if (fileName.includes('ê°•ë„')) topic = 'ê°•ë„ì¸¡ì •';
                    
                    // ì²­í¬ ìˆ˜ ê¸°ë°˜ ë¬¸ì„œ í¬ê¸°
                    let sizeInfo = '';
                    if (doc.chunk_count > 100) sizeInfo = 'ëŒ€ìš©ëŸ‰';
                    else if (doc.chunk_count > 50) sizeInfo = 'ì¤‘ìš©ëŸ‰';
                    else if (doc.chunk_count > 20) sizeInfo = 'ì†Œìš©ëŸ‰';
                    else sizeInfo = 'ë‹¨í¸';
                    
                    docDiv.innerHTML = `
                        <div class="document-info">
                            <div class="document-title">ğŸ“„ ${doc.document_id}</div>
                            <div class="text-muted" style="display: flex; gap: 10px; flex-wrap: wrap; margin: 5px 0;">
                                <span style="background: #e3f2fd; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${docType}</span>
                                ${docCategory ? `<span style="background: #f3e5f5; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${docCategory}</span>` : ''}
                                ${topic ? `<span style="background: #e8f5e8; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${topic}</span>` : ''}
                                <span style="background: #fff3e0; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${sizeInfo} ${doc.chunk_count}ì²­í¬</span>
                            </div>
                            ${doc.first_chunk_preview ? `<div class="document-preview" style="font-size: 0.8em; color: #666; margin-top: 5px; line-height: 1.3;">${doc.first_chunk_preview.slice(0, 120)}...</div>` : ''}
                        </div>
                        <div class="document-actions">
                            <button onclick="deleteDocument('${doc.document_id}')" class="btn btn-danger" style="padding: 6px 12px; font-size: 0.9rem;">
                                ğŸ—‘ï¸ ì‚­ì œ
                            </button>
                        </div>
                    `;
                    documentList.appendChild(docDiv);
                });
                
                // ì²« ë¬¸ì„œ ì •ë³´ í‘œì‹œ
                if (info) {
                    info.textContent = documents[0].first_chunk_preview ? 
                        `ë¯¸ë¦¬ë³´ê¸°: ${documents[0].first_chunk_preview.slice(0, 60)}...` : '';
                }
                
                // í´ë§ìš© ë¬¸ì„œ ê°œìˆ˜ ì—…ë°ì´íŠ¸
                lastDocumentCount = documents.length;
            } else {
                if (info) info.textContent = '';
                documentList.innerHTML = '<div class="text-center text-muted">ğŸ“­ ì €ì¥ëœ ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                lastDocumentCount = 0;
            }
            
            // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¬ë“±ë¡
            const selectAllCheckbox = document.getElementById('select-all-docs');
            if (selectAllCheckbox) {
                // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì œê±°í•˜ê³  ìƒˆë¡œ ë“±ë¡
                selectAllCheckbox.removeEventListener('change', handleSelectAllChange);
                selectAllCheckbox.addEventListener('change', handleSelectAllChange);
            }
            
            individualDocCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.addEventListener('change', updateChatPreview);
            });
        }
        
        // ì „ì²´ ì„ íƒ ì²´í¬ë°•ìŠ¤ í•¸ë“¤ëŸ¬ (ë¶„ë¦¬)
        function handleSelectAllChange() {
            const selectAllCheckbox = document.getElementById('select-all-docs');
            const individualDocCheckboxes = document.getElementById('individual-doc-checkboxes');
            
            if (selectAllCheckbox && individualDocCheckboxes) {
                const checked = selectAllCheckbox.checked;
                const boxes = individualDocCheckboxes.querySelectorAll('input[type="checkbox"]');
                boxes.forEach(cb => { 
                    cb.disabled = checked; 
                    if (checked) cb.checked = false; 
                });
                updateChatPreview();
            }
        }
        
        // ë°±ê·¸ë¼ìš´ë“œ í™˜ì˜ë©”ì‹œì§€ ìƒì„± í•¨ìˆ˜ (ìë™ ì‹¤í–‰ìš©)
        async function generateWelcomeMessagesBackground() {
            try {
                const response = await fetch('/api/welcome-messages/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ count: 5 })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    console.log(`âœ… ë°±ê·¸ë¼ìš´ë“œ í™˜ì˜ë©”ì‹œì§€ ìƒì„± ì™„ë£Œ: ${data.generated_count}ê°œ ìƒì„±`);
                } else {
                    console.error('ë°±ê·¸ë¼ìš´ë“œ í™˜ì˜ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨:', data.detail);
                }
                
            } catch (error) {
                console.error('ë°±ê·¸ë¼ìš´ë“œ í™˜ì˜ë©”ì‹œì§€ ìƒì„± ì˜¤ë¥˜:', error);
            }
        }
        
        // ì£¼ê¸°ì  í™˜ì˜ë©”ì‹œì§€ ìƒì„± (1ì‹œê°„ë§ˆë‹¤)
        function startWelcomeMessageAutoGeneration() {
            // í˜ì´ì§€ ë¡œë“œ í›„ 5ë¶„ ë’¤ì— ì²« ë²ˆì§¸ ìƒì„±
            setTimeout(async () => {
                console.log('ğŸ¯ ìë™ í™˜ì˜ë©”ì‹œì§€ ìƒì„± ì‹œì‘...');
                try {
                    await generateWelcomeMessagesBackground();
                } catch (error) {
                    console.error('ìë™ í™˜ì˜ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨:', error);
                }
            }, 5 * 60 * 1000); // 5ë¶„
            
            // ê·¸ ì´í›„ 1ì‹œê°„ë§ˆë‹¤ ìƒì„±
            setInterval(async () => {
                console.log('ğŸ”„ ì£¼ê¸°ì  í™˜ì˜ë©”ì‹œì§€ ìƒì„±...');
                try {
                    await generateWelcomeMessagesBackground();
                } catch (error) {
                    console.error('ì£¼ê¸°ì  í™˜ì˜ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨:', error);
                }
            }, 60 * 60 * 1000); // 1ì‹œê°„
            
            console.log('âœ… í™˜ì˜ë©”ì‹œì§€ ìë™ ìƒì„± ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘ë¨ (ì²« ì‹¤í–‰: 5ë¶„ í›„, ì´í›„: 1ì‹œê°„ë§ˆë‹¤)');
        }
        
        async function showStorageStats() {
            try {
                const response = await fetch('/api/storage/stats');
                const result = await response.json();
                
                if (response.ok) {
                    const stats = `ğŸ“Š ì €ì¥ì†Œ í†µê³„:\n` +
                        `íŒŒì¼: ${result.file_storage.total_files}ê°œ (${result.file_storage.total_size_mb}MB)\n` +
                        `ë¬¸ì„œ: ${result.vector_db.total_documents}ê°œ\n` +
                        `ì²­í¬: ${result.vector_db.total_chunks}ê°œ`;
                    alert(stats);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âŒ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        async function cleanupOrphanedFiles() {
            if (!confirm('ê³ ì•„ íŒŒì¼ë“¤ì„ ì •ë¦¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }
            
            // ê¸°ì¡´ ë©”ì‹œì§€ í´ë¦¬ì–´
            clearManagementStatus();
            
            try {
                const response = await fetch('/api/documents/cleanup', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = 
                        `âœ… ì •ë¦¬ ì™„ë£Œ: ${result.cleaned_files_count}ê°œ íŒŒì¼ ì •ë¦¬ë¨`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    
                    // ì„±ê³µ ë©”ì‹œì§€ë¥¼ 4ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 4000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âŒ ì •ë¦¬ ì‹¤íŒ¨: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        // ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨ ê°„ê²© (30ì´ˆ)
        let documentListInterval = null;
        let lastDocumentCount = 0;
        
        function startDocumentListPolling() {
            // ê¸°ì¡´ ì¸í„°ë²Œ ì •ë¦¬
            if (documentListInterval) {
                clearInterval(documentListInterval);
            }
            
            // 30ì´ˆë§ˆë‹¤ ë¬¸ì„œ ëª©ë¡ í™•ì¸
            documentListInterval = setInterval(async () => {
                try {
                    const res = await fetch('/api/documents');
                    const data = await res.json();
                    const currentDocumentCount = data.documents ? data.documents.length : 0;
                    
                    // ë¬¸ì„œ ê°œìˆ˜ê°€ ë³€ê²½ë˜ì—ˆìœ¼ë©´ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    if (currentDocumentCount !== lastDocumentCount) {
                        console.log(`ë¬¸ì„œ ê°œìˆ˜ ë³€ê²½ ê°ì§€: ${lastDocumentCount} â†’ ${currentDocumentCount}`);
                        fetchDocumentList();
                        lastDocumentCount = currentDocumentCount;
                        
                        // ìë™ ìƒˆë¡œê³ ì¹¨ í‘œì‹œê¸° ì—…ë°ì´íŠ¸
                        updateAutoRefreshIndicator('ë³€ê²½ ê°ì§€ë¨');
                    }
                } catch (error) {
                    console.log('ë¬¸ì„œ ëª©ë¡ í´ë§ ì˜¤ë¥˜:', error);
                }
            }, 30000); // 30ì´ˆ ê°„ê²©
        }
        
        function stopDocumentListPolling() {
            if (documentListInterval) {
                clearInterval(documentListInterval);
                documentListInterval = null;
            }
        }
        
        function updateAutoRefreshIndicator(status) {
            const indicator = document.getElementById('auto-refresh-indicator');
            if (!indicator) return;
            
            const timestamp = new Date().toLocaleTimeString();
            
            switch(status) {
                case 'ë³€ê²½ ê°ì§€ë¨':
                    indicator.innerHTML = `ğŸ”„ ëª©ë¡ ì—…ë°ì´íŠ¸ë¨ (${timestamp})`;
                    indicator.style.color = '#28a745';
                    setTimeout(() => {
                        indicator.innerHTML = 'ğŸ”„ ìë™ ìƒˆë¡œê³ ì¹¨ í™œì„±í™”';
                        indicator.style.color = '#28a745';
                    }, 3000);
                    break;
                case 'í™œì„±í™”':
                    indicator.innerHTML = 'ğŸ”„ ìë™ ìƒˆë¡œê³ ì¹¨ í™œì„±í™”';
                    indicator.style.color = '#28a745';
                    break;
                case 'ë¹„í™œì„±í™”':
                    indicator.innerHTML = 'â¸ï¸ ìë™ ìƒˆë¡œê³ ì¹¨ ë¹„í™œì„±í™”';
                    indicator.style.color = '#6c757d';
                    break;
                default:
                    indicator.innerHTML = `ğŸ”„ ${status}`;
                    indicator.style.color = '#17a2b8';
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        document.addEventListener('DOMContentLoaded', async () => {
            // ì›°ì»´ ë©”ì‹œì§€ í‘œì‹œ (ë™ì  ë¡œë“œ)
            await showWelcomeMessage();
            
            fetchOllamaStatusAndModels();
            fetchDocumentList();
            updateSystemStats(); // ìƒˆë¡œ ì¶”ê°€: ì‹œìŠ¤í…œ í†µê³„ ì´ˆê¸°í™”
            setupQuickSettings(); // ìƒˆë¡œ ì¶”ê°€: ë¹ ë¥¸ ì„¤ì • í† ê¸€ ì´ˆê¸°í™”
            setupDocumentSelectionInteraction(); // ë¬¸ì„œ ì„ íƒ UI ìƒí˜¸ì‘ìš© ì„¤ì •
            
            // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœ ì´ˆê¸°í™”
            updateProcessingActivity('idle');
            
            // ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨ ì‹œì‘
            startDocumentListPolling();
            updateAutoRefreshIndicator('í™œì„±í™”');
            
            // ë¬¸ì„œ ê´€ë¦¬ ë²„íŠ¼ë“¤
            document.getElementById('refresh-documents').addEventListener('click', fetchDocumentList);
            document.getElementById('storage-stats').addEventListener('click', showStorageStats);
            document.getElementById('cleanup-duplicates').addEventListener('click', cleanupDuplicateDocuments);
            document.getElementById('sort-documents').addEventListener('click', sortDocumentsByName);
            document.getElementById('cleanup-files').addEventListener('click', cleanupOrphanedFiles);
            document.getElementById('delete-all-documents').addEventListener('click', deleteAllDocuments);
            
            // í™˜ì˜ë©”ì‹œì§€ ìë™ ìƒì„± ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘
            startWelcomeMessageAutoGeneration();
            
            // ì²˜ë¦¬ ì¤‘ë‹¨ ë²„íŠ¼
            document.getElementById('stop-processing').addEventListener('click', () => {
                if (confirm('í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ë¥¼ ì¤‘ë‹¨í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nâš ï¸ ì¤‘ë‹¨ëœ íŒŒì¼ë“¤ì€ ë‹¤ì‹œ ì—…ë¡œë“œí•´ì•¼ í•©ë‹ˆë‹¤.')) {
                    console.log('ì‚¬ìš©ì ìš”ì²­ìœ¼ë¡œ íŒŒì¼ ì²˜ë¦¬ ì¤‘ë‹¨');
                    
                    // ëª¨ë“  ì§„í–‰ë¥  ì¶”ì  ì¤‘ë‹¨
                    clearMultiFileTracking();
                    
                    // ì§„í–‰ë¥  UI ì—…ë°ì´íŠ¸
                    const progressContainer = document.getElementById('progress-container');
                    const uploadStatus = document.getElementById('upload-status');
                    
                    // ì¤‘ë‹¨ ë©”ì‹œì§€ í‘œì‹œ
                    if (uploadStatus) {
                        uploadStatus.textContent = 'â¹ ì‚¬ìš©ì ìš”ì²­ìœ¼ë¡œ ì²˜ë¦¬ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.';
                        uploadStatus.className = 'status-message status-warning';
                    }
                    
                    // ì „ì²´ ì§„í–‰ë¥  ì •ë¦¬
                    updateOverallProgress(0, 0, 'ì²˜ë¦¬ ì¤‘ë‹¨ë¨');
                    
                    // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ì»¨í…Œì´ë„ˆ ì •ë¦¬
                    const individualContainer = document.getElementById('individual-progress-container');
                    if (individualContainer) {
                        individualContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #dc3545;"><strong>â¹ ì²˜ë¦¬ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤</strong><br><small>ìƒˆë¡œìš´ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë ¤ë©´ í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê±°ë‚˜ ìƒˆ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.</small></div>';
                    }
                    
                    // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ idleë¡œ ë³€ê²½
                    updateProcessingActivity('idle');
                    
                    // 3ì´ˆ í›„ ì§„í–‰ë¥  ì°½ ìë™ ìˆ¨ê¹€
                    setTimeout(() => {
                        if (progressContainer) {
                            progressContainer.style.display = 'none';
                        }
                    }, 3000);
                }
            });
            
            // ì§„í–‰ë¥  ì°½ ë‹«ê¸° ë²„íŠ¼
            document.getElementById('hide-progress').addEventListener('click', () => {
                const progressContainer = document.getElementById('progress-container');
                const selectedFilesContainer = document.getElementById('selected-files-container');
                
                progressContainer.style.display = 'none';
                clearMultiFileTracking();
                
                // ì„ íƒëœ íŒŒì¼ ëª©ë¡ë„ ìˆ¨ê¸°ê³  ì´ˆê¸°í™”
                if (selectedFilesContainer) {
                    selectedFilesContainer.style.display = 'none';
                    document.getElementById('selected-files-list').innerHTML = '';
                    selectedFilesForUpload.clear();
                    
                    // íŒŒì¼ ì…ë ¥ ì´ˆê¸°í™”
                    const pdfFileInput = document.getElementById('pdf-file');
                    if (pdfFileInput) {
                        pdfFileInput.value = '';
                    }
                    
                    // ì—…ë¡œë“œ ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
                    updateSelectedCount();
                }
            });
            
            
            // ëª¨ë¸ ì„ íƒ ë³€ê²½ ì‹œ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
            const modelSelect = document.getElementById('ollama-models');
            modelSelect.addEventListener('change', updateSelectedModelDisplay);
        });

        // ì´ë¯¸ì§€ ëª¨ë‹¬ ê¸°ëŠ¥ ì„ì‹œ ë¹„í™œì„±í™”
        // Image modal functionality temporarily disabled
        
        // í‘œ í™•ì¥/ì¶•ì†Œ ê¸°ëŠ¥
        function toggleTableExpand(tableId) {
            const table = document.getElementById(tableId);
            const hiddenRows = table.querySelectorAll('.hidden-row');
            const expandIndicator = table.querySelector('.table-expand-indicator');
            const button = table.parentElement.querySelector('.btn-small');
            
            if (table.classList.contains('collapsed')) {
                // í™•ì¥
                hiddenRows.forEach(row => row.style.display = '');
                if (expandIndicator) expandIndicator.style.display = 'none';
                button.textContent = 'ì¶•ì†Œí•˜ê¸°';
                table.classList.remove('collapsed');
            } else {
                // ì¶•ì†Œ
                hiddenRows.forEach(row => row.style.display = 'none');
                if (expandIndicator) expandIndicator.style.display = '';
                button.textContent = 'ì „ì²´ ë³´ê¸°';
                table.classList.add('collapsed');
            }
        }
        
        // ESC í‚¤ ì´ë²¤íŠ¸ (ì´ë¯¸ì§€ ëª¨ë‹¬ ê¸°ëŠ¥ ë¹„í™œì„±í™”ë¨)
        // document.addEventListener('keydown', function(e) {
        //     if (e.key === 'Escape') {
        //         closeImageModal();
        //     }
        // });
        
        // ë§ˆí¬ë‹¤ìš´ ë Œë”ë§(ë‹µë³€ì— ì ìš©)
        // marked.js CDN ì¶”ê°€
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
        document.head.appendChild(script);
    </script>
</body>
</html>
