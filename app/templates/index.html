<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KITECH RAG Chatbot</title>
    <link rel="stylesheet" href="{{ url_for('static', path='/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🤖 KITECH RAG Chatbot</h1>

        <div class="ollama-section">
            <h2>📊 시스템 상태 대시보드</h2>
            
            <!-- 첫 번째 줄: LLM & 문서처리 상태 (균등 배치) -->
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; align-items: center; margin-bottom: 15px;">
                <!-- Ollama 상태 -->
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">🧠</span>
                    <div id="ollama-status" style="font-size: 0.9em;">Ollama 상태: 확인 중...</div>
                </div>
                
                <!-- 모델 선택 -->
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">⚙️</span>
                    <label for="ollama-models" style="margin: 0; white-space: nowrap; font-size: 0.9em;">모델:</label>
                    <select id="ollama-models" style="flex: 1; min-width: 0; font-size: 0.85em;">
                        <option value="">로딩 중...</option>
                    </select>
                </div>
                
                <!-- LLM 작동 상태 -->
                <div id="model-info-container" style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.1em;">💭</span>
                    <div id="model-activity" style="display: none; align-items: center; gap: 6px;">
                        <div id="activity-gauge" style="width: 18px; height: 18px; border-radius: 50%; background: conic-gradient(#28a745 0deg, #e9ecef 0deg); position: relative; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background: white; border-radius: 50%;"></div>
                        </div>
                        <span id="activity-text" style="font-size: 0.8em; color: #28a745; font-weight: 500;">대기중</span>
                    </div>
                    <div id="model-info" style="font-size: 0.8em; color: #495057; flex: 1; min-width: 0;">
                        모델 정보 로딩 중...
                    </div>
                </div>
                
                <!-- 문서 처리 상태 -->
                <div id="processing-status-container" style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">📄</span>
                    <div id="processing-activity" style="display: flex; align-items: center; gap: 6px;">
                        <div id="processing-gauge" style="width: 18px; height: 18px; border-radius: 50%; background: conic-gradient(#6c757d 0deg, #e9ecef 0deg); position: relative; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background: white; border-radius: 50%;"></div>
                        </div>
                        <span id="processing-text" style="font-size: 0.8em; color: #6c757d; font-weight: 500;">대기중</span>
                    </div>
                </div>
            </div>
            
            <!-- 두 번째 줄: 시스템 통계 & 빠른 설정 -->
            <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap; padding: 12px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                <!-- 시스템 통계 -->
                <div style="display: flex; gap: 20px; flex: 1; min-width: 300px;">
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="doc-count">0</div>
                        <div style="font-size: 0.8em; color: #6c757d;">문서</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="chunk-count">0</div>
                        <div style="font-size: 0.8em; color: #6c757d;">청크</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="storage-size">0MB</div>
                        <div style="font-size: 0.8em; color: #6c757d;">저장공간</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; font-weight: 500; color: #6c757d;" id="last-update">업데이트 없음</div>
                        <div style="font-size: 0.8em; color: #6c757d;">마지막 업데이트</div>
                    </div>
                </div>
                
                <!-- 빠른 설정 토글 -->
                <div style="display: flex; gap: 15px; align-items: center; border-left: 1px solid #dee2e6; padding-left: 20px;">
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="ocr-correction-toggle" checked style="margin: 0;">
                        <span>🔧 OCR 교정</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="llm-correction-toggle" checked style="margin: 0;">
                        <span>🤖 LLM 교정</span>
                        <span style="font-size: 0.7em; color: #28a745; margin-left: 5px;" title="경량 모델(qwen2.5:3b) 사용으로 빠른 처리">⚡ 경량</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="auto-refresh-toggle" checked style="margin: 0;">
                        <span>🔄 자동새로고침</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="external-access-toggle" checked style="margin: 0;">
                        <span>🌐 외부접속</span>
                        <span id="external-access-badge" style="font-size: 0.7em; color: #28a745; margin-left: 5px; background: rgba(40, 167, 69, 0.1); padding: 2px 6px; border-radius: 10px; border: 1px solid rgba(40, 167, 69, 0.3);" title="외부 API/웹 검색 허용됨">🟢 활성</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="upload-section">
            <h2>📁 문서 업로드 및 처리</h2>
            <form id="upload-form">
                <label for="pdf-file">📄 PDF 선택:</label>
                <input type="file" id="pdf-file" name="files" accept=".pdf" multiple required>
                
                <!-- 선택된 파일 목록 표시 -->
                <div id="selected-files-container" style="display:none; margin-top:15px;">
                    <h4 style="margin: 10px 0; color: #495057;">📋 선택된 파일 목록:</h4>
                    <div id="selected-files-list" style="max-height: 200px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 8px; padding: 10px; background: #f8f9fa;">
                        <!-- 선택된 파일들이 여기에 체크박스와 함께 표시됩니다 -->
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                        <button type="button" id="select-all-btn" style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 0.9em;">전체 선택</button>
                        <button type="button" id="deselect-all-btn" style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 0.9em;">전체 해제</button>
                        <span id="selected-count" style="font-size: 0.9em; color: #6c757d;">0개 파일 선택됨</span>
                    </div>
                </div>
                
                <button type="submit" id="upload-submit-btn">🚀 업로드 및 처리</button>
            </form>
            <div id="upload-status" class="status-message"></div>
            <div id="progress-container" style="display:none; margin-top:15px; border:1px solid #ddd; border-radius:8px; padding:15px; background:#f8f9fa;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4 style="margin: 0; color: #495057;">⏳ 파일 처리 진행 상황</h4>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button id="stop-processing" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.8em; cursor: pointer;" title="현재 처리 중단">⏹ 중단</button>
                        <button id="hide-progress" style="background: none; border: none; font-size: 1.2em; cursor: pointer; color: #6c757d;" title="진행률 창 숨기기">✕</button>
                    </div>
                </div>
                
                <!-- 전체 진행률 -->
                <div id="overall-progress" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span id="overall-progress-text">전체 진행률</span>
                        <span id="overall-progress-count">0/0 완료</span>
                    </div>
                    <div id="overall-progress-bar-container" style="height:8px; background:#e0e0e0; border-radius:4px; overflow:hidden; display: none;">
                        <div id="overall-progress-bar" style="height:100%; width:0%; background:#28a745; transition:width 0.3s;"></div>
                    </div>
                </div>
                
                <!-- 개별 파일 진행률 컨테이너 -->
                <div id="individual-progress-container">
                    <!-- 개별 파일 진행률이 여기에 동적으로 추가됩니다 -->
                </div>
                
                <!-- 완료 후 자동 숨김 설정 -->
                <div style="margin-top: 10px; font-size: 0.9em; color: #6c757d; text-align: center;">
                    <label>
                        <input type="checkbox" id="auto-hide-progress" checked style="margin-right: 5px;">
                        모든 파일 처리 완료 시 자동으로 숨기기 (10초 후)
                    </label>
                </div>
            </div>
        </div>

        <div class="document-management-section">
            <h2>📚 문서 관리 
                <span id="auto-refresh-indicator" style="font-size: 0.8em; color: #28a745; margin-left: 10px;">
                    🔄 자동 새로고침 활성화
                </span>
            </h2>
            <div style="margin-bottom:15px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                <button id="refresh-documents" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">🔄 문서새로고침</button>
                <button id="storage-stats" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">📊 문서통계</button>
                <button id="cleanup-duplicates" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">🔍 중복정리</button>
                <button id="sort-documents" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">📝 문서정렬</button>
                <button id="cleanup-files" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap;">🧹 파일정리</button>
                <button id="delete-all-documents" style="padding: 6px 10px; font-size: 0.85em; border-radius: 6px; white-space: nowrap; background:#dc3545; color:white;">🗑️ 전체삭제</button>
            </div>
            
            <div id="document-list" style="max-height:200px; overflow-y:auto; border:1px solid #ddd; padding:10px; margin-bottom:15px;">
                <!-- 문서 목록이 여기에 표시됩니다 -->
            </div>
            
            <div id="management-status" class="status-message"></div>
        </div>

        <div class="chat-section">
            <h2>💬 챗봇에게 물어보기</h2>
            <!-- 문서 선택 영역 -->
            <div style="background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                    <span style="font-size: 1.1em;">📋</span>
                    <label style="font-weight: 600; color: #495057; margin: 0;">문서 선택</label>
                    <span id="document-info" style="font-size: 0.85em; color: #6c757d; margin-left: auto;"></span>
                </div>
                
                <!-- 전체 문서 선택 -->
                <div style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 10px; margin: 0; cursor: pointer;">
                        <input type="checkbox" id="select-all-docs" checked style="margin: 0; transform: scale(1.1);">
                        <span style="font-weight: 600; color: #495057;">📑 전체 문서</span>
                        <span style="font-size: 0.8em; color: #6c757d; margin-left: auto;">모든 저장된 문서 사용</span>
                    </label>
                </div>
                
                <!-- 특정 문서 선택 섹션 -->
                <div id="specific-doc-section" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 12px; margin-bottom: 10px; display: none;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <input type="checkbox" id="select-specific-docs" style="margin: 0; transform: scale(1.1);">
                        <span style="font-weight: 600; color: #495057;">📄 특정 문서 선택</span>
                        <span style="font-size: 0.8em; color: #6c757d; margin-left: auto;">원하는 문서만 선택</span>
                    </div>
                    
                    <!-- 개별 문서 리스트 -->
                    <div id="individual-doc-container" style="display: none; margin-left: 24px; padding-top: 8px; border-top: 1px solid #e9ecef;">
                        <div style="font-size: 0.9em; color: #6c757d; margin-bottom: 8px;">
                            🎯 문서를 선택하세요:
                        </div>
                        <div id="individual-doc-checkboxes" style="max-height: 140px; overflow-y: auto; padding-right: 4px;">
                            <!-- 개별 문서 체크박스 리스트가 동적으로 생성됩니다 -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Compact Horizontal Chat Progress Indicator -->
            <div id="chat-progress" class="chat-progress">
                <div class="progress-header">
                    <div class="progress-title">
                        <span class="progress-icon">🤖</span>
                        <span id="progress-main-text">AI 답변 생성 중...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-time" id="progress-timer">0초</span>
                    </div>
                </div>
                
                <div class="progress-bar-container">
                    <div class="progress-bar" id="overall-progress-bar"></div>
                </div>
                
                <div class="chat-progress-steps">
                    <div class="progress-step" data-step="query">
                        <div class="progress-step-icon" data-step="1"></div>
                        <span class="step-title">질문분석</span>
                        <div class="step-status" id="query-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="embedding">
                        <div class="progress-step-icon" data-step="2"></div>
                        <span class="step-title">임베딩</span>
                        <div class="step-status" id="embedding-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="search">
                        <div class="progress-step-icon" data-step="3"></div>
                        <span class="step-title">문서검색</span>
                        <div class="step-status" id="search-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="generate">
                        <div class="progress-step-icon" data-step="4"></div>
                        <span class="step-title">답변생성</span>
                        <div class="step-status" id="generate-status">
                            <div class="response-length" id="response-length" style="display: none;">0자</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="chat-history">
                <!-- 채팅 메시지가 여기에 표시됩니다 -->
            </div>
            <div class="chat-input-container">
                <button id="new-chat-button" class="btn btn-success" title="새 대화 시작하기" style="background:#28a745; margin-right: 10px;">🔄 새 대화</button>
                <input type="text" id="chat-input" placeholder="💭 질문을 입력하세요...">
                <button id="send-button" class="btn btn-primary">💬 전송</button>
            </div>
            <div id="chat-status" class="status-message"></div>
        </div>
    </div>

    <script>
        const uploadForm = document.getElementById('upload-form');
        const pdfFile = document.getElementById('pdf-file');
        const uploadStatus = document.getElementById('upload-status');

        const chatHistory = document.getElementById('chat-history');
        const chatMessages = document.getElementById('chat-history'); // Same as chatHistory for message container
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const chatStatus = document.getElementById('chat-status');

        // Streaming control
        let currentStreamAbortController = null;
        let isStreaming = false;
        
        // Conversation history management
        let conversationHistory = [];
        const MAX_HISTORY_LENGTH = 10; // 최근 10개 대화만 유지
        
        // Make functions global for debugging
        window.debugStopStreaming = function() {
            console.log('Manual stop streaming called');
            console.log('isStreaming:', isStreaming);
            console.log('currentStreamAbortController:', currentStreamAbortController);
            stopStreaming();
        };

        // Debug conversation history
        window.debugConversationHistory = function() {
            console.log('Current conversation history:', conversationHistory);
            console.log('Total messages:', conversationHistory.length);
            conversationHistory.forEach((msg, index) => {
                console.log(`${index + 1}. ${msg.role}: ${msg.content.substring(0, 100)}...`);
            });
        };

        // 파일 업로드 진행률 관리
        function initializeUploadProgress(selectedFiles) {
            const progressContainer = document.getElementById('progress-container');
            const uploadStatus = document.getElementById('upload-status');
            
            // 진행률 컨테이너 표시
            progressContainer.style.display = 'block';
            
            // 전체 진행률 초기화
            updateOverallProgress(0, selectedFiles.length, '업로드 준비 중...');
            
            // 개별 파일 진행률 초기화
            initializeFileProgressBars(selectedFiles);
            
            // 상태 메시지 업데이트
            uploadStatus.textContent = `${selectedFiles.length}개 파일 업로드 시작...`;
            uploadStatus.className = 'status-message status-info';
        }

        function initializeFileProgressBars(files) {
            const progressList = document.getElementById('progress-list') || createProgressList();
            progressList.innerHTML = '';

            files.forEach((file, index) => {
                const progressItem = document.createElement('div');
                progressItem.className = 'file-progress-item';
                progressItem.id = `file-progress-${index}`;
                progressItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="file-icon">📄</span>
                            <div>
                                <div class="file-name" style="font-weight: 500; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${file.name}</div>
                                <div class="file-size" style="font-size: 0.8em; color: #666;">${(file.size / 1024 / 1024).toFixed(1)} MB</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="upload-percentage">0%</span>
                            <span class="upload-status-text">대기 중</span>
                        </div>
                    </div>
                    <div class="progress-bar-container" style="width: 100%; height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden;">
                        <div class="progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4CAF50, #45a049); transition: width 0.3s ease;"></div>
                    </div>
                `;
                progressList.appendChild(progressItem);
            });
        }

        function createProgressList() {
            const progressContainer = document.getElementById('progress-container');
            const progressList = document.createElement('div');
            progressList.id = 'progress-list';
            progressList.style.cssText = 'margin-top: 15px; max-height: 300px; overflow-y: auto;';
            
            // 제목 추가
            const title = document.createElement('h5');
            title.textContent = '📁 개별 파일 업로드 진행률';
            title.style.cssText = 'margin: 0 0 10px 0; color: #495057; font-size: 0.95em;';
            
            progressContainer.appendChild(title);
            progressContainer.appendChild(progressList);
            return progressList;
        }

        function updateFileProgress(fileIndex, percentage, status = '') {
            const progressItem = document.getElementById(`file-progress-${fileIndex}`);
            if (!progressItem) return;

            const progressBar = progressItem.querySelector('.progress-bar');
            const percentageSpan = progressItem.querySelector('.upload-percentage');
            const statusSpan = progressItem.querySelector('.upload-status-text');
            const fileIcon = progressItem.querySelector('.file-icon');

            if (progressBar) progressBar.style.width = `${percentage}%`;
            if (percentageSpan) percentageSpan.textContent = `${Math.round(percentage)}%`;
            if (statusSpan && status) statusSpan.textContent = status;

            // 상태에 따른 아이콘 변경
            if (fileIcon) {
                if (percentage === 100) {
                    fileIcon.textContent = '✅';
                    if (statusSpan) statusSpan.textContent = '완료';
                } else if (percentage > 0) {
                    fileIcon.textContent = '📤';
                } else {
                    fileIcon.textContent = '📄';
                }
            }

            // 프로그레스 바 색상 변경
            if (progressBar) {
                if (percentage === 100) {
                    progressBar.style.background = 'linear-gradient(90deg, #4CAF50, #45a049)';
                } else if (status.includes('오류')) {
                    progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                } else {
                    progressBar.style.background = 'linear-gradient(90deg, #2196F3, #1976D2)';
                }
            }
        }

        function updateOverallProgress(completed, total, message = '') {
            const progressText = document.getElementById('overall-progress-text');
            const progressCount = document.getElementById('overall-progress-count');
            const uploadStatus = document.getElementById('upload-status');

            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

            if (progressText) progressText.textContent = `전체 진행률 (${percentage}%)`;
            if (progressCount) progressCount.textContent = `${completed}/${total} 완료`;
            if (uploadStatus && message) {
                uploadStatus.textContent = message;
                uploadStatus.className = percentage === 100 ? 'status-message status-success' : 'status-message status-info';
            }
        }

        async function uploadWithProgress(formData, selectedFiles) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();

                // 업로드 진행률 추적
                xhr.upload.addEventListener('progress', (event) => {
                    if (event.lengthComputable) {
                        const percentComplete = (event.loaded / event.total) * 100;
                        
                        // 모든 파일에 동일한 진행률 적용 (실제로는 전체 FormData 진행률)
                        selectedFiles.forEach((file, index) => {
                            updateFileProgress(index, percentComplete, '업로드 중...');
                        });
                        
                        updateOverallProgress(0, selectedFiles.length, `업로드 중... ${Math.round(percentComplete)}%`);
                    }
                });

                // 업로드 완료
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            const result = JSON.parse(xhr.responseText);
                            
                            // 각 파일 완료 상태로 업데이트
                            selectedFiles.forEach((file, index) => {
                                updateFileProgress(index, 100, '업로드 완료');
                            });
                            
                            updateOverallProgress(selectedFiles.length, selectedFiles.length, '모든 파일 업로드 완료!');
                            
                            resolve({
                                success: true,
                                results: result.results || result
                            });
                        } catch (error) {
                            console.error('Response parsing error:', error);
                            reject(new Error('서버 응답 파싱 실패'));
                        }
                    } else {
                        reject(new Error(`업로드 실패: ${xhr.status} ${xhr.statusText}`));
                    }
                });

                // 오류 처리
                xhr.addEventListener('error', () => {
                    selectedFiles.forEach((file, index) => {
                        updateFileProgress(index, 0, '업로드 오류');
                    });
                    reject(new Error('네트워크 오류가 발생했습니다'));
                });

                // 요청 전송
                xhr.open('POST', '/api/upload_pdf/');
                xhr.send(formData);
            });
        }

        // 토스트 메시지 함수
        function showToastMessage(message, type = 'info') {
            // 기존 토스트 제거
            const existingToast = document.querySelector('.toast-message');
            if (existingToast) {
                existingToast.remove();
            }

            // 토스트 엘리먼트 생성
            const toast = document.createElement('div');
            toast.className = `toast-message toast-${type}`;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                max-width: 400px;
                padding: 16px;
                background: ${type === 'info' ? '#e3f2fd' : type === 'warning' ? '#fff3e0' : '#ffebee'};
                border: 1px solid ${type === 'info' ? '#2196f3' : type === 'warning' ? '#ff9800' : '#f44336'};
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-size: 14px;
                line-height: 1.4;
                color: #333;
                white-space: pre-line;
                transform: translateX(100%);
                transition: transform 0.3s ease;
            `;

            // 메시지 설정
            toast.textContent = message;

            // DOM에 추가
            document.body.appendChild(toast);

            // 애니메이션 효과
            setTimeout(() => {
                toast.style.transform = 'translateX(0)';
            }, 10);

            // 자동 제거 (5초 후)
            setTimeout(() => {
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 5000);

            // 클릭 시 제거
            toast.addEventListener('click', () => {
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            });
        }

        // THINK 블록 스타일링 함수 - 추론 모델의 사고 과정을 차별화해서 표시
        function styleThinkBlocks(text) {
            try {
                let processed = text;
                
                // 추론 블록 패턴들과 해당 스타일 처리
                const thinkPatterns = [
                    // <think> 태그 형태 - QwQ 모델 형식 (소문자)
                    {
                        pattern: /<think>([\s\S]*?)<\/think>/gim,
                        replacement: (match, content) => `
<div class="thinking-section" style="
    margin: 12px 0;
    padding: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #6c757d;
    border-radius: 8px;
    font-size: 0.85em;
    color: #495057;
    font-style: italic;
    opacity: 0.85;
">
    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-weight: 600; color: #6c757d;">
        🧠 <span>Thinking...</span>
    </div>
    <div style="white-space: pre-wrap; line-height: 1.4;">${content.trim()}</div>
</div>`
                    },
                    // <THINK> 태그 형태 - 대문자 버전 (호환성)
                    {
                        pattern: /<THINK>([\s\S]*?)<\/THINK>/gim,
                        replacement: (match, content) => `
<div class="thinking-section" style="
    margin: 12px 0;
    padding: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #6c757d;
    border-radius: 8px;
    font-size: 0.85em;
    color: #495057;
    font-style: italic;
    opacity: 0.85;
">
    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-weight: 600; color: #6c757d;">
        🧠 <span>Thinking...</span>
    </div>
    <div style="white-space: pre-wrap; line-height: 1.4;">${content.trim()}</div>
</div>`
                    },
                    // THINK: 한줄 패턴
                    {
                        pattern: /^THINK:\s*(.+)$/gm,
                        replacement: (match, content) => `
<div class="thinking-line" style="
    margin: 8px 0;
    padding: 8px 12px;
    background: rgba(108, 117, 125, 0.1);
    border-radius: 6px;
    font-size: 0.8em;
    color: #6c757d;
    font-style: italic;
    border-left: 2px solid #6c757d;
">
    💭 ${content.trim()}
</div>`
                    },
                    // 멀티라인 THINK 블록
                    {
                        pattern: /THINK:\s*([\s\S]*?)(?=\n\n[A-Z가-힣]|\n\d+\.|\n-|\n\*|\n#|$)/gim,
                        replacement: (match, content) => `
<div class="thinking-section" style="
    margin: 12px 0;
    padding: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #6c757d;
    border-radius: 8px;
    font-size: 0.85em;
    color: #495057;
    font-style: italic;
    opacity: 0.85;
">
    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-weight: 600; color: #6c757d;">
        🧠 <span>Thinking...</span>
    </div>
    <div style="white-space: pre-wrap; line-height: 1.4;">${content.trim()}</div>
</div>`
                    }
                ];
                
                // 각 패턴에 대해 스타일링 적용
                thinkPatterns.forEach(({ pattern, replacement }) => {
                    processed = processed.replace(pattern, replacement);
                });
                
                // 한국어 추론 패턴들을 간단한 스타일로 처리
                const koreanThinkPatterns = [
                    /^생각:\s*(.+)$/gm,
                    /^분석:\s*(.+)$/gm,
                    /^추론:\s*(.+)$/gm
                ];
                
                koreanThinkPatterns.forEach(pattern => {
                    processed = processed.replace(pattern, (match, content) => `
<div class="thinking-line" style="
    margin: 8px 0;
    padding: 8px 12px;
    background: rgba(108, 117, 125, 0.1);
    border-radius: 6px;
    font-size: 0.8em;
    color: #6c757d;
    font-style: italic;
    border-left: 2px solid #6c757d;
">
    💭 ${content.trim()}
</div>`);
                });
                
                // 연속된 빈 줄 정리
                processed = processed.replace(/\n{3,}/g, '\n\n').trim();
                
                return processed;
            } catch (error) {
                console.warn('THINK block styling failed:', error);
                return text; // 실패 시 원본 텍스트 반환
            }
        }

        // 안정적인 실시간 THINK 블록 렌더링 함수
        function renderStreamingWithThinkBlocks(messageElement, fullText) {
            if (!window.marked) {
                messageElement.textContent = fullText;
                return;
            }

            try {
                // 메시지 요소에 처리된 THINK 블록 기록 저장
                if (!messageElement.processedThinkBlocks) {
                    messageElement.processedThinkBlocks = new Set();
                }
                if (!messageElement.isAnswerStarted) {
                    messageElement.isAnswerStarted = false;
                }
                
                // 참고문헌은 스트리밍 완료 후 후처리됨

                let processedHTML = '';
                let remainingText = fullText;
                
                // 완성된 <think> 블록들을 순차적으로 처리
                const completedThinkMatches = fullText.match(/<think>[\s\S]*?<\/think>/gi) || [];
                
                completedThinkMatches.forEach((match, index) => {
                    const content = match.replace(/<\/?think>/gi, '').trim();
                    const thinkId = `think-block-${index}`;
                    
                    // 이미 처리된 THINK 블록인지 확인
                    if (!messageElement.processedThinkBlocks.has(thinkId)) {
                        // 답변이 시작되었는지에 따라 open 속성 결정
                        const isOpen = !messageElement.isAnswerStarted;
                        const openAttr = isOpen ? 'open' : '';
                        const statusText = messageElement.isAnswerStarted ? '(답변 완료됨)' : '(완료)';
                        
                        // 새로운 완성된 THINK 블록 생성
                        const thinkHTML = `
<details class="thinking-accordion" id="${thinkId}" ${openAttr} style="
    margin: 12px 0;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    background: #f8f9fa;
">
    <summary style="
        cursor: pointer;
        padding: 12px;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 7px;
        font-weight: 600;
        color: #6c757d;
        display: flex;
        align-items: center;
        gap: 8px;
        user-select: none;
    ">
        💭 <span>thinking process</span>
        <span style="font-size: 0.8em; margin-left: auto; opacity: 0.7;">${statusText}</span>
    </summary>
    <div style="
        padding: 12px;
        font-size: 0.85em;
        color: #495057;
        font-style: italic;
        line-height: 1.4;
        white-space: pre-wrap;
        border-top: 1px solid #dee2e6;
        background: #ffffff;
    ">${escapeHtml(content)}</div>
</details>`;
                        processedHTML += thinkHTML;
                        messageElement.processedThinkBlocks.add(thinkId);
                    } else {
                        // 이미 처리된 블록은 기존 DOM에서 가져옴
                        const existingBlock = messageElement.querySelector(`#${thinkId}`);
                        if (existingBlock) {
                            processedHTML += existingBlock.outerHTML;
                        }
                    }
                    
                    // 처리된 THINK 블록을 텍스트에서 제거
                    remainingText = remainingText.replace(match, '');
                });

                // 진행 중인 THINK 블록 처리 (완성되지 않은 것)
                const incompleteThinkMatch = remainingText.match(/<think>[\s\S]*?$/i);
                if (incompleteThinkMatch) {
                    const incompleteContent = incompleteThinkMatch[0].replace(/<think>/i, '').trim();
                    processedHTML += `
<div class="thinking-section streaming" style="
    margin: 12px 0;
    padding: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #6c757d;
    border-radius: 8px;
    font-size: 0.85em;
    color: #495057;
    font-style: italic;
    opacity: 0.85;
">
    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-weight: 600; color: #6c757d;">
        💭 <span>thinking...</span>
        <span class="typing-cursor">▎</span>
    </div>
    <div style="white-space: pre-wrap; line-height: 1.4;">${escapeHtml(incompleteContent)}</div>
</div>`;
                    // 진행 중인 THINK 블록도 텍스트에서 제거
                    remainingText = remainingText.replace(incompleteThinkMatch[0], '');
                }

                // 실제 답변이 시작되었는지 확인
                const cleanAnswer = remainingText.trim();
                if (cleanAnswer.length > 30 && !messageElement.isAnswerStarted) {
                    messageElement.isAnswerStarted = true;
                    console.log('답변 시작됨 - THINK 블록 접기 시작');
                }
                
                // 일반 답변 텍스트 처리 (참고문헌은 스트리밍 완료 후 후처리됨)
                let answerHTML = '';
                if (cleanAnswer) {
                    // 불완전한 HTML 태그들 필터링 (참고문헌 조각들 제거)
                    let filteredText = cleanAnswer;
                    
                    // 단독으로 나타나는 HTML 태그들 제거 (줄 전체가 태그인 경우)
                    filteredText = filteredText.replace(/^\s*<\/?(?:details|summary|div|span)[^>]*>\s*$/gm, '');
                    
                    // 공백만 남은 줄들 제거
                    filteredText = filteredText.replace(/^\s*$/gm, '').trim();
                    
                    // 필터링 후 빈 내용이면 스킵
                    if (!filteredText) {
                        return;
                    }
                    
                    // 필터링된 텍스트로 계속 처리
                    const processedText = filteredText;
                    // 코드 블록 경계 감지 (불완전한 코드 블록 처리)
                    const codeBlockPattern = /```[\s\S]*?```/g;
                    const incompleteCodeBlockPattern = /```[\s\S]*$/;
                    
                    // 불완전한 코드 블록이 있는지 확인
                    const hasIncompleteCodeBlock = incompleteCodeBlockPattern.test(processedText);
                    
                    let textToRender = processedText;
                    let incompleteContent = '';
                    
                    if (hasIncompleteCodeBlock) {
                        // 불완전한 코드 블록을 분리
                        const match = processedText.match(/^([\s\S]*?)(```[\s\S]*)$/);
                        if (match) {
                            textToRender = match[1]; // 완성된 부분
                            incompleteContent = match[2]; // 불완전한 코드 블록
                        }
                    } else {
                        // 마지막 줄은 아직 작성 중일 수 있으므로 분리
                        const answerLines = processedText.split('\n');
                        if (answerLines.length > 1) {
                            const completedAnswerLines = answerLines.slice(0, -1);
                            const currentAnswerLine = answerLines[answerLines.length - 1];
                            
                            textToRender = completedAnswerLines.join('\n');
                            incompleteContent = currentAnswerLine;
                        }
                    }

                    // 완성된 부분 렌더링
                    if (textToRender && textToRender.trim()) {
                        try {
                            answerHTML = window.marked.parse(textToRender);
                            answerHTML = cleanIncompleteHTML(answerHTML);
                            answerHTML = enhanceMarkdownRendering(answerHTML);
                        } catch (e) {
                            console.warn('Markdown parsing failed for completed text:', e);
                            answerHTML = `<p>${escapeHtml(textToRender)}</p>`;
                        }
                    }

                    // 불완전한 부분 처리 (코드 블록이거나 현재 줄)
                    if (incompleteContent && incompleteContent.trim()) {
                        if (hasIncompleteCodeBlock) {
                            // 불완전한 코드 블록을 스타일링된 프리뷰로 표시
                            const content = incompleteContent.replace(/^```\w*\n?/, '').trim();
                            answerHTML += `
<pre style="
    background-color: #f8f9fa; 
    padding: 1rem; 
    border-radius: 4px; 
    overflow-x: auto; 
    border-left: 4px solid #007bff;
    position: relative;
    border: 1px dashed #dee2e6;
"><code>${escapeHtml(content)}<span class="typing-cursor">▎</span></code>
<div style="
    position: absolute; 
    top: 5px; 
    right: 10px; 
    font-size: 0.8em; 
    color: #6c757d; 
    background: rgba(255,255,255,0.8); 
    padding: 2px 6px; 
    border-radius: 3px;
">작성 중...</div>
</pre>`;
                        } else {
                            // 일반 텍스트 줄 처리
                            if (incompleteContent.includes('**') || incompleteContent.includes('*') || 
                                incompleteContent.includes('`') || incompleteContent.includes('#')) {
                                try {
                                    let currentLineHTML = window.marked.parse(incompleteContent);
                                    currentLineHTML = cleanIncompleteHTML(currentLineHTML);
                                    answerHTML += currentLineHTML.replace('</p>', '<span class="typing-cursor">▎</span></p>');
                                } catch (e) {
                                    answerHTML += `<p>${escapeHtml(incompleteContent)}<span class="typing-cursor">▎</span></p>`;
                                }
                            } else {
                                answerHTML += `<p>${escapeHtml(incompleteContent)}<span class="typing-cursor">▎</span></p>`;
                            }
                        }
                    }
                }

                // 최종 HTML 설정
                messageElement.innerHTML = processedHTML + answerHTML;
                
                // DOM 업데이트 후 THINK 블록 이벤트 설정 (항상 실행)
                setTimeout(() => {
                    const allAccordions = messageElement.querySelectorAll('.thinking-accordion');
                    allAccordions.forEach(accordion => {
                        setupThinkBlockToggle(accordion);
                        
                        // 답변이 시작되었으면 접힘 상태 보장
                        if (messageElement.isAnswerStarted) {
                            accordion.removeAttribute('open');
                            accordion.open = false;
                        }
                    });
                }, 10);

            } catch (error) {
                console.warn('Markdown rendering error during streaming:', error);
                // 오류 시 텍스트로 fallback
                messageElement.textContent = fullText + '▎';
            }
        }

        // THINK 블록 접힘 관리 함수
        function collapseThinkBlocks(messageElement) {
            const allAccordions = messageElement.querySelectorAll('.thinking-accordion');
            allAccordions.forEach(accordion => {
                // open 속성과 property 모두 제거하여 접기
                accordion.removeAttribute('open');
                accordion.open = false;
                
                // 상태 텍스트 업데이트
                const statusSpan = accordion.querySelector('summary span:last-child');
                if (statusSpan && !statusSpan.textContent.includes('답변 완료됨')) {
                    statusSpan.textContent = '(답변 완료됨)';
                }
                
                // 수동 토글 이벤트 리스너 추가 (중복 방지)
                setupThinkBlockToggle(accordion);
            });
        }

        // THINK 블록 토글 이벤트 설정
        function setupThinkBlockToggle(accordion) {
            const summary = accordion.querySelector('summary');
            if (summary && !summary.hasAttribute('data-event-attached')) {
                summary.setAttribute('data-event-attached', 'true');
                
                // 기본 동작 방지하고 수동 제어
                summary.addEventListener('click', function(e) {
                    e.preventDefault(); // 기본 details 동작 방지
                    e.stopPropagation(); // 이벤트 전파 방지
                    
                    // 답변 완료 후에는 토글 허용
                    const statusSpan = accordion.querySelector('summary span:last-child');
                    const isCompleted = statusSpan && (
                        statusSpan.textContent.includes('완료') || 
                        statusSpan.textContent.includes('답변 완료됨')
                    );
                    
                    if (isCompleted) {
                        // 수동 토글 (DOM 조작으로 직접 제어)
                        const isCurrentlyOpen = accordion.hasAttribute('open') || accordion.open;
                        
                        if (isCurrentlyOpen) {
                            accordion.removeAttribute('open');
                            accordion.open = false;
                            console.log('THINK 블록이 수동으로 접혀짐');
                        } else {
                            accordion.setAttribute('open', '');
                            accordion.open = true;
                            console.log('THINK 블록이 수동으로 펼쳐짐');
                        }
                    } else {
                        console.log('THINK 블록이 아직 완료되지 않음 - 토글 불가');
                    }
                });
            }
        }

        // 답변 완료 후 THINK 블록 최종 상태 설정
        function finalizeThinkBlocks(messageElement) {
            const allAccordions = messageElement.querySelectorAll('.thinking-accordion');
            allAccordions.forEach(accordion => {
                // 최종 접힘 상태로 고정 (DOM property와 attribute 모두 설정)
                accordion.removeAttribute('open');
                accordion.open = false;
                
                // 토글 이벤트 설정 (아직 설정되지 않았다면)
                setupThinkBlockToggle(accordion);
                
                // 최종 상태 텍스트로 업데이트
                const statusSpan = accordion.querySelector('summary span:last-child');
                if (statusSpan) {
                    statusSpan.textContent = '(완료)';
                    statusSpan.style.color = '#28a745';
                }
                
                // summary 스타일 업데이트 (완료 상태)
                const summary = accordion.querySelector('summary');
                if (summary) {
                    summary.style.background = 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)';
                    summary.style.opacity = '0.8';
                }
            });
        }
        
        // 기존 renderStreamingMarkdown 함수는 호환성을 위해 유지
        function renderStreamingMarkdown(messageElement, fullText) {
            return renderStreamingWithThinkBlocks(messageElement, fullText);
        }

        // HTML 태그 이스케이프 함수
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 마크다운 렌더링 후처리 함수
        function enhanceMarkdownRendering(html) {
            try {
                // 임시 div에서 HTML 처리
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;

                // 색깔 강조 처리 - 이모지가 포함된 strong 태그들
                const strongElements = tempDiv.querySelectorAll('strong');
                strongElements.forEach(strong => {
                    const text = strong.textContent;
                    
                    if (text.includes('🔴')) {
                        strong.style.cssText = 'color: #dc3545; background: rgba(220, 53, 69, 0.1); padding: 3px 8px; border-radius: 5px; border: 1px solid rgba(220, 53, 69, 0.2);';
                    } else if (text.includes('🟡')) {
                        strong.style.cssText = 'color: #fd7e14; background: rgba(255, 193, 7, 0.1); padding: 3px 8px; border-radius: 5px; border: 1px solid rgba(255, 193, 7, 0.3);';
                    } else if (text.includes('🟢')) {
                        strong.style.cssText = 'color: #28a745; background: rgba(40, 167, 69, 0.1); padding: 3px 8px; border-radius: 5px; border: 1px solid rgba(40, 167, 69, 0.2);';
                    } else if (text.includes('🔵')) {
                        strong.style.cssText = 'color: #007bff; background: rgba(0, 123, 255, 0.1); padding: 3px 8px; border-radius: 5px; border: 1px solid rgba(0, 123, 255, 0.2);';
                    }
                    
                    // 섹션 제목 이모지 강화
                    if (text.match(/^(📊|🎯|📋|📈|💡|⚡|🔧|🏭|🔬|✨)/)) {
                        strong.style.cssText += ' font-size: 1.1em; display: inline-block; margin-bottom: 0.5rem; padding: 0.3rem 0.8rem; border-radius: 6px;';
                    }
                });

                // 이모지 기반 섹션 제목 처리
                const paragraphs = tempDiv.querySelectorAll('p');
                paragraphs.forEach(p => {
                    const text = p.textContent;
                    if (text.match(/^(📊|🎯|📋|📈|💡|⚡|🔧|🏭|🔬|✨)/)) {
                        p.style.cssText = 'font-weight: 600; color: #2c3e50; margin-top: 1.5rem; margin-bottom: 0.5rem; padding: 0.5rem 0; border-bottom: 2px solid #e9ecef;';
                    }
                });

                // 수치 데이터 시각화 프로그레스 바 처리 (매우 제한적으로만 적용)
                const codeBlocks = tempDiv.querySelectorAll('pre code');
                codeBlocks.forEach(code => {
                    const text = code.textContent;
                    // 매우 엄격한 조건: 프로그레스 바 패턴이 명확히 있고, 다른 코드가 없을 때만 처리
                    const hasProgressPattern = /(.+?):\s*(█+░*)\s*(\d+%)/g.test(text);
                    const looksLikeProgressOnly = text.split('\n').every(line => 
                        line.trim() === '' || 
                        line.includes('█') && line.includes('%') ||
                        line.match(/^(탕구비|러너비|인게이트비|비율|설계|주조)/i)
                    );
                    
                    if (hasProgressPattern && looksLikeProgressOnly && text.length < 500) {
                        // 프로그레스 바가 포함된 코드 블록을 특별 처리
                        const lines = text.split('\n');
                        let enhancedHTML = '';
                        let hasValidProgress = false;
                        
                        lines.forEach(line => {
                            if (line.includes('█') && line.includes('%')) {
                                // 프로그레스 바 라인 스타일링
                                const progressMatch = line.match(/(.+?):\s*(█+░*)\s*(\d+%)\s*(.*)/);
                                if (progressMatch) {
                                    hasValidProgress = true;
                                    const [, label, bar, percentage, desc] = progressMatch;
                                    const filledBlocks = (bar.match(/█/g) || []).length;
                                    const totalBlocks = bar.length;
                                    const progressPercent = Math.round((filledBlocks / totalBlocks) * 100);
                                    
                                    enhancedHTML += `<div style="margin: 0.5rem 0; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #667eea;">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="font-weight: 500; min-width: 120px;">${label}:</span>
                                            <div style="flex: 1; background: #e9ecef; height: 8px; border-radius: 4px; overflow: hidden;">
                                                <div style="width: ${progressPercent}%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);"></div>
                                            </div>
                                            <span style="font-weight: 600; color: #667eea;">${percentage}</span>
                                            <span style="color: #6c757d; font-size: 0.9em;">${desc}</span>
                                        </div>
                                    </div>`;
                                } else {
                                    enhancedHTML += escapeHtml(line) + '<br>';
                                }
                            } else if (line.trim() !== '') {
                                enhancedHTML += escapeHtml(line) + '<br>';
                            }
                        });
                        
                        // 실제로 유효한 프로그레스 바가 있었을 때만 적용
                        if (hasValidProgress && enhancedHTML !== '') {
                            code.innerHTML = enhancedHTML;
                        }
                    }
                });

                // 표에 추가 스타일 적용
                const tables = tempDiv.querySelectorAll('table');
                tables.forEach(table => {
                    // 테이블 컨테이너 래핑
                    const wrapper = document.createElement('div');
                    wrapper.style.cssText = 'overflow-x: auto; margin: 1.5rem 0; border-radius: 8px; box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);';
                    
                    table.style.cssText = 'width: 100%; border-collapse: collapse; background: white; min-width: 500px;';
                    
                    const ths = table.querySelectorAll('th');
                    ths.forEach(th => {
                        th.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: 600; padding: 12px 16px; text-align: left; border: none; font-size: 0.95rem;';
                    });
                    
                    const tds = table.querySelectorAll('td');
                    tds.forEach((td, index) => {
                        td.style.cssText = 'padding: 12px 16px; border-bottom: 1px solid #e9ecef; font-size: 0.9rem; vertical-align: top;';
                        
                        // 짝수 행 배경색
                        const row = td.parentElement;
                        const rowIndex = Array.from(row.parentElement.children).indexOf(row);
                        if (rowIndex % 2 === 0) {
                            td.style.backgroundColor = '#f8f9fa';
                        }
                    });
                    
                    // 호버 효과 추가
                    const rows = table.querySelectorAll('tr');
                    rows.forEach(row => {
                        row.addEventListener('mouseenter', () => {
                            row.querySelectorAll('td').forEach(td => {
                                td.style.backgroundColor = '#e3f2fd';
                            });
                        });
                        row.addEventListener('mouseleave', () => {
                            row.querySelectorAll('td').forEach((td, index) => {
                                const rowIndex = Array.from(row.parentElement.children).indexOf(row);
                                td.style.backgroundColor = rowIndex % 2 === 0 ? '#f8f9fa' : 'white';
                            });
                        });
                    });
                    
                    // 테이블을 래퍼로 감싸기
                    table.parentNode.insertBefore(wrapper, table);
                    wrapper.appendChild(table);
                });

                // 리스트 개선
                const lists = tempDiv.querySelectorAll('ul, ol');
                lists.forEach(list => {
                    list.style.cssText = 'margin: 1rem 0; padding-left: 1.5rem;';
                    
                    const items = list.querySelectorAll('li');
                    items.forEach(li => {
                        li.style.cssText = 'margin: 0.5rem 0; line-height: 1.6;';
                        
                        // 체크리스트 스타일 - 이모지만 색상 적용, 나머지 텍스트는 기본 색상 유지
                        const text = li.textContent;
                        if (text.includes('✅')) {
                            li.innerHTML = li.innerHTML.replace(/✅/g, '<span style="color: #28a745; display: inline;">✅</span>');
                            li.style.cssText += '; font-weight: 500; color: inherit;'; // 기본 색상 상속 보장
                        } else if (text.includes('❌')) {
                            li.innerHTML = li.innerHTML.replace(/❌/g, '<span style="color: #dc3545; display: inline;">❌</span>');
                            li.style.cssText += '; font-weight: 500; color: inherit;'; // 기본 색상 상속 보장
                        } else if (text.includes('⚙️')) {
                            li.innerHTML = li.innerHTML.replace(/⚙️/g, '<span style="color: #6c757d;">⚙️</span>');
                            li.style.fontWeight = '500';
                        }
                    });
                });

                return tempDiv.innerHTML;
            } catch (error) {
                console.warn('Enhanced markdown rendering failed:', error);
                return html;
            }
        }

        // 불완전한 HTML 태그 정리 함수
        function cleanIncompleteHTML(html) {
            if (!html) return '';
            
            // HTML 참조 문헌인 경우 태그 정리를 스킵
            if ((html.trim().startsWith('<details') && html.includes('참조 문헌')) ||
                (html.includes('<details') && html.includes('참조 문헌') && html.includes('</details>'))) {
                return html;
            }
            
            // 닫히지 않은 태그들을 찾아서 제거하거나 닫기
            let cleaned = html;
            
            // 일반적인 마크다운 태그들의 불완전한 형태 처리
            const tagPairs = [
                ['<strong>', '</strong>'],
                ['<em>', '</em>'],
                ['<code>', '</code>'],
                ['<pre>', '</pre>'],
                ['<p>', '</p>'],
                ['<h1>', '</h1>'],
                ['<h2>', '</h2>'],
                ['<h3>', '</h3>'],
                ['<h4>', '</h4>'],
                ['<h5>', '</h5>'],
                ['<h6>', '</h6>'],
                ['<ul>', '</ul>'],
                ['<ol>', '</ol>'],
                ['<li>', '</li>'],
                ['<blockquote>', '</blockquote>'],
                ['<details>', '</details>'],
                ['<summary>', '</summary>'],
                ['<div>', '</div>'],
                ['<span>', '</span>']
            ];

            for (const [openTag, closeTag] of tagPairs) {
                const openCount = (cleaned.match(new RegExp(escapeRegex(openTag), 'g')) || []).length;
                const closeCount = (cleaned.match(new RegExp(escapeRegex(closeTag), 'g')) || []).length;
                
                // 열린 태그가 더 많으면 닫는 태그 추가
                if (openCount > closeCount) {
                    cleaned += closeTag.repeat(openCount - closeCount);
                }
            }

            return cleaned;
        }

        // 정규식 이스케이프 함수
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // 대화 히스토리 관리 함수들
        function addToConversationHistory(role, content) {
            conversationHistory.push({
                role: role, // 'user' or 'assistant'
                content: content,
                timestamp: new Date().toISOString()
            });
            
            // 최대 길이 제한
            if (conversationHistory.length > MAX_HISTORY_LENGTH * 2) { // user + assistant 쌍이므로 *2
                conversationHistory = conversationHistory.slice(-MAX_HISTORY_LENGTH * 2);
            }
            
            console.log('Updated conversation history:', conversationHistory.length, 'messages');
        }

        function clearConversationHistory() {
            conversationHistory = [];
            console.log('Conversation history cleared');
        }

        function getConversationContext() {
            // 최근 대화들을 문맥으로 반환
            return conversationHistory.slice(-6) // 최근 3쌍(6개 메시지)만 사용
                .map(msg => `${msg.role}: ${msg.content}`)
                .join('\n');
        }

        // 파일 선택 상태 관리
        let selectedFilesForUpload = new Set();
        
        // 파일 선택 시 이벤트 리스너
        pdfFile.addEventListener('change', function(event) {
            const files = Array.from(event.target.files);
            
            // 파일 개수 제한 확인 (최대 10개)
            const MAX_FILES = 10;
            if (files.length > MAX_FILES) {
                alert(`⚠️ 최대 ${MAX_FILES}개의 파일까지만 선택할 수 있습니다.\n현재 선택된 파일: ${files.length}개\n\n처리 성능상 최대 5개 파일까지만 동시에 처리됩니다.`);
                
                // 파일 선택 초기화
                event.target.value = '';
                displaySelectedFiles([]);
                return;
            }
            
            // 5개 이상 선택 시 안내 메시지
            if (files.length > 5) {
                const message = `📋 ${files.length}개 파일이 선택되었습니다.\n\n⚡ 성능 최적화를 위해 최대 5개씩 동시 처리됩니다.\n나머지 파일들은 순차적으로 처리됩니다.`;
                
                // 간단한 토스트 메시지 표시
                showToastMessage(message, 'info');
            }
            
            displaySelectedFiles(files);
        });
        
        // 선택된 파일 목록 표시
        function displaySelectedFiles(files) {
            const container = document.getElementById('selected-files-container');
            const filesList = document.getElementById('selected-files-list');
            const selectedCount = document.getElementById('selected-count');
            
            if (files.length === 0) {
                container.style.display = 'none';
                selectedFilesForUpload.clear();
                return;
            }
            
            container.style.display = 'block';
            selectedFilesForUpload.clear();
            
            filesList.innerHTML = '';
            files.forEach((file, index) => {
                selectedFilesForUpload.add(index); // 기본적으로 모든 파일 선택
                
                const fileItem = document.createElement('div');
                fileItem.style.cssText = `
                    display: flex; 
                    align-items: center; 
                    padding: 8px 12px; 
                    margin-bottom: 6px; 
                    background: white; 
                    border: 1px solid #dee2e6; 
                    border-radius: 6px;
                    transition: all 0.2s ease;
                `;
                
                fileItem.innerHTML = `
                    <input type="checkbox" id="file-${index}" checked style="margin-right: 10px;">
                    <label for="file-${index}" style="flex: 1; margin: 0; cursor: pointer; font-size: 0.9rem;">
                        📄 ${file.name}
                    </label>
                    <span style="font-size: 0.8rem; color: #6c757d;">
                        ${(file.size / 1024 / 1024).toFixed(2)} MB
                    </span>
                `;
                
                const checkbox = fileItem.querySelector(`#file-${index}`);
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        selectedFilesForUpload.add(index);
                        fileItem.style.backgroundColor = 'white';
                    } else {
                        selectedFilesForUpload.delete(index);
                        fileItem.style.backgroundColor = '#f8f9fa';
                    }
                    updateSelectedCount();
                });
                
                filesList.appendChild(fileItem);
            });
            
            updateSelectedCount();
        }
        
        // 선택된 파일 개수 업데이트
        function updateSelectedCount() {
            const selectedCount = document.getElementById('selected-count');
            const submitBtn = document.getElementById('upload-submit-btn');
            
            selectedCount.textContent = `${selectedFilesForUpload.size}개 파일 선택됨`;
            submitBtn.disabled = selectedFilesForUpload.size === 0;
            
            if (selectedFilesForUpload.size === 0) {
                submitBtn.style.opacity = '0.5';
                submitBtn.style.cursor = 'not-allowed';
            } else {
                submitBtn.style.opacity = '1';
                submitBtn.style.cursor = 'pointer';
            }
        }
        
        // 전체 선택/해제 버튼
        document.getElementById('select-all-btn').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#selected-files-list input[type="checkbox"]');
            checkboxes.forEach((checkbox, index) => {
                checkbox.checked = true;
                selectedFilesForUpload.add(index);
                checkbox.closest('div').style.backgroundColor = 'white';
            });
            updateSelectedCount();
        });
        
        document.getElementById('deselect-all-btn').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#selected-files-list input[type="checkbox"]');
            checkboxes.forEach((checkbox, index) => {
                checkbox.checked = false;
                selectedFilesForUpload.delete(index);
                checkbox.closest('div').style.backgroundColor = '#f8f9fa';
            });
            updateSelectedCount();
        });

        uploadForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            
            // 파일 업로드 시작 시 management 메시지 클리어
            if (typeof clearManagementStatus === 'function') {
                clearManagementStatus();
            }
            
            const allFiles = Array.from(pdfFile.files);
            const selectedFiles = allFiles.filter((file, index) => selectedFilesForUpload.has(index));
            
            if (selectedFiles.length === 0) {
                uploadStatus.textContent = '처리할 파일을 선택하세요.';
                updateProcessingActivity('idle');
                return;
            }
            
            // 업로드 진행률 UI 초기화 및 표시
            initializeUploadProgress(selectedFiles);
            
            // 문서 처리 상태를 '처리중'으로 변경
            updateProcessingActivity('processing');
            
            const formData = new FormData();
            for (const f of selectedFiles) {
                formData.append('files', f);
            }
            // Include OCR correction flag from dashboard toggle
            const ocrToggle = document.getElementById('ocr-correction-toggle');
            formData.append('ocr_correction_enabled', ocrToggle.checked);
            
            // Include LLM correction flag from dashboard toggle
            const llmToggle = document.getElementById('llm-correction-toggle');
            formData.append('llm_correction_enabled', llmToggle.checked);
            try {
                // XMLHttpRequest를 사용하여 업로드 진행률 추적
                const result = await uploadWithProgress(formData, selectedFiles);
                if (result.success) {
                    if (result.results && Array.isArray(result.results)) {
                        const successfulUploads = [];
                        const errorUploads = [];
                        
                        // 파일 결과별로 진행률 업데이트
                        for (let i = 0; i < result.results.length; i++) {
                            const r = result.results[i];
                            if (r.error) {
                                errorUploads.push({filename: r.filename || '파일 없음', error: r.error});
                                updateFileProgress(i, 0, '업로드 실패');
                            } else {
                                if(r.document_id) {
                                    successfulUploads.push({
                                        documentId: r.document_id,
                                        filename: r.filename
                                    });
                                    updateFileProgress(i, 100, '처리 시작됨');
                                }
                            }
                        }
                        
                        // 전체 진행률 업데이트
                        updateOverallProgress(successfulUploads.length, selectedFiles.length, 
                            `${successfulUploads.length}개 파일 업로드 완료, ${errorUploads.length}개 실패`);
                        
                        // 오류가 있는 경우만 메시지 표시
                        if (errorUploads.length > 0) {
                            let errorMsg = '';
                            errorUploads.forEach(error => {
                                errorMsg += `❌ ${error.filename}: ${error.error}\n`;
                            });
                            uploadStatus.textContent = errorMsg.trim();
                            uploadStatus.className = 'status-message status-error';
                            // 문서 처리 상태를 '오류'로 변경
                            updateProcessingActivity('error');
                        } else {
                            // 성공한 경우 간단한 메시지만
                            uploadStatus.textContent = `${successfulUploads.length}개 파일 업로드 시작됨`;
                            uploadStatus.className = 'status-message status-success';
                            // 문서 처리 상태를 '완료'로 변경 (100% 진행률)
                            updateProcessingActivity('completed', 100);
                        }
                        
                        // 다중 파일 진행률 추적 시작
                        if (successfulUploads.length > 0) {
                            startMultiFileProgressTracking(successfulUploads);
                            
                            // 업로드 완료 후 업로드 관련 UI 정리 (3초 후)
                            setTimeout(() => {
                                // 업로드 상태 메시지 정리
                                uploadStatus.textContent = '';
                                uploadStatus.className = 'status-message';
                                
                                // 선택된 파일 목록 숨기기 (문서 처리가 시작되었으므로)
                                const selectedFilesContainer = document.getElementById('selected-files-container');
                                if (selectedFilesContainer) {
                                    selectedFilesContainer.style.display = 'none';
                                    document.getElementById('selected-files-list').innerHTML = '';
                                    selectedFilesForUpload.clear();
                                    
                                    // 파일 입력 필드 초기화
                                    const pdfFileInput = document.getElementById('pdf-file');
                                    if (pdfFileInput) {
                                        pdfFileInput.value = '';
                                    }
                                    
                                    // 업로드 버튼 상태 초기화
                                    updateSelectedCount();
                                }
                                
                                // 진행률 창에 포커스를 주어 사용자가 진행 상황을 볼 수 있도록 함
                                const progressContainer = document.getElementById('progress-container');
                                if (progressContainer) {
                                    progressContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }, 3000);
                        }
                        
                        // 문서 목록 새로고침
                        setTimeout(() => {
                            fetchDocumentList();
                        }, 2000);
                    } else {
                        uploadStatus.textContent = '알 수 없는 응답 형식';
                        uploadStatus.className = 'status-message status-error';
                        // 문서 처리 상태를 '오류'로 변경
                        updateProcessingActivity('error');
                    }
                } else {
                    uploadStatus.textContent = `오류: ${result.error || '알 수 없는 오류'}`;
                    uploadStatus.className = 'status-message status-error';
                    // 문서 처리 상태를 '오류'로 변경
                    updateProcessingActivity('error');
                }
            } catch (error) {
                console.error('Upload error:', error);
                
                // 각 파일을 오류 상태로 업데이트
                selectedFiles.forEach((file, index) => {
                    updateFileProgress(index, 0, '업로드 실패');
                });
                
                updateOverallProgress(0, selectedFiles.length, '업로드 실패');
                uploadStatus.textContent = `네트워크 오류: ${error.message}`;
                uploadStatus.className = 'status-message status-error';
                
                // 문서 처리 상태를 '오류'로 변경
                updateProcessingActivity('error');
            }
        });

        async function sendMessage() {
            const query = chatInput.value.trim();
            if (!query) return;

            // 1. 즉시 이전 상태 정리 (동일 질문 시 깨끗한 시작을 위해)
            resetChatProgress();

            appendMessage('user', query);
            chatInput.value = '';
            
            // Show progress indicator
            showChatProgress();
            
            // 모델 활동 상태를 '처리중'으로 변경
            updateModelActivity('processing');
            
            // Create streaming message container
            const streamingMessageDiv = document.createElement('div');
            streamingMessageDiv.classList.add('message', 'bot-message', 'streaming');
            const messageContent = document.createElement('div');
            messageContent.classList.add('streaming-content');
            streamingMessageDiv.appendChild(messageContent);
            chatMessages.appendChild(streamingMessageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            try {
                // Debug: Log request details
                console.log('Sending chat request:', {
                    query: query,
                    model_name: getSelectedModel(),
                    document_ids: getSelectedDocumentIds(),
                    conversation_history: conversationHistory.length
                });
                
                // Create AbortController for cancelling the request
                const abortController = new AbortController();
                currentStreamAbortController = abortController;

                // Show stop button
                showStopButton();

                // Use EventSource for Server-Sent Events
                const response = await fetch('/api/chat/stream/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        query: query, 
                        model_name: getSelectedModel(), 
                        document_ids: getSelectedDocumentIds(),
                        conversation_history: conversationHistory
                    }),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    // Handle error responses, especially 400 Bad Request with validation messages
                    if (response.status === 400) {
                        try {
                            const errorData = await response.json();
                            if (errorData.detail && errorData.detail.message) {
                                // Display the validation error message from backend
                                appendMessage('bot', `❌ ${errorData.detail.message}`);
                                
                                // Also show suggestions if available
                                if (errorData.detail.suggestions && errorData.detail.suggestions.length > 0) {
                                    const suggestionsHtml = errorData.detail.suggestions
                                        .map(suggestion => `• ${suggestion}`)
                                        .join('\n');
                                    appendMessage('bot', `\n💡 **추천 질문:**\n${suggestionsHtml}`);
                                }
                                
                                chatStatus.textContent = '';
                                chatStatus.className = 'status-message';
                                return; // Exit early, don't throw error
                            }
                        } catch (parseError) {
                            console.warn('Failed to parse 400 error response:', parseError);
                        }
                    }
                    
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // Handle streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullResponse = '';
                let contentSummary = null;
                let mediaReferences = null;
                let markdownTimeout = null;

                // Initialize with first step only
                updateChatProgressStep('embedding', '질문을 처리하고 있습니다...');

                let buffer = '';
                
                // Add abort signal listener to force close reader
                abortController.signal.addEventListener('abort', () => {
                    console.log('Abort signal received, cancelling reader');
                    try {
                        reader.cancel();
                    } catch (e) {
                        console.log('Reader cancel failed:', e);
                    }
                });
                
                try {
                    while (true) {
                        // Check if abort was requested
                        if (abortController.signal.aborted) {
                            console.log('Streaming aborted by user');
                            break;
                        }
                        
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep incomplete line in buffer

                        for (const line of lines) {
                            if (line.trim().startsWith('data: ')) {
                                try {
                                    const jsonStr = line.trim().substring(6);
                                    if (jsonStr.trim()) {
                                        const data = JSON.parse(jsonStr);
                                        
                                        if (data.type === 'status') {
                                            // Update status message and progress step
                                            chatStatus.textContent = data.message;
                                            chatStatus.className = 'status-message';
                                            
                                            // Update progress step based on status message with sequential timing
                                            console.log('Status message received:', data.message); // Debug log
                                            
                                            // 단순화된 단계별 진행 로직 (중복 실행 방지)
                                            if (data.message.includes('질문 분석')) {
                                                updateChatProgressStep('query', data.message);
                                            } else if (data.message.includes('캐시에서 답변을 불러오고 있습니다')) {
                                                updateChatProgressStep('embedding', '캐시 확인 중...');
                                            } else if (data.message.includes('LLM으로 답변을 구조화하고 있습니다')) {
                                                updateChatProgressStep('generate', '💾 캐시된 답변을 구조화하고 있습니다...');
                                            } else if (data.message.includes('관련 문서 검색')) {
                                                updateChatProgressStep('search', data.message);
                                            } else if (data.message.includes('답변 생성')) {
                                                updateChatProgressStep('generate', data.message);
                                            }
                                        } else if (data.type === 'content') {
                                            // First content chunk - we're definitely in generate phase
                                            if (fullResponse === '') {
                                                console.log('First content chunk received, starting generate step');
                                                updateChatProgressStep('generate', 'AI가 답변을 생성하고 있습니다...');
                                            }
                                            
                                            // Append content to streaming message
                                            fullResponse += data.content;
                                            console.log('Content appended, fullResponse length:', fullResponse.length);
                                            
                                            // 참고문헌 디버깅 - 모든 content 로그
                                            if (data.content.includes('참조') || data.content.includes('details') || data.content.includes('문헌')) {
                                                console.log('🔍 참고문헌 관련 콘텐츠:', data.content);
                                            }
                                            
                                            // 실시간 마크다운 렌더링 (줄 단위)
                                            renderStreamingMarkdown(messageContent, fullResponse);
                                            
                                            chatMessages.scrollTop = chatMessages.scrollHeight;
                                            
                                        } else if (data.type === 'final') {
                                            // Store metadata
                                            contentSummary = data.metadata.content_summary;
                                            mediaReferences = data.metadata.media_references;
                                            
                                            console.log('Final metadata received:', { contentSummary, mediaReferences });
                                            
                                            // Complete progress in final stage
                                            updateChatProgressStep('generate', '답변 생성 완료!');
                                            
                                            // 스트리밍 완료 시 모든 THINK 블록 접기
                                            setTimeout(() => {
                                                const allThinkAccordions = messageContent.querySelectorAll('.thinking-accordion');
                                                allThinkAccordions.forEach(accordion => {
                                                    accordion.removeAttribute('open');
                                                    const statusSpan = accordion.querySelector('summary span:last-child');
                                                    if (statusSpan && !statusSpan.textContent.includes('답변 완료됨')) {
                                                        statusSpan.textContent = '(답변 완료됨)';
                                                    }
                                                });
                                                console.log('스트리밍 완료 - 모든 THINK 블록 접기 처리됨');
                                            }, 100);
                                        } else if (data.type === 'validation_error') {
                                            // Handle validation errors from backend
                                            console.log('Validation error received:', data);
                                            
                                            // Display validation error message
                                            let errorMessage = `❌ ${data.message}`;
                                            appendMessage('bot', errorMessage);
                                            
                                            // Also show suggestions if available
                                            if (data.suggestions && data.suggestions.length > 0) {
                                                const suggestionsHtml = data.suggestions
                                                    .map(suggestion => `• ${suggestion}`)
                                                    .join('\n');
                                                appendMessage('bot', `\n💡 **추천 질문:**\n${suggestionsHtml}`);
                                            }
                                            
                                            // Clear status and stop streaming
                                            chatStatus.textContent = '';
                                            chatStatus.className = 'status-message';
                                            
                                            // Remove the streaming message placeholder since we showed error
                                            if (streamingMessageDiv.parentNode) {
                                                streamingMessageDiv.parentNode.removeChild(streamingMessageDiv);
                                            }
                                            
                                            return; // Exit streaming loop
                                        } else if (data.type === 'error') {
                                            throw new Error(data.message);
                                        }
                                    }
                                } catch (parseError) {
                                    console.warn('Failed to parse SSE data:', line, parseError);
                                }
                            }
                        }
                    }
                } catch (streamError) {
                    console.error('Streaming read error:', streamError);
                    throw streamError;
                } finally {
                    // Ensure reader cleanup
                    try {
                        reader.releaseLock();
                    } catch (releaseError) {
                        console.warn('Failed to release reader lock:', releaseError);
                    }
                }

                // Remove streaming class and finalize message
                streamingMessageDiv.classList.remove('streaming');
                
                // Remove typing cursor and process references
                if (fullResponse && messageContent) {
                    // 타이핑 커서 제거
                    const typingCursors = messageContent.querySelectorAll('.typing-cursor');
                    typingCursors.forEach(cursor => cursor.remove());
                    
                    // 참고문헌 후처리 - 전체 응답에서 참고문헌 추출
                    const referenceMatch = fullResponse.match(/<details[^>]*>[\s\S]*?참조 문헌[\s\S]*?<\/details>/i);
                    if (referenceMatch) {
                        const referenceHTML = referenceMatch[0];
                        console.log('참고문헌 발견, 후처리 중:', referenceHTML.length, '자');
                        
                        // 기존 내용에서 참고문헌 제거 (중복 방지)
                        let cleanContent = messageContent.innerHTML;
                        
                        // 1. 기존 참고문헌만 제거 (중복 방지)
                        cleanContent = cleanContent.replace(/<details[^>]*>[\s\S]*?참조 문헌[\s\S]*?<\/details>/gi, '');
                        
                        // 2. 텍스트로 렌더링된 불완전한 HTML 조각들만 제거 (매우 정교한 패턴)
                        // - 단독으로 나타나는 HTML 태그들만 제거하고, 실제 HTML 구조는 보존
                        // - 줄 단위로 확인하여 고립된 태그만 제거
                        const lines = cleanContent.split('\n');
                        const filteredLines = lines.map(line => {
                            const trimmedLine = line.trim();
                            // 한 줄에 단독으로 나타나는 HTML 태그만 제거 (텍스트 없이)
                            if (/^<\/?(?:details|summary|div|span)[^>]*>$/.test(trimmedLine)) {
                                return '';
                            }
                            return line;
                        });
                        cleanContent = filteredLines.join('\n');
                        
                        // 참고문헌을 맨 끝에 추가
                        messageContent.innerHTML = cleanContent + referenceHTML;
                        console.log('참고문헌 후처리 완료');
                    } else {
                        console.log('참고문헌 없음');
                    }
                }
                
                // Complete the generate progress step
                if (fullResponse) {
                    updateChatProgressStep('generate', '답변 생성 완료!');
                }
                
                // 스트리밍 완료 후 모든 THINK 블록 접기 (최종 처리)
                setTimeout(() => {
                    if (messageContent) {
                        const finalThinkAccordions = messageContent.querySelectorAll('.thinking-accordion');
                        finalThinkAccordions.forEach(accordion => {
                            accordion.removeAttribute('open');
                            const statusSpan = accordion.querySelector('summary span:last-child');
                            if (statusSpan && !statusSpan.textContent.includes('답변 완료됨')) {
                                statusSpan.textContent = '(답변 완료됨)';
                            }
                        });
                        if (finalThinkAccordions.length > 0) {
                            console.log(`스트림 종료 - ${finalThinkAccordions.length}개 THINK 블록 최종 접기 처리됨`);
                        }
                    }
                }, 200);
                
                // Clear any pending markdown timeout
                if (markdownTimeout) {
                    clearTimeout(markdownTimeout);
                }
                
                // 스트리밍 메시지를 enhanced multimodal 형태로 변환하지 않고 그대로 유지
                // THINK 블록 상태를 보존하기 위해 추가 변환 작업 스킵
                if (fullResponse) {
                    console.log('스트리밍 완료 - 메시지 변환 스킵하여 THINK 블록 상태 보존');
                    
                    // 스트리밍 메시지의 클래스만 정리하고 내용은 유지
                    streamingMessageDiv.classList.remove('streaming');
                    streamingMessageDiv.classList.add('bot-message');
                    
                    // 최종적으로 THINK 블록들이 접힌 상태인지 확인
                    setTimeout(() => {
                        const allAccordions = streamingMessageDiv.querySelectorAll('.thinking-accordion');
                        allAccordions.forEach(accordion => {
                            accordion.removeAttribute('open');
                            accordion.open = false;
                            
                            // 이벤트 핸들러 설정
                            setupThinkBlockToggle(accordion);
                            
                            const statusSpan = accordion.querySelector('summary span:last-child');
                            if (statusSpan) {
                                statusSpan.textContent = '(완료)';
                                statusSpan.style.color = '#28a745';
                            }
                        });
                        if (allAccordions.length > 0) {
                            console.log(`최종 상태 확인 완료 - ${allAccordions.length}개 THINK 블록 모두 접혀있음`);
                        }
                    }, 500);
                } else {
                    // Fallback for empty responses
                    if (window.marked && fullResponse) {
                        try {
                            let fallbackHTML = window.marked.parse(fullResponse);
                            fallbackHTML = enhanceMarkdownRendering(fallbackHTML);
                            messageContent.innerHTML = fallbackHTML;
                        } catch (markdownError) {
                            messageContent.textContent = fullResponse;
                        }
                    }
                }
                
                // 스트리밍 완료 후 대화 히스토리에 봇 응답 저장
                if (fullResponse && fullResponse.trim()) {
                    // 에러 메시지나 시스템 메시지가 아닌 경우에만 저장
                    if (!fullResponse.includes('⚠️') && !fullResponse.includes('❌') && !fullResponse.includes('답변을 드릴 수 없')) {
                        addToConversationHistory('assistant', fullResponse);
                        console.log('Bot response added to conversation history');
                    }
                }

                // Update status with summary
                chatStatus.className = 'status-message status-success';
                if (contentSummary) {
                    const summaryText = `텍스트: ${contentSummary.text_chunks || 0}개, 이미지: ${contentSummary.images || 0}개, 표: ${contentSummary.tables || 0}개`;
                    const cacheIndicator = '';
                    chatStatus.textContent = `✅ 답변 생성 완료 (${summaryText})${cacheIndicator}`;
                } else {
                    const cacheIndicator = '';
                    chatStatus.textContent = `✅ 답변이 생성되었습니다${cacheIndicator}`;
                }
                
                setTimeout(() => {
                    chatStatus.textContent = '';
                    chatStatus.className = 'status-message';
                }, 5000);

            } catch (error) {
                console.error('Streaming error:', error);
                console.error('Error details:', error.stack);
                console.error('Request context:', {
                    query: query,
                    model_name: getSelectedModel(),
                    document_ids: getSelectedDocumentIds(),
                    timestamp: new Date().toISOString()
                });
                
                // Remove failed streaming message
                if (streamingMessageDiv.parentNode) {
                    streamingMessageDiv.parentNode.removeChild(streamingMessageDiv);
                }
                
                // Detailed error message based on error type
                let errorMessage = '❌ 오류가 발생했습니다: ';
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMessage += '서버에 연결할 수 없습니다. 서버가 실행 중인지 확인해주세요.';
                } else if (error.name === 'AbortError' || error.message.includes('aborted')) {
                    // Don't show error for deliberate abortion - stopStreaming() already handles this
                    console.log('Stream was aborted by user');
                    return;
                } else if (error.message.includes('timeout')) {
                    errorMessage += '요청 시간이 초과되었습니다. 다시 시도해주세요.';
                } else if (error.message.includes('HTTP error')) {
                    errorMessage += `서버 오류 (${error.message})`;
                } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                    errorMessage += '네트워크 연결을 확인해주세요.';
                } else {
                    errorMessage += error.message || '알 수 없는 오류';
                }
                
                appendMessage('bot', errorMessage);
                chatStatus.className = 'status-message status-error';
                chatStatus.textContent = errorMessage;
            } finally {
                // Small delay to ensure progress update is visible before hiding
                setTimeout(() => {
                    hideChatProgress();
                }, 500);
                sendButton.disabled = false;
                
                // Hide stop button and restore send button
                hideStopButton();
                
                // 모델 활동 상태를 '대기중'으로 복귀
                updateModelActivity('idle');
            }
        }

        sendButton.addEventListener('click', () => {
            console.log('Send button clicked, isStreaming:', isStreaming);
            if (isStreaming) {
                console.log('Calling stopStreaming()');
                stopStreaming();
            } else {
                console.log('Calling sendMessage()');
                sendMessage();
            }
        });
        
        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !isStreaming) {
                sendMessage();
            }
        });

        // New chat button functionality
        const newChatButton = document.getElementById('new-chat-button');
        newChatButton.addEventListener('click', startNewConversation);

        function startNewConversation() {
            // Clear chat history
            chatHistory.innerHTML = '';
            
            // Clear conversation history
            clearConversationHistory();
            
            // Clear any status messages
            const chatStatus = document.getElementById('chat-status');
            if (chatStatus) {
                chatStatus.textContent = '';
                chatStatus.className = 'status-message';
            }
            
            // Hide any progress indicators
            const progressEl = document.getElementById('chat-progress');
            if (progressEl) {
                progressEl.classList.remove('active');
                if (progressEl.timerInterval) {
                    clearInterval(progressEl.timerInterval);
                    progressEl.timerInterval = null;
                    progressEl.startTime = null;
                }
            }
            
            // Show welcome message again
            showWelcomeMessage();
            
            // Focus on input
            chatInput.focus();
        }

        async function showWelcomeMessage() {
            try {
                // API에서 랜덤 환영메시지 가져오기
                const response = await fetch('/api/welcome-messages/random');
                const data = await response.json();
                
                if (response.ok && data.message) {
                    appendMessage('bot', data.message, true);
                    console.log('🎯 동적 환영메시지 로드됨:', data.message.slice(0, 50) + '...');
                } else {
                    // API 실패 시 기본 메시지
                    showDefaultWelcomeMessage();
                }
            } catch (error) {
                console.error('환영메시지 로드 실패:', error);
                // 네트워크 오류 시 기본 메시지
                showDefaultWelcomeMessage();
            }
        }
        
        function showDefaultWelcomeMessage() {
            const welcomeMessage = `📚 안녕하세요! 업로드된 문서들에 대해 궁금한 것이 있으시면 언제든 물어보세요.`;
            appendMessage('bot', welcomeMessage, true);
        }

        function showStopButton() {
            console.log('Showing stop button, setting isStreaming = true');
            isStreaming = true;
            sendButton.innerHTML = '🛑 중지';
            sendButton.style.backgroundColor = '#dc3545';
            sendButton.disabled = false; // Re-enable button for stop functionality
            
            // Debug button state
            console.log('Button element:', sendButton);
            console.log('Button disabled:', sendButton.disabled);
            console.log('Button innerHTML:', sendButton.innerHTML);
            console.log('Stop button shown, currentStreamAbortController:', currentStreamAbortController);
        }

        function hideStopButton() {
            console.log('Hiding stop button, setting isStreaming = false');
            isStreaming = false;
            sendButton.innerHTML = '💬 전송';
            sendButton.style.backgroundColor = '';
            sendButton.disabled = false;
            currentStreamAbortController = null;
            
            // 스트리밍 완료 시 모든 메시지의 THINK 블록을 최종 상태로 설정 (강력한 처리)
            setTimeout(() => {
                const allMessages = chatHistory.querySelectorAll('.bot-message, .message');
                allMessages.forEach(messageElement => {
                    const accordions = messageElement.querySelectorAll('.thinking-accordion');
                    if (accordions.length > 0) {
                        accordions.forEach(accordion => {
                            // 강제로 접힘 상태 설정
                            accordion.removeAttribute('open');
                            accordion.open = false;
                            
                            // 이벤트 핸들러 설정
                            setupThinkBlockToggle(accordion);
                            
                            // 상태 텍스트 업데이트
                            const statusSpan = accordion.querySelector('summary span:last-child');
                            if (statusSpan) {
                                statusSpan.textContent = '(완료)';
                                statusSpan.style.color = '#28a745';
                            }
                        });
                        console.log(`hideStopButton에서 ${accordions.length}개 THINK 블록 최종 처리 완료`);
                    }
                });
            }, 200);
        }

        function stopStreaming() {
            console.log('stopStreaming called, currentStreamAbortController:', currentStreamAbortController);
            if (currentStreamAbortController) {
                console.log('Aborting current stream...');
                currentStreamAbortController.abort();
                
                // Remove any streaming message placeholders and clean up cursors
                const streamingMessages = document.querySelectorAll('.message.streaming');
                streamingMessages.forEach(msg => {
                    // Remove typing cursor from the message before removing the message
                    const cursor = msg.querySelector('.typing-cursor');
                    if (cursor) {
                        cursor.remove();
                    }
                    msg.remove();
                });
                
                // Show stopped message
                appendMessage('bot', '⚠️ 응답 생성이 중지되었습니다.');
                
                // Clean up UI
                hideStopButton();
                
                // Clear status and progress
                chatStatus.textContent = '';
                chatStatus.className = 'status-message';
                
                const progressEl = document.getElementById('chat-progress');
                if (progressEl) {
                    progressEl.classList.remove('active');
                    if (progressEl.timerInterval) {
                        clearInterval(progressEl.timerInterval);
                        progressEl.timerInterval = null;
                        progressEl.startTime = null;
                    }
                }
                
                // Re-enable input and model activity
                chatInput.disabled = false;
                sendButton.disabled = false;
                updateModelActivity('idle');
            }
        }

        function appendMessage(sender, text, isMarkdown=false) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
            if(isMarkdown && window.marked) {
                let parsedHTML = window.marked.parse(text);
                if (sender === 'bot') {
                    parsedHTML = enhanceMarkdownRendering(parsedHTML);
                }
                messageDiv.innerHTML = parsedHTML;
            } else {
                messageDiv.textContent = text;
            }
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight; // Scroll to bottom
            
            // 대화 히스토리에 저장 (시스템 메시지 제외)
            if (sender === 'user') {
                addToConversationHistory('user', text);
            } else if (sender === 'bot' && !text.includes('⚠️') && !text.includes('❌') && !text.includes('안녕하세요! 👋')) {
                // 에러 메시지나 웰컴 메시지는 히스토리에서 제외
                addToConversationHistory('assistant', text);
            }
        }
        
        function createEnhancedMultimodalMessage(result) {
            console.log('Creating enhanced multimodal message:', { cached: result.cached, responseLength: result.response?.length });
            
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'bot-message', 'multimodal-message');
            
            // Add cache indicator if applicable
            if (result.cached) {
                messageDiv.classList.add('cached-message');
                const cacheIndicator = document.createElement('div');
                cacheIndicator.classList.add('cache-indicator');
                cacheIndicator.innerHTML = '💾 캐시된 응답 (구조화 완료)';
                messageDiv.appendChild(cacheIndicator);
            }
            
            // 메인 답변 텍스트 (캐시된 응답에 대해 강제 마크다운 처리)
            const responseDiv = document.createElement('div');
            responseDiv.classList.add('response-text');
            
            // Force markdown parsing for all responses, especially cached ones
            if (window.marked && result.response) {
                try {
                    console.log('Applying markdown to response:', { 
                        cached: result.cached, 
                        responseLength: result.response.length,
                        preview: result.response.substring(0, 100),
                        markedAvailable: !!window.marked
                    });
                    
                    // Configure marked with enhanced options for better formatting
                    if (window.marked.setOptions) {
                        window.marked.setOptions({
                            breaks: true,           // 줄바꿈 처리
                            gfm: true,             // GitHub Flavored Markdown
                            tables: true,          // 표 지원
                            pedantic: false,       // 엄격하지 않은 파싱
                            sanitize: false,       // HTML 허용
                            smartLists: true,      // 똑똑한 리스트 처리
                            smartypants: false     // 따옴표 변환 비활성화
                        });
                    }
                    
                    // For cached responses, ensure proper markdown parsing - THINK 블록 필터링 적용
                    const filteredResponse = styleThinkBlocks(result.response);
                    let parsedHtml = window.marked.parse(filteredResponse);
                    parsedHtml = enhanceMarkdownRendering(parsedHtml);
                    responseDiv.innerHTML = parsedHtml;
                    
                    // Apply additional styling for tables and code blocks
                    responseDiv.querySelectorAll('table').forEach(table => {
                        table.style.cssText = 'border-collapse: collapse; width: 100%; margin: 1rem 0;';
                        table.querySelectorAll('th, td').forEach(cell => {
                            cell.style.cssText = 'border: 1px solid #ddd; padding: 8px; text-align: left;';
                        });
                        table.querySelectorAll('th').forEach(header => {
                            header.style.cssText += 'background-color: #f2f2f2; font-weight: bold;';
                        });
                    });
                    
                    // Style code blocks
                    responseDiv.querySelectorAll('pre').forEach(pre => {
                        pre.style.cssText = 'background-color: #f8f9fa; padding: 1rem; border-radius: 4px; overflow-x: auto; border-left: 4px solid #007bff;';
                    });
                    
                    console.log('Markdown parsing successful, HTML length:', parsedHtml.length);
                    
                } catch (markdownError) {
                    console.error('Markdown parsing failed:', markdownError);
                    const filteredResponse = styleThinkBlocks(result.response);
                    responseDiv.textContent = filteredResponse;
                }
            } else {
                console.warn('Marked not available or no response text');
                const filteredResponse = styleThinkBlocks(result.response || '');
                responseDiv.textContent = filteredResponse;
            }
            messageDiv.appendChild(responseDiv);
            
            // Content summary removed - now handled by streaming service with accordion format
            
            // Media references - 현재 개발 중으로 숨김 처리
            /* 참조 이미지/표 기능은 현재 개발 중입니다
            if (result.media_references && result.media_references.has_media) {
                const mediaDiv = document.createElement('div');
                mediaDiv.classList.add('media-content');
                mediaDiv.style.display = 'none'; // 임시 숨김
                
                // Referenced images
                if (result.media_references.images && result.media_references.images.length > 0) {
                    const imagesDiv = document.createElement('div');
                    imagesDiv.classList.add('referenced-media');
                    imagesDiv.innerHTML = '<h4>🖼️ 참조된 이미지</h4>';
                    
                    result.media_references.images.forEach(img => {
                        const imgContainer = document.createElement('div');
                        imgContainer.classList.add('media-item');
                        imgContainer.innerHTML = `
                            <img src="${img.path}" alt="${img.metadata || 'Referenced image'}" 
                                 loading="lazy" style="max-width: 300px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div class="media-caption">${img.metadata || '이미지'}</div>
                        `;
                        imagesDiv.appendChild(imgContainer);
                    });
                    mediaDiv.appendChild(imagesDiv);
                }
                
                // Referenced tables
                if (result.media_references.tables && result.media_references.tables.length > 0) {
                    const tablesDiv = document.createElement('div');
                    tablesDiv.classList.add('referenced-media');
                    tablesDiv.innerHTML = '<h4>📋 참조된 표</h4>';
                    
                    result.media_references.tables.forEach(table => {
                        const tableContainer = document.createElement('div');
                        tableContainer.classList.add('media-item');
                        tableContainer.innerHTML = `
                            <img src="${table.path}" alt="${table.metadata || 'Referenced table'}" 
                                 loading="lazy" style="max-width: 400px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div class="media-caption">${table.metadata || '표'}</div>
                        `;
                        tablesDiv.appendChild(tableContainer);
                    });
                    mediaDiv.appendChild(tablesDiv);
                }
                
                messageDiv.appendChild(mediaDiv);
            }
            */
            
            return messageDiv;
        }

        function appendMultimodalMessage(sender, result) {
            const messageDiv = createEnhancedMultimodalMessage(result);
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // Enhanced chat progress functions with real-time status updates
        function showChatProgress() {
            const progressEl = document.getElementById('chat-progress');
            const progressMessage = document.getElementById('chat-progress-message');
            
            progressEl.classList.add('active');
            
            // Reset all steps
            document.querySelectorAll('.progress-step').forEach(step => {
                step.classList.remove('active', 'completed');
            });
            
            // Start with query analysis step - wait for backend status
            updateProgressStep('query', '질문을 분석하고 있습니다...');
            
            // Don't auto-complete query step - let backend control progression
        }
        
        function updateProgressStep(stepName, message, details = {}) {
            // Ensure details is always an object
            if (!details || typeof details !== 'object') {
                details = {};
            }
            const progressEl = document.getElementById('chat-progress');
            const progressMainText = document.getElementById('progress-main-text');
            const steps = ['query', 'embedding', 'search', 'generate'];
            
            console.log(`📊 Progress Update: ${stepName} - ${message}`, details);
            
            // Update main progress text
            if (progressMainText) {
                progressMainText.textContent = message;
            }
            
            // Update timer (처음에만 시작, 이후에는 유지)
            if (!progressEl.startTime) {
                progressEl.startTime = Date.now();
                progressEl.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - progressEl.startTime) / 1000);
                    const timerEl = document.getElementById('progress-timer');
                    if (timerEl) {
                        timerEl.textContent = `${elapsed}초`;
                    }
                }, 1000);
            }
            
            // Mark previous steps as completed (강제로 모든 애니메이션 제거)
            const currentIndex = steps.indexOf(stepName);
            for (let i = 0; i < currentIndex; i++) {
                const stepEl = document.querySelector(`[data-step="${steps[i]}"]`);
                if (stepEl) {
                    // 강제로 모든 상태 제거하고 completed 상태로 설정
                    stepEl.classList.remove('active', 'pending');
                    stepEl.classList.add('completed');
                    
                    // 스피너 제거하고 체크 마크로 교체
                    const statusEl = stepEl.querySelector('.step-status');
                    if (statusEl) {
                        statusEl.innerHTML = '<div class="step-check">✓</div>';
                    }
                    
                    // 아이콘에서도 애니메이션 제거
                    const iconEl = stepEl.querySelector('.progress-step-icon');
                    if (iconEl) {
                        iconEl.style.animation = 'none';
                    }
                    
                    console.log(`✅ Force completed ${steps[i]}`);
                }
            }
            
            // Mark current step as active or completed based on message
            const currentStepEl = document.querySelector(`[data-step="${stepName}"]`);
            if (currentStepEl) {
                // Check if this step is completed (based on message keywords)
                const isCompleted = message.includes('완료') || message.includes('Done') || message.includes('Completed');
                
                if (isCompleted) {
                    // Mark as completed
                    currentStepEl.classList.remove('active', 'pending');
                    currentStepEl.classList.add('completed');
                    
                    // Update status to completed (remove spinner, add check)
                    const statusEl = document.getElementById(`${stepName}-status`);
                    if (statusEl) {
                        statusEl.innerHTML = '<div class="step-check">✓</div>';
                    }
                    
                    console.log(`✅ Marked ${stepName} as completed: ${message}`);
                } else {
                    // Mark as active (in progress)
                    currentStepEl.classList.remove('completed', 'pending');
                    currentStepEl.classList.add('active');
                    
                    // Update step status with spinner (현재 단계만)
                    const statusEl = document.getElementById(`${stepName}-status`);
                    if (statusEl) {
                        const spinnerHtml = '<div class="step-spinner"></div>';
                        statusEl.innerHTML = spinnerHtml;
                    }
                    
                    // 현재 단계 아이콘에만 애니메이션 적용
                    const iconEl = currentStepEl.querySelector('.progress-step-icon');
                    if (iconEl) {
                        iconEl.style.animation = ''; // 기본 애니메이션 복원
                    }
                    
                    console.log(`🔄 Marked ${stepName} as active: ${message}`);
                }
                
                // Special handling for generate step
                if (stepName === 'generate' && details && details.responseLength) {
                    const responseLengthEl = document.getElementById('response-length');
                    if (responseLengthEl) {
                        responseLengthEl.textContent = `${details.responseLength}자`;
                        responseLengthEl.style.display = 'inline-block';
                    }
                }
            }
            
            // Mark future steps as pending (애니메이션 없이)
            for (let i = currentIndex + 1; i < steps.length; i++) {
                const stepEl = document.querySelector(`[data-step="${steps[i]}"]`);
                if (stepEl) {
                    stepEl.classList.remove('active', 'completed');
                    stepEl.classList.add('pending');
                    
                    // 미래 단계 아이콘 애니메이션 제거
                    const iconEl = stepEl.querySelector('.progress-step-icon');
                    if (iconEl) {
                        iconEl.style.animation = 'none';
                    }
                    
                    // 미래 단계 스피너 제거
                    const statusEl = stepEl.querySelector('.step-status');
                    if (statusEl) {
                        statusEl.innerHTML = '';
                    }
                }
            }
            
            // Update message with typing effect for generate step
            if (stepName === 'generate' && message.includes('생성하고 있습니다')) {
                if (progressMainText) {
                    showTypingEffect(progressMainText, message);
                }
            } else {
                if (progressMainText) {
                    progressMainText.textContent = message;
                }
            }
        }
        
        function showTypingEffect(element, baseMessage) {
            let dots = 0;
            const typingInterval = setInterval(() => {
                dots = (dots + 1) % 4;
                element.textContent = baseMessage + '.'.repeat(dots);
            }, 500);
            
            // Store interval for cleanup
            const progressEl = document.getElementById('chat-progress');
            progressEl.typingInterval = typingInterval;
        }
        
        function updateResponseProgress(wordCount, estimatedTotal) {
            const message = `답변 생성 중... (${wordCount}/${estimatedTotal} 단어)`;
            updateChatProgressStep('generate', message);
        }
        
        // 즉시 진행상황 초기화 함수 (동일 질문 시 깨끗한 시작을 위해)
        function resetChatProgress() {
            const progressEl = document.getElementById('chat-progress');
            if (!progressEl) return;
            
            // 즉시 모든 타이머 정리
            if (progressEl.timerInterval) {
                clearInterval(progressEl.timerInterval);
                progressEl.timerInterval = null;
            }
            if (progressEl.stepInterval) {
                clearInterval(progressEl.stepInterval);
                progressEl.stepInterval = null;
            }
            if (progressEl.typingInterval) {
                clearInterval(progressEl.typingInterval);
                progressEl.typingInterval = null;
            }
            
            // 즉시 상태 초기화
            progressEl.classList.remove('active', 'completing');
            progressEl.startTime = null;
            
            // 모든 단계 초기화 (애니메이션 완전 제거)
            document.querySelectorAll('.progress-step').forEach(step => {
                step.classList.remove('active', 'completed', 'pending');
                
                // 모든 아이콘 애니메이션 강제 제거
                const iconEl = step.querySelector('.progress-step-icon');
                if (iconEl) {
                    iconEl.style.animation = 'none';
                }
                
                // 모든 스피너 제거
                const statusEl = step.querySelector('.step-status');
                if (statusEl) {
                    statusEl.innerHTML = '';
                }
            });
            
            // 진행률 초기화
            const progressMainText = document.getElementById('progress-main-text');
            if (progressMainText) progressMainText.textContent = 'AI 답변 생성 중...';
        }

        function hideChatProgress() {
            const progressEl = document.getElementById('chat-progress');
            
            // Add completion animation before hiding
            progressEl.classList.add('completing');
            
            // Update final status
            const progressMainText = document.getElementById('progress-main-text');
            if (progressMainText) progressMainText.textContent = '답변 생성 완료! 🎉';
            
            // Mark all steps as completed
            document.querySelectorAll('.progress-step').forEach(step => {
                step.classList.remove('active', 'pending');
                step.classList.add('completed');
                const statusEl = step.querySelector('.step-status');
                if (statusEl) {
                    statusEl.innerHTML = '<div class="step-check">✓</div>';
                }
            });
            
            // Clear timers
            if (progressEl.timerInterval) {
                clearInterval(progressEl.timerInterval);
                progressEl.timerInterval = null;
            }
            if (progressEl.stepInterval) {
                clearInterval(progressEl.stepInterval);
                progressEl.stepInterval = null;
            }
            if (progressEl.typingInterval) {
                clearInterval(progressEl.typingInterval);
                progressEl.typingInterval = null;
            }
            
            // Hide after animation
            setTimeout(() => {
                progressEl.classList.remove('active', 'completing');
                
                // Reset for next use (동일한 로직을 resetChatProgress로 위임)
                setTimeout(() => {
                    resetChatProgress();
                }, 500);
            }, 1500);
        }

        // 채팅 전용 진행률 업데이트 함수 (단순화)
        function updateChatProgressStep(step, message = '', details = {}) {
            // 채팅 진행률은 문서 처리 진행률과 분리하여 업데이트
            if (document.getElementById('progress-container') && 
                document.getElementById('progress-container').style.display !== 'none') {
                // 문서 처리 중이면 채팅 진행률 업데이트하지 않음
                return;
            }
            
            // 새로운 단계로 진행할 때 이전 단계들을 조용히 완료 처리
            const steps = ['query', 'embedding', 'search', 'generate'];
            const currentStepIndex = steps.indexOf(step);
            
            // 현재 단계 이전의 모든 단계를 완료 상태로 마킹 (UI 업데이트 없이)
            for (let i = 0; i < currentStepIndex; i++) {
                const prevStep = document.querySelector(`.progress-step[data-step="${steps[i]}"]`);
                if (prevStep && !prevStep.classList.contains('completed')) {
                    prevStep.classList.remove('active');
                    prevStep.classList.add('completed');
                    console.log(`✅ Silently completing previous step: ${steps[i]}`);
                }
            }
            
            // 현재 단계 업데이트
            updateProgressStep(step, message, 0, details);
        }
        
        // 단계명 반환 헬퍼 함수
        function getStepName(step) {
            const stepNames = {
                'query': '질문분석',
                'embedding': '임베딩',
                'search': '문서검색',
                'generate': '답변생성'
            };
            return stepNames[step] || step;
        }

        // Ollama 상태 및 모델 목록 불러오기
        async function fetchOllamaStatusAndModels() {
            const statusEl = document.getElementById('ollama-status');
            // 상태
            try {
                const res = await fetch('/api/ollama/status');
                const data = await res.json();
                const status = data.status === 'running' ? '✅ 실행 중' : (data.status === 'not running' ? '❌ 중지됨' : '❓ ' + data.status);
                statusEl.textContent = 'Ollama 상태: ' + status;
                statusEl.className = 'status-display ' + (data.status === 'running' ? 'status-running' : 'status-stopped');
            } catch (e) {
                statusEl.textContent = 'Ollama 상태: ❌ 확인 실패';
                statusEl.className = 'status-display status-stopped';
            }
            // 모델 목록
            try {
                const res = await fetch('/api/ollama/models');
                const data = await res.json();
                const select = document.getElementById('ollama-models');
                
                // 현재 선택된 모델 저장 (있다면)
                const currentSelected = select.value;
                
                select.innerHTML = '';
                if (data.models && data.models.length > 0) {
                    let qwenFound = false;
                    let defaultModel = null;
                    
                    data.models.forEach((model, index) => {
                        const opt = document.createElement('option');
                        opt.value = model;
                        opt.textContent = formatModelName(model);
                        select.appendChild(opt);
                        
                        // qwen3:30b-a3b 모델 찾기 (우선 선택)
                        if (!qwenFound && model.toLowerCase().includes('qwen3:30b-a3b')) {
                            qwenFound = true;
                            defaultModel = model;
                        }
                        // qwen 계열 모델 찾기 (두 번째 우선순위)
                        else if (!qwenFound && !defaultModel && model.toLowerCase().includes('qwen')) {
                            defaultModel = model;
                        }
                        
                        // 첫 번째 모델을 백업으로 저장
                        if (!defaultModel) {
                            defaultModel = model;
                        }
                        
                        // 이전에 선택된 모델이 있으면 그것을 선택
                        if (currentSelected && model === currentSelected) {
                            opt.selected = true;
                        }
                    });
                    
                    // 이전 선택이 없으면 Gemma 모델 또는 첫 번째 모델 선택
                    if (!currentSelected && defaultModel) {
                        select.value = defaultModel;
                        // 해당 옵션을 선택 상태로 만들기
                        const targetOption = select.querySelector(`option[value="${defaultModel}"]`);
                        if (targetOption) {
                            targetOption.selected = true;
                        }
                    }
                    
                    // 현재 선택된 모델 표시 업데이트
                    updateSelectedModelDisplay();
                } else {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = '모델 없음';
                    select.appendChild(opt);
                }
            } catch (e) {
                const select = document.getElementById('ollama-models');
                select.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = '모델 목록 불러오기 실패';
                select.appendChild(opt);
            }
        }
        function getSelectedModel() {
            const select = document.getElementById('ollama-models');
            return select.value;
        }
        
        // 모델명 간단하게 포맷
        function formatModelName(fullModelName) {
            if (!fullModelName) return fullModelName;
            
            // 일반적인 패턴들 처리
            const patterns = [
                // llama2:7b -> Llama2 (7B)
                { regex: /^(\w+):(\d+\.?\d*b?)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // qwen2:1.5b -> Qwen2 (1.5B)
                { regex: /^(\w+\d*):(\d+\.?\d*b?)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // gemma:2b-instruct -> Gemma (2B-Instruct)
                { regex: /^(\w+):(\d+\.?\d*b?-?\w*)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // llama2:latest -> Llama2 (Latest)
                { regex: /^(\w+):latest$/i, format: (match) => `${capitalize(match[1])} (Latest)` },
                // codellama:13b-code -> CodeLlama (13B-Code)
                { regex: /^(\w+):(\d+\.?\d*b?-?\w*)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
            ];
            
            for (const pattern of patterns) {
                const match = fullModelName.match(pattern.regex);
                if (match) {
                    return pattern.format(match);
                }
            }
            
            // 매칭되지 않는 경우 첫 번째 부분만 사용하거나 전체 이름 사용
            if (fullModelName.includes(':')) {
                const parts = fullModelName.split(':');
                return `${capitalize(parts[0])} (${parts[1]})`;
            }
            
            return capitalize(fullModelName);
        }
        
        // 첫 글자를 대문자로 변환
        function capitalize(str) {
            if (!str) return str;
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        // 현재 선택된 모델 표시 업데이트
        function updateSelectedModelDisplay() {
            const select = document.getElementById('ollama-models');
            const selectedModel = select.value;
            
            if (selectedModel) {
                select.style.color = '#495057';
                select.style.fontWeight = '500';
                
                // 모델 정보 업데이트
                updateModelInfo(selectedModel);
            }
        }
        
        // 모델 정보 업데이트 (개선된 버전)
        function updateModelInfo(modelName) {
            const modelInfoEl = document.getElementById('model-info');
            const activityEl = document.getElementById('model-activity');
            
            if (!modelName) {
                modelInfoEl.textContent = '모델 선택되지 않음';
                activityEl.style.display = 'none';
                return;
            }
            
            // 모델 상세 정보 추정
            const modelInfo = getModelInfo(modelName);
            modelInfoEl.innerHTML = `
                <div style="line-height: 1.3;">
                    <div style="font-weight: 600; color: #2c3e50; font-size: 0.9em;">
                        ${modelInfo.vendor} • ${modelInfo.size}
                    </div>
                    <div style="font-size: 0.75em; color: #6c757d;">
                        ${modelInfo.type} • ${modelInfo.language}
                    </div>
                </div>
            `;
            
            // 작동 상태 표시
            activityEl.style.display = 'flex';
            updateModelActivity('idle');
        }
        
        // 모델 정보 추정 (개선된 버전)
        function getModelInfo(modelName) {
            const name = modelName.toLowerCase();
            
            // 제작사 추정
            let vendor = 'Unknown';
            if (name.includes('llama')) vendor = 'Meta';
            else if (name.includes('gemma')) vendor = 'Google';
            else if (name.includes('qwen')) vendor = 'Alibaba';
            else if (name.includes('mistral')) vendor = 'Mistral AI';
            else if (name.includes('phi')) vendor = 'Microsoft';
            else if (name.includes('codellama')) vendor = 'Meta';
            else if (name.includes('vicuna')) vendor = 'LMSYS';
            else if (name.includes('alpaca')) vendor = 'Stanford';
            else if (name.includes('wizardlm')) vendor = 'WizardLM';
            else if (name.includes('nous')) vendor = 'Nous Research';
            
            // 크기 추정
            let size = '크기 불명';
            if (name.includes('0.5b')) size = '0.5B';
            else if (name.includes('1b')) size = '1B';
            else if (name.includes('1.5b')) size = '1.5B';
            else if (name.includes('2b')) size = '2B';
            else if (name.includes('3b')) size = '3B';
            else if (name.includes('7b')) size = '7B';
            else if (name.includes('8b')) size = '8B';
            else if (name.includes('9b')) size = '9B';
            else if (name.includes('13b')) size = '13B';
            else if (name.includes('14b')) size = '14B';
            else if (name.includes('20b')) size = '20B';
            else if (name.includes('30b') || name.includes('33b')) size = '30B+';
            else if (name.includes('70b')) size = '70B';
            else if (name.includes('180b')) size = '180B';
            
            // 타입 추정
            let type = '일반형';
            if (name.includes('instruct')) type = '지시 특화';
            else if (name.includes('chat')) type = '대화 특화';
            else if (name.includes('code')) type = '코딩 특화';
            else if (name.includes('vision')) type = '비전 모델';
            else if (name.includes('math')) type = '수학 특화';
            else if (name.includes('reasoning')) type = '추론 특화';
            
            // 언어 지원 추정
            let language = '다국어';
            if (name.includes('ko') || name.includes('korean')) language = '한국어 특화';
            else if (name.includes('en') || name.includes('english')) language = '영어 특화';
            else if (name.includes('zh') || name.includes('chinese')) language = '중국어 특화';
            else if (name.includes('jp') || name.includes('japanese')) language = '일본어 특화';
            
            return { vendor, size, type, language };
        }
        
        // 모델 활동 상태 업데이트
        function updateModelActivity(status, progress = 0) {
            const gauge = document.getElementById('activity-gauge');
            const text = document.getElementById('activity-text');
            
            if (!gauge || !text) return;
            
            switch(status) {
                case 'idle':
                    gauge.style.background = 'conic-gradient(#6c757d 0deg, #e9ecef 0deg)';
                    text.textContent = '대기중';
                    text.style.color = '#6c757d';
                    break;
                case 'active':
                    const angle = (progress / 100) * 360;
                    gauge.style.background = `conic-gradient(#28a745 ${angle}deg, #e9ecef ${angle}deg)`;
                    text.textContent = '활성';
                    text.style.color = '#28a745';
                    break;
                case 'processing':
                    gauge.style.background = 'conic-gradient(#007bff 0deg, #007bff 90deg, #e9ecef 90deg, #e9ecef 180deg, #007bff 180deg, #007bff 270deg, #e9ecef 270deg)';
                    gauge.style.animation = 'spin 1s linear infinite';
                    text.textContent = '처리중';
                    text.style.color = '#007bff';
                    break;
                case 'error':
                    gauge.style.background = 'conic-gradient(#dc3545 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = '오류';
                    text.style.color = '#dc3545';
                    break;
            }
        }
        
        // 문서 처리 상태 업데이트
        function updateProcessingActivity(status, progress = 0) {
            const gauge = document.getElementById('processing-gauge');
            const text = document.getElementById('processing-text');
            
            if (!gauge || !text) return;
            
            switch(status) {
                case 'idle':
                    gauge.style.background = 'conic-gradient(#6c757d 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = '대기중';
                    text.style.color = '#6c757d';
                    break;
                case 'processing':
                    // 진행률이 제공된 경우 진행률 표시, 아니면 스피너 애니메이션
                    if (progress > 0) {
                        const angle = (progress / 100) * 360;
                        gauge.style.background = `conic-gradient(#007bff ${angle}deg, #e9ecef ${angle}deg)`;
                        gauge.style.animation = 'none';
                        text.textContent = `처리중 ${Math.round(progress)}%`;
                    } else {
                        gauge.style.background = 'conic-gradient(#007bff 0deg, #007bff 90deg, #e9ecef 90deg, #e9ecef 180deg, #007bff 180deg, #007bff 270deg, #e9ecef 270deg)';
                        gauge.style.animation = 'spin 1s linear infinite';
                        text.textContent = '처리중';
                    }
                    text.style.color = '#007bff';
                    break;
                case 'completed':
                    const angle = (progress / 100) * 360;
                    gauge.style.background = `conic-gradient(#28a745 ${angle}deg, #e9ecef ${angle}deg)`;
                    gauge.style.animation = 'none';
                    text.textContent = '완료';
                    text.style.color = '#28a745';
                    break;
                case 'completed_with_errors':
                    const angleWarning = (progress / 100) * 360;
                    gauge.style.background = `conic-gradient(#ffc107 ${angleWarning}deg, #e9ecef ${angleWarning}deg)`;
                    gauge.style.animation = 'none';
                    text.textContent = '완료(오류)';
                    text.style.color = '#ffc107';
                    break;
                case 'error':
                    gauge.style.background = 'conic-gradient(#dc3545 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = '오류';
                    text.style.color = '#dc3545';
                    break;
            }
        }
        
        // 시스템 통계 업데이트
        async function updateSystemStats() {
            try {
                // 문서 목록 가져오기
                const docsRes = await fetch('/api/documents');
                const docsData = await docsRes.json();
                
                // 저장소 통계 가져오기
                const statsRes = await fetch('/api/storage/stats');
                const statsData = await statsRes.json();
                
                // UI 업데이트
                const docCount = docsData.documents ? docsData.documents.length : 0;
                const totalChunks = docsData.documents ? 
                    docsData.documents.reduce((sum, doc) => sum + (doc.chunk_count || 0), 0) : 0;
                
                document.getElementById('doc-count').textContent = docCount;
                document.getElementById('chunk-count').textContent = totalChunks;
                
                if (statsRes.ok && statsData.file_storage) {
                    const sizeMB = Math.round(statsData.file_storage.total_size_mb || 0);
                    document.getElementById('storage-size').textContent = `${sizeMB}MB`;
                }
                
                // 마지막 업데이트 시간
                const now = new Date();
                const timeStr = now.toLocaleTimeString('ko-KR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                document.getElementById('last-update').textContent = timeStr;
                
            } catch (error) {
                console.error('시스템 통계 업데이트 실패:', error);
            }
        }
        
        // 빠른 설정 토글 이벤트
        function setupQuickSettings() {
            // OCR 교정 토글
            const ocrToggle = document.getElementById('ocr-correction-toggle');
            ocrToggle.addEventListener('change', (e) => {
                console.log('OCR 교정:', e.target.checked ? '활성화' : '비활성화');
                // 실제 설정 변경 로직은 여기에 구현
            });
            
            // LLM 교정 토글
            const llmToggle = document.getElementById('llm-correction-toggle');
            llmToggle.addEventListener('change', (e) => {
                console.log('LLM 교정:', e.target.checked ? '활성화' : '비활성화');
                // 실제 설정 변경 로직은 여기에 구현
            });
            
            // 자동 새로고침 토글
            const autoRefreshToggle = document.getElementById('auto-refresh-toggle');
            autoRefreshToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    startDocumentListPolling();
                    updateAutoRefreshIndicator('활성화');
                } else {
                    stopDocumentListPolling();
                    updateAutoRefreshIndicator('비활성화');
                }
            });
            
            // 외부 접속 토글
            const externalAccessToggle = document.getElementById('external-access-toggle');
            const externalAccessBadge = document.getElementById('external-access-badge');
            externalAccessToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    console.log('외부 접속: 활성화');
                    externalAccessBadge.textContent = '🟢 활성';
                    externalAccessBadge.style.color = '#28a745';
                    externalAccessBadge.style.background = 'rgba(40, 167, 69, 0.1)';
                    externalAccessBadge.style.borderColor = 'rgba(40, 167, 69, 0.3)';
                    externalAccessBadge.title = '외부 API/웹 검색 허용됨';
                } else {
                    console.log('외부 접속: 비활성화');
                    externalAccessBadge.textContent = '🔴 차단';
                    externalAccessBadge.style.color = '#dc3545';
                    externalAccessBadge.style.background = 'rgba(220, 53, 69, 0.1)';
                    externalAccessBadge.style.borderColor = 'rgba(220, 53, 69, 0.3)';
                    externalAccessBadge.title = '외부 API/웹 검색 차단됨';
                }
                // 실제 설정 변경 로직은 여기에 구현
            });
        }
        
        // 페이지 로드 시 Ollama 상태/모델 목록 불러오기는 아래 DOMContentLoaded에서 처리

        // 프로그레스바 단계별 매핑
        const progressSteps = [
            { step: 'Preparing', percent: 0 },
            { step: 'Starting', percent: 1 },
            { step: 'Analyzing', percent: 10 },
            { step: 'OCR', percent: 50 },
            { step: 'text_preprocessing', percent: 56 },
            { step: 'text_splitting', percent: 58 },
            { step: 'chunk_validation', percent: 60 },
            { step: 'chunk_correction', percent: 61 },
            { step: 'chunk_preparation', percent: 62 },
            { step: 'Chunking', percent: 62 },
            { step: 'Embedding', percent: 65 },
            { step: 'Metadata', percent: 75 },
            { step: 'Storing', percent: 80 },
            { step: 'TextCorrection', percent: 85 },
            { step: 'Done', percent: 100 },
            { step: 'Completed', percent: 100 },
            { step: 'Error', percent: 100 },
        ];
        
        // CSS-safe documentId 생성 함수
        function createSafeId(documentId) {
            // 파일명의 공백, 특수문자를 언더스코어로 변환하고 CSS-safe하게 만듦
            return documentId.replace(/[^a-zA-Z0-9_-]/g, '_');
        }
        
        // 다중 파일 진행률 추적 변수들
        let multiFileTracking = {
            files: new Map(), // originalDocumentId -> {safeId, filename, status, interval, startTime}
            intervals: new Set(),
            hideTimeout: null
        };
        
        // 경과시간 포맷팅 함수
        function formatElapsedTime(startTime) {
            if (!startTime) return '';
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // 업로드 진행률 UI 숨기기 함수
        function hideUploadProgressUI() {
            // 개별 파일 업로드 진행률 목록 제거
            const progressList = document.getElementById('progress-list');
            if (progressList) {
                // 부드러운 페이드아웃 효과
                progressList.style.transition = 'opacity 0.5s ease';
                progressList.style.opacity = '0';
                
                setTimeout(() => {
                    progressList.remove();
                }, 500);
            }
            
            // 업로드 진행률 제목 제거 (progress-list와 함께 생성된 제목)
            const progressContainer = document.getElementById('progress-container');
            if (progressContainer) {
                const titleElements = progressContainer.querySelectorAll('h5');
                titleElements.forEach(title => {
                    if (title.textContent.includes('개별 파일 업로드 진행률')) {
                        title.style.transition = 'opacity 0.5s ease';
                        title.style.opacity = '0';
                        setTimeout(() => {
                            if (title.parentNode) {
                                title.remove();
                            }
                        }, 500);
                    }
                });
            }
            
            console.log('업로드 진행률 UI 숨김 처리 완료');
        }
        
        // 다중 파일 진행률 추적 시작
        function startMultiFileProgressTracking(files) {
            console.log('다중 파일 진행률 추적 시작:', files);
            
            // 진행률 컨테이너 표시
            const progressContainer = document.getElementById('progress-container');
            progressContainer.style.display = 'block';
            
            // 전체 진행률 바 표시
            const overallProgressBarContainer = document.getElementById('overall-progress-bar-container');
            if (overallProgressBarContainer) {
                overallProgressBarContainer.style.display = 'block';
            }
            
            // 업로드 진행률 창 숨기기 (문서 처리 시작) - 2초 후 부드럽게 사라짐
            setTimeout(() => {
                hideUploadProgressUI();
            }, 2000);
            
            // 기존 데이터 정리
            clearMultiFileTracking();
            
            // 전체 진행률 초기화
            updateOverallProgress(0, files.length);
            
            // 개별 파일 진행률 UI 생성 및 추적 시작
            files.forEach(file => {
                createIndividualProgressUI(file.documentId, file.filename);
                startIndividualFileTracking(file.documentId, file.filename);
            });
        }
        
        // 개별 파일 진행률 UI 생성 (동적 스타일)
        function createIndividualProgressUI(documentId, filename) {
            const container = document.getElementById('individual-progress-container');
            const safeId = createSafeId(documentId);
            
            const fileDiv = document.createElement('div');
            fileDiv.id = `progress-${safeId}`;
            fileDiv.className = 'file-progress-card';
            fileDiv.style.cssText = `
                margin-bottom: 15px; 
                padding: 15px; 
                border: 1px solid #dee2e6; 
                border-radius: 12px; 
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.05);
                transition: all 0.3s ease;
            `;
            
            fileDiv.innerHTML = `
                <!-- 파일 헤더 -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div id="file-icon-${safeId}" style="font-size: 1.2em;">📄</div>
                        <div style="display: flex; flex-direction: column;">
                            <span style="font-weight: 600; color: #2c3e50; font-size: 1rem; max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${filename}">${filename}</span>
                            <span style="font-size: 0.8em; color: #6c757d;">문서 처리 중...</span>
                        </div>
                    </div>
                    <div id="status-badge-${safeId}" class="status-badge status-waiting">
                        <span id="status-text-${safeId}">대기 중</span>
                    </div>
                </div>
                
                <!-- 처리 단계 표시 (동적) -->
                <div id="process-steps-${safeId}" class="process-steps-dynamic">
                    <!-- 현재 처리 중인 단계만 표시됩니다 -->
                </div>
                
                <!-- 진행률 바 (전체) -->
                <div style="margin-top: 10px;">
                    <div style="height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">
                        <div id="progress-bar-${safeId}" style="height: 100%; width: 0%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.3s ease;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.85em; color: #6c757d;">
                        <span id="progress-text-${safeId}">0%</span>
                        <span id="time-info-${safeId}"></span>
                    </div>
                </div>
            `;
            
            container.appendChild(fileDiv);
        }
        
        // 개별 파일 진행률 추적
        function startIndividualFileTracking(documentId, filename) {
            const startTime = Date.now(); // 처리 시작 시간 기록
            let retryCount = 0;
            const maxRetries = 20; // 최대 20번 재시도로 증가 (약 30초)
            const safeId = createSafeId(documentId); // CSS-safe ID 생성
            
            // 백그라운드 처리 시작을 위해 2초 지연 후 상태 조회 시작 (3초→2초 단축)
            setTimeout(() => {
                const interval = setInterval(async () => {
                    try {
                        const res = await fetch(`/api/upload_status/${documentId}`);
                        const data = await res.json();
                        
                        // 문서를 찾을 수 없는 경우 재시도 처리
                        if (data.step === 'Unknown' || data.message?.includes('찾을 수 없습니다')) {
                            retryCount++;
                            
                            // 진행상황 표시 업데이트
                            const progressElement = document.getElementById(`progress-${safeId}`);
                            if (progressElement) {
                                const processStepsContainer = progressElement.querySelector(`#process-steps-${safeId}`);
                                if (processStepsContainer) {
                                    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                                    processStepsContainer.innerHTML = `
                                        <div class="current-step-display waiting compact">
                                            <div class="step-icon waiting">⏳</div>
                                            <div class="step-text-compact">
                                                <span class="main-text">백그라운드 처리 시작 대기 중... (${retryCount}/${maxRetries} 시도, ${elapsedSeconds}초 경과)</span>
                                            </div>
                                        </div>
                                    `;
                                }
                            }
                            
                            console.log(`📋 Document ${documentId} not found, retry ${retryCount}/${maxRetries}... (${Math.floor((Date.now() - startTime) / 1000)}초 경과)`);
                            
                            // 최대 재시도 횟수 초과 시에만 중단
                            if (retryCount >= maxRetries) {
                                console.warn(`❌ Document ${documentId} not found after ${maxRetries} retries, stopping... (총 ${Math.floor((Date.now() - startTime) / 1000)}초 소요)`);
                                clearInterval(interval);
                                multiFileTracking.intervals.delete(interval);
                                
                                // UI에 실패 메시지 표시
                                if (progressElement) {
                                    const processStepsContainer = progressElement.querySelector(`#process-steps-${safeId}`);
                                    if (processStepsContainer) {
                                        processStepsContainer.innerHTML = `
                                            <div class="current-step-display error compact">
                                                <div class="step-icon error">❌</div>
                                                <div class="step-text-compact">
                                                    <span class="main-text">처리 시작 실패 - 백엔드 상태 확인 불가 (${Math.floor((Date.now() - startTime) / 1000)}초 소요)</span>
                                                </div>
                                            </div>
                                        `;
                                    }
                                    
                                    // 파일 카드를 에러 상태로 변경
                                    progressElement.className = 'file-progress-card error';
                                    
                                    const statusBadge = progressElement.querySelector(`#status-badge-${safeId}`);
                                    const statusText = progressElement.querySelector(`#status-text-${safeId}`);
                                    const fileIcon = progressElement.querySelector(`#file-icon-${safeId}`);
                                    const timeInfo = progressElement.querySelector(`#time-info-${safeId}`);
                                    
                                    if (statusBadge) statusBadge.className = 'status-badge status-error';
                                    if (statusText) statusText.textContent = '처리 실패';
                                    if (fileIcon) fileIcon.textContent = '❌';
                                    if (timeInfo) timeInfo.textContent = '실패';
                                }
                                
                                // 파일 추적에서 에러 상태로 마킹
                                const fileInfo = multiFileTracking.files.get(documentId);
                                if (fileInfo) {
                                    fileInfo.status = 'Error';
                                    fileInfo.completed = true; // 에러도 완료로 간주
                                }
                                updateOverallProgressFromFiles();
                                checkAllFilesCompleted(); // 완료 상태 체크
                                return;
                            }
                            
                            // 재시도 중이므로 함수 종료하고 다음 interval 대기
                            return;
                        }
                        
                        // 정상 응답 시 재시도 카운터 리셋
                        retryCount = 0;
                        
                        updateIndividualProgress(documentId, data);
                    
                    // 파일 상태 업데이트 - 백엔드 percent 값 우선 사용
                    const actualPercent = data.percent !== undefined ? data.percent : (progressSteps.find(s => s.step === data.step) || { percent: 0 }).percent;
                    const fileInfo = multiFileTracking.files.get(documentId) || {};
                    multiFileTracking.files.set(documentId, {
                        ...fileInfo,
                        filename,
                        status: data.step,
                        progress: actualPercent,
                        completed: data.step === 'Done' || data.step === 'Completed' || data.step === 'Error',
                        startTime: fileInfo.startTime || startTime // 시작 시간 유지
                    });
                        
                        // 전체 진행률 업데이트 (실시간)
                        updateOverallProgressFromFiles();
                        
                        if (data.step === 'Done' || data.step === 'Completed' || data.step === 'Error') {
                            clearInterval(interval);
                            multiFileTracking.intervals.delete(interval);
                            checkAllFilesCompleted();
                        }
                    } catch (error) {
                        console.error(`진행률 추적 오류 (${documentId}):`, error);
                        const progressElement = document.getElementById(`progress-${safeId}`);
                        if (progressElement) {
                            const processStepsContainer = progressElement.querySelector(`#process-steps-${safeId}`);
                            if (processStepsContainer) {
                                processStepsContainer.innerHTML = `
                                    <div class="current-step-display error compact">
                                        <div class="step-icon error">⚠️</div>
                                        <div class="step-text-compact">
                                            <span class="main-text">상태 확인 실패: ${error.message}</span>
                                        </div>
                                    </div>
                                `;
                            }
                        }
                    }
                }, 1500);
                
                multiFileTracking.intervals.add(interval);
                multiFileTracking.files.set(documentId, {
                    filename,
                    status: 'starting',
                    interval,
                    completed: false,
                    startTime: startTime // 시작 시간 저장
                });
            }, 3000); // 3초 지연 후 상태 조회 시작
        }
        
        // 개별 파일 진행률 업데이트 (동적 스타일)
        function updateIndividualProgress(documentId, data) {
            // 백엔드 percent 값을 우선 사용, 없으면 기본 단계별 값 사용
            const percent = data.percent !== undefined ? data.percent : (progressSteps.find(s => s.step === data.step) || { percent: 0 }).percent;
            const safeId = createSafeId(documentId); // CSS-safe ID 생성
            
            // 메인 UI 요소들 (CSS-safe ID 사용)
            const fileCard = document.getElementById(`progress-${safeId}`);
            const progressBar = document.getElementById(`progress-bar-${safeId}`);
            const statusBadge = document.getElementById(`status-badge-${safeId}`);
            const statusText = document.getElementById(`status-text-${safeId}`);
            const progressText = document.getElementById(`progress-text-${safeId}`);
            const timeInfo = document.getElementById(`time-info-${safeId}`);
            const fileIcon = document.getElementById(`file-icon-${safeId}`);
            
            // 진행률 바 업데이트 (실제 percent 값 사용, 0-100 범위 제한)
            const displayPercent = Math.max(0, Math.min(100, Math.round(percent)));
            if (progressBar) progressBar.style.width = displayPercent + '%';
            if (progressText) {
                // 페이지 정보가 있으면 추가 표시
                if (data.current_page && data.total_pages) {
                    progressText.textContent = `${displayPercent}% (${data.current_page}/${data.total_pages} 페이지)`;
                } else {
                    progressText.textContent = `${displayPercent}%`;
                }
            }
            
            // multiFileTracking의 파일 정보도 실시간으로 업데이트
            if (multiFileTracking.files.has(documentId)) {
                const fileInfo = multiFileTracking.files.get(documentId);
                fileInfo.progress = displayPercent;
                fileInfo.status = data.step;
                const wasCompleted = fileInfo.completed;
                fileInfo.completed = data.step === 'Done' || data.step === 'Completed' || data.step === 'Error';
                if (!wasCompleted && fileInfo.completed) {
                    console.log(`파일 ${documentId} 완료됨 (상태: ${data.step})`);
                }
                multiFileTracking.files.set(documentId, fileInfo);
            }
            
            // 프로세스 단계 업데이트 (상세 정보 포함)
            updateProcessSteps(documentId, data.step, data);
            
            if (data.step === 'Done' || data.step === 'Completed') {
                // 완료 상태
                if (fileCard) {
                    fileCard.className = 'file-progress-card completed';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-completed';
                }
                if (statusText) statusText.textContent = '완료';
                if (fileIcon) fileIcon.textContent = '✅';
                if (progressBar) {
                    progressBar.style.background = 'linear-gradient(90deg, #28a745 0%, #20c997 100%)';
                    progressBar.style.width = '100%';
                }
                if (progressText) progressText.textContent = '100%';
                if (timeInfo) timeInfo.textContent = '완료됨';
                
            } else if (data.step === 'Error') {
                // 오류 상태
                if (fileCard) {
                    fileCard.className = 'file-progress-card error';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-error';
                }
                if (statusText) statusText.textContent = '오류';
                if (fileIcon) fileIcon.textContent = '❌';
                if (progressBar) {
                    progressBar.style.background = 'linear-gradient(90deg, #dc3545 0%, #e74c3c 100%)';
                }
                if (timeInfo) timeInfo.textContent = '오류 발생';
                
            } else if (data.step === 'Queued') {
                // 대기열 상태
                if (fileCard) {
                    fileCard.className = 'file-progress-card queued';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-queued';
                }
                if (statusText) {
                    if (data.details && data.details.queue_position) {
                        statusText.textContent = `대기 중 (${data.details.queue_position}번째)`;
                    } else {
                        statusText.textContent = '대기 중';
                    }
                }
                if (fileIcon) fileIcon.textContent = '⏳';
                if (timeInfo) timeInfo.textContent = '대기 중';
                
            } else {
                // 처리 중 상태
                if (fileCard) {
                    fileCard.className = 'file-progress-card processing';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-processing';
                }
                if (statusText) statusText.textContent = '처리 중';
                if (fileIcon) fileIcon.textContent = '⚙️';
                if (timeInfo) {
                    const fileInfo = multiFileTracking.files.get(documentId);
                    if (fileInfo && fileInfo.startTime) {
                        timeInfo.textContent = formatElapsedTime(fileInfo.startTime);
                    } else {
                        timeInfo.textContent = '00:00';
                    }
                }
            }
        }
        
        // 프로세스 단계 시각화 업데이트 (동적 방식)
        function updateProcessSteps(documentId, currentStep, data = {}) {
            const safeId = createSafeId(documentId); // CSS-safe ID 생성
            const processStepsContainer = document.getElementById(`process-steps-${safeId}`);
            if (!processStepsContainer) return;
            
            // 디버깅 로그 추가
            console.log(`📋 단계 업데이트: ${documentId} - ${currentStep}`, data);
            
            // 상세한 단계별 표시 정보
            let stepText = '';
            let stepIcon = '';
            
            switch(currentStep) {
                case 'Queued':
                    stepIcon = '⏳';
                    if (data.details && data.details.queue_position) {
                        stepText = `처리 대기열에서 순서를 기다리는 중... (대기순서: ${data.details.queue_position}번째)`;
                    } else {
                        stepText = '처리 대기열에서 순서를 기다리는 중...';
                    }
                    break;
                case 'Preparing':
                    stepIcon = '📋';
                    stepText = '문서 처리 준비 중...';
                    break;
                case 'Starting':
                    stepIcon = '🚀';
                    stepText = data.details && data.details.was_queued ? '큐에서 처리 시작됨' : '백그라운드 처리 시작됨';
                    break;
                case 'Analyzing':
                    stepIcon = '🔍';
                    stepText = `PDF 파일 분석 중... ${data.total_pages ? `(${data.total_pages}페이지)` : ''}`;
                    break;
                case 'OCR':
                    stepIcon = '👁️';
                    if (data.current_page && data.total_pages) {
                        const details = data.details || {};
                        const stage = details.stage || '';
                        let stageText = '';
                        if (stage === 'text') stageText = '텍스트 추출';
                        else if (stage === 'images') stageText = '이미지 추출';
                        else if (stage === 'tables') stageText = '표 추출';
                        else stageText = 'OCR 처리';
                        
                        stepText = `${stageText} (${data.current_page}/${data.total_pages} 페이지)`;
                    } else if (data.message) {
                        // 메시지에서 중복 '중...' 제거
                        let cleanMessage = data.message;
                        if (cleanMessage.includes('중...') && !cleanMessage.endsWith('중...')) {
                            cleanMessage = cleanMessage.replace(/중\.\.\./g, '');
                        }
                        stepText = cleanMessage;
                    } else {
                        stepText = 'OCR 처리';
                    }
                    break;
                case 'Chunking':
                    stepIcon = '📝';
                    if (data.details && data.details.text_length) {
                        stepText = `텍스트 분할 (${data.details.text_length.toLocaleString()}자)`;
                    } else if (data.message) {
                        stepText = data.message.replace(/중\.\.\./g, '');
                    } else {
                        stepText = '텍스트 청크 분할';
                    }
                    break;
                case 'text_preprocessing':
                    stepIcon = '🔧';
                    stepText = data.message || '텍스트 전처리 및 분석';
                    break;
                case 'text_splitting':
                    stepIcon = '✂️';
                    stepText = data.message || '텍스트 분할 진행';
                    break;
                case 'chunk_validation':
                    stepIcon = '✅';
                    stepText = data.message || '청크 검증 및 최적화';
                    break;
                case 'chunk_correction':
                    stepIcon = '🤖';
                    stepText = data.message || '청크 OCR 교정';
                    break;
                case 'chunk_preparation':
                    stepIcon = '📦';
                    stepText = data.message || '청크 준비 완료';
                    break;
                case 'Embedding':
                    stepIcon = '🧠';
                    if (data.details && data.details.chunks_to_process) {
                        stepText = `임베딩 생성 (${data.details.chunks_to_process}개 청크)`;
                    } else if (data.message) {
                        stepText = data.message.replace(/중\.\.\./g, '');
                    } else {
                        stepText = '벡터 임베딩 생성';
                    }
                    break;
                case 'Storing':
                    stepIcon = '💾';
                    if (data.details) {
                        const details = data.details;
                        const parts = [];
                        if (details.texts) parts.push(`텍스트 ${details.texts}개`);
                        if (details.images) parts.push(`이미지 ${details.images}개`);
                        if (details.tables) parts.push(`표 ${details.tables}개`);
                        stepText = `데이터베이스 저장 (${parts.join(', ')})`;
                    } else if (data.message) {
                        stepText = data.message.replace(/중\.\.\./g, '');
                    } else {
                        stepText = '데이터베이스 저장';
                    }
                    break;
                case 'TextCorrection':
                    stepIcon = '🤖';
                    if (data.details && data.details.batch_current && data.details.batch_total) {
                        const { batch_current, batch_total, text_length } = data.details;
                        stepText = `LLM 텍스트 교정 (${batch_current}/${batch_total} 배치, ${text_length?.toLocaleString()}자)`;
                    } else if (data.message) {
                        stepText = data.message.replace(/중\.\.\./g, '');
                    } else {
                        stepText = 'LLM 텍스트 교정';
                    }
                    break;
                case 'Done':
                case 'Completed':
                    stepIcon = '✅';
                    if (data.details) {
                        const details = data.details;
                        stepText = `처리 완료 (${details.total_pages || 0}페이지, ${details.text_chunks || 0}청크, ${details.images || 0}이미지, ${details.tables || 0}표)`;
                    } else if (data.message) {
                        stepText = data.message;
                    } else {
                        stepText = '모든 처리 완료';
                    }
                    break;
                case 'Error':
                    stepIcon = '❌';
                    stepText = data.message || '처리 중 오류가 발생했습니다.';
                    break;
                default:
                    stepIcon = '⏳';
                    stepText = data.message || '준비 중...';
            }
            
            // 상태별 CSS 클래스 결정
            let statusClass = 'waiting';
            if (currentStep === 'Done' || currentStep === 'Completed') {
                statusClass = 'completed';
            } else if (currentStep === 'Error') {
                statusClass = 'error';
            } else if (currentStep === 'Queued') {
                statusClass = 'queued';
            } else if (['Preparing', 'Starting', 'Analyzing', 'OCR', 'Chunking', 'text_preprocessing', 'text_splitting', 'chunk_validation', 'chunk_correction', 'chunk_preparation', 'Embedding', 'Metadata', 'Storing', 'TextCorrection'].includes(currentStep)) {
                statusClass = 'processing';
            }
            
            // 경과시간 추가 (옵션)
            const fileInfo = multiFileTracking.files.get(documentId);
            const elapsedTime = (fileInfo && fileInfo.startTime) ? formatElapsedTime(fileInfo.startTime) : '';
            
            // 한 줄 깔끔한 단계 표시
            const compactDetails = getCompactDetails(data.details || {});
            const fullText = compactDetails ? `${stepText} ${compactDetails}` : stepText;
            
            processStepsContainer.innerHTML = `
                <div class="current-step-display ${statusClass} compact">
                    <div class="step-icon ${statusClass}">${stepIcon}</div>
                    <div class="step-text-compact">
                        <span class="main-text">${fullText}</span>
                        ${elapsedTime ? `<span class="elapsed-time">${elapsedTime}</span>` : ''}
                    </div>
                </div>
            `;
        }
        
        // 한 줄 압축 상세 정보 생성
        function getCompactDetails(details) {
            const compactItems = [];
            
            // 중복 정보 방지를 위해 우선순위별로 표시
            if (details.text_length && details.chunks_created) {
                compactItems.push(`${details.text_length.toLocaleString()}자 → ${details.chunks_created}청크`);
            } else if (details.text_length) {
                compactItems.push(`${details.text_length.toLocaleString()}자`);
            } else if (details.chunks_created) {
                compactItems.push(`${details.chunks_created}청크`);
            }
            
            if (details.embeddings_created) {
                compactItems.push(`${details.embeddings_created}임베딩`);
            }
            
            if (details.stored_texts || details.stored_images || details.stored_tables) {
                const counts = [];
                if (details.stored_texts) counts.push(`텍스트${details.stored_texts}`);
                if (details.stored_images) counts.push(`이미지${details.stored_images}`);
                if (details.stored_tables) counts.push(`표${details.stored_tables}`);
                if (counts.length > 0) {
                    compactItems.push(counts.join(' • '));
                }
            }
            
            return compactItems.length > 0 ? ` • ${compactItems.join(' • ')}` : '';
        }
        
        // 상세 정보를 포맷팅하여 표시 (레거시 - 사용안함)
        function getFormattedDetails(details) {
            const items = [];
            
            if (details.stage) {
                const stageNames = {
                    'text': '텍스트 추출',
                    'images': '이미지 추출', 
                    'tables': '표 추출'
                };
                items.push(`처리 단계: ${stageNames[details.stage] || details.stage}`);
            }
            
            if (details.pages_processed !== undefined) {
                items.push(`처리된 페이지: ${details.pages_processed}개`);
            }
            
            if (details.text_length !== undefined) {
                items.push(`텍스트 길이: ${details.text_length.toLocaleString()}자`);
            }
            
            if (details.chunks_created !== undefined) {
                items.push(`생성된 청크: ${details.chunks_created}개`);
            }
            
            if (details.embeddings_created !== undefined) {
                items.push(`생성된 임베딩: ${details.embeddings_created}개`);
            }
            
            if (details.embedding_dimension !== undefined) {
                items.push(`벡터 차원: ${details.embedding_dimension}차원`);
            }
            
            return items.map(item => `<div class="detail-item">• ${item}</div>`).join('');
        }
        
        // 사용자 친화적 메시지 생성
        function getFriendlyMessage(step, originalMessage) {
            const friendlyMessages = {
                'OCR': '👁️ OCR로 텍스트를 추출하고 있습니다...',
                'Chunking': '📝 텍스트를 청크로 분할하고 있습니다...',
                'Embedding': '🧠 임베딩 벡터를 생성하고 있습니다...',
                'Storing': '💾 데이터베이스에 저장하고 있습니다...',
                'Done': '✅ 모든 처리가 완료되었습니다!'
            };
            
            return friendlyMessages[step] || originalMessage || '처리 중입니다...';
        }
        
        // 전체 진행률 업데이트 (완료 개수 기반)
        function updateOverallProgress(completedCount, totalCount) {
            const progressBar = document.getElementById('overall-progress-bar');
            const countSpan = document.getElementById('overall-progress-count');
            const textSpan = document.getElementById('overall-progress-text');
            
            const percentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;
            
            if (progressBar) progressBar.style.width = percentage + '%';
            if (countSpan) countSpan.textContent = `${completedCount}/${totalCount} 완료`;
            if (textSpan) {
                if (completedCount === totalCount && totalCount > 0) {
                    textSpan.textContent = '✅ 모든 파일 처리 완료';
                    progressBar.style.background = '#28a745';
                } else {
                    textSpan.textContent = '전체 진행률';
                    progressBar.style.background = '#28a745';
                }
            }
        }
        
        // 개별 파일 진행률 기반 전체 진행률 업데이트 (실시간)
        // 디바운싱을 위한 전역 변수
        let overallProgressUpdateTimeout = null;
        
        function updateOverallProgressFromFiles() {
            // 디바운싱: 빠른 연속 업데이트를 방지하여 성능 최적화
            if (overallProgressUpdateTimeout) {
                clearTimeout(overallProgressUpdateTimeout);
            }
            
            overallProgressUpdateTimeout = setTimeout(() => {
                updateOverallProgressFromFilesImmediate();
            }, 100); // 100ms 디바운스
        }
        
        function updateOverallProgressFromFilesImmediate() {
            const progressBar = document.getElementById('overall-progress-bar');
            const countSpan = document.getElementById('overall-progress-count');
            const textSpan = document.getElementById('overall-progress-text');
            
            const files = Array.from(multiFileTracking.files.values());
            if (files.length === 0) return;
            
            // 개별 파일 진행률의 가중 평균 계산 (실제 진행률 반영)
            const totalProgress = files.reduce((sum, file) => {
                // progress 값이 유효한지 확인하고 0-100 범위로 제한
                const fileProgress = Math.max(0, Math.min(100, file.progress || 0));
                return sum + fileProgress;
            }, 0);
            const averageProgress = Math.round(totalProgress / files.length);
            
            // 완료된 파일 개수 (에러 상태도 완료로 간주)
            const completedFiles = files.filter(f => f.completed);
            const errorFiles = files.filter(f => f.status === 'Error');
            const successFiles = completedFiles.filter(f => f.status !== 'Error');
            const completedCount = completedFiles.length;
            const totalCount = files.length;
            
            // 진행률 바 업데이트 (평균 진행률 기반, 완료 상태 고려)
            let displayProgress = averageProgress;
            
            // 모든 파일이 완료되면 100%로 설정
            if (completedCount === totalCount && totalCount > 0) {
                displayProgress = 100;
            }
            
            if (progressBar) progressBar.style.width = displayProgress + '%';
            if (countSpan) {
                // 에러가 있는 경우 구분하여 표시
                if (errorFiles.length > 0) {
                    countSpan.textContent = `${completedCount}/${totalCount} 완료 (⚠️ ${errorFiles.length}개 오류)`;
                } else {
                    countSpan.textContent = `${completedCount}/${totalCount} 완료`;
                }
            }
            if (textSpan) {
                if (completedCount === totalCount && totalCount > 0) {
                    if (errorFiles.length > 0) {
                        textSpan.textContent = `⚠️ 처리 완료 (${errorFiles.length}개 파일 오류)`;
                        if (progressBar) progressBar.style.background = '#ffc107'; // 노란색 (경고)
                    } else {
                        textSpan.textContent = '✅ 모든 파일 처리 완료';
                        if (progressBar) progressBar.style.background = '#28a745'; // 초록색 (성공)
                    }
                } else {
                    textSpan.textContent = `전체 진행률 (${displayProgress}%)`;
                    if (progressBar) progressBar.style.background = '#007bff'; // 파란색 (진행중)
                    // 실시간 문서 처리 상태 업데이트 (처리 중, 진행률 반영)
                    if (totalCount > 0) {
                        updateProcessingActivity('processing', displayProgress);
                    }
                }
            }
            
            // 상태별 파일 개수 디버깅 로그
            console.log(`전체 진행률 업데이트: ${displayProgress}% (완료: ${completedCount}/${totalCount}, 성공: ${successFiles.length}, 오류: ${errorFiles.length})`);
        }
        
        // 완료 확인 디바운싱을 위한 전역 변수
        let completionCheckTimeout = null;
        
        // 모든 파일 완료 확인 (디바운싱 적용)
        function checkAllFilesCompleted() {
            // 디바운싱: 빠른 연속 완료 체크를 방지
            if (completionCheckTimeout) {
                clearTimeout(completionCheckTimeout);
            }
            
            completionCheckTimeout = setTimeout(() => {
                checkAllFilesCompletedImmediate();
            }, 200); // 200ms 디바운스
        }
        
        function checkAllFilesCompletedImmediate() {
            const files = Array.from(multiFileTracking.files.values());
            const completedFiles = files.filter(f => f.completed);
            const errorFiles = files.filter(f => f.status === 'Error');
            const successFiles = completedFiles.filter(f => f.status !== 'Error');
            const totalFiles = files.length;
            
            console.log('checkAllFilesCompleted: 완료된 파일', completedFiles.length, '/ 전체 파일', totalFiles, '(성공:', successFiles.length, ', 오류:', errorFiles.length, ')');
            updateOverallProgress(completedFiles.length, totalFiles);
            
            if (completedFiles.length === totalFiles && totalFiles > 0) {
                console.log('모든 파일 처리 완료!');
                
                // 오류 있는 경우와 성공한 경우를 구분하여 상태 업데이트
                if (errorFiles.length > 0) {
                    console.log(`⚠️ 처리 완료되었으나 ${errorFiles.length}개 파일에 오류 발생`);
                    updateProcessingActivity('completed_with_errors', 100);
                } else {
                    console.log('✅ 모든 파일이 성공적으로 처리됨');
                    updateProcessingActivity('completed', 100);
                }
                
                // 문서 목록 새로고침 (성공한 파일이 있는 경우에만)
                if (successFiles.length > 0) {
                    setTimeout(() => {
                        fetchDocumentList();
                        console.log('모든 파일 처리 완료: 문서 목록 자동 새로고침');
                    }, 1000);
                }
                
                // 자동 숨김 설정 확인
                const autoHide = document.getElementById('auto-hide-progress');
                console.log('자동 숨김 체크박스 상태:', autoHide ? autoHide.checked : 'not found');
                if (autoHide && autoHide.checked) {
                    console.log('자동 숨김 예약 중...');
                    scheduleProgressHide();
                } else {
                    console.log('자동 숨김 비활성화됨');
                }
            }
        }
        
        // 진행률 창 자동 숨김 예약
        function scheduleProgressHide() {
            console.log('scheduleProgressHide 호출됨 - 10초 후 숨김 예약');
            if (multiFileTracking.hideTimeout) {
                clearTimeout(multiFileTracking.hideTimeout);
                console.log('기존 타이머 제거됨');
            }
            
            multiFileTracking.hideTimeout = setTimeout(() => {
                console.log('자동 숨김 실행 중...');
                const progressContainer = document.getElementById('progress-container');
                const selectedFilesContainer = document.getElementById('selected-files-container');
                
                if (progressContainer) {
                    progressContainer.style.display = 'none';
                    clearMultiFileTracking();
                    // 문서 처리 상태를 '대기중'으로 복귀
                    updateProcessingActivity('idle');
                }
                
                // 선택된 파일 목록도 숨기고 초기화
                if (selectedFilesContainer) {
                    selectedFilesContainer.style.display = 'none';
                    document.getElementById('selected-files-list').innerHTML = '';
                    selectedFilesForUpload.clear();
                    
                    // 파일 입력 초기화
                    const pdfFileInput = document.getElementById('pdf-file');
                    if (pdfFileInput) {
                        pdfFileInput.value = '';
                    }
                    
                    // 업로드 버튼 상태 초기화
                    updateSelectedCount();
                }
            }, 10000); // 10초 후 숨김
        }
        
        // 다중 파일 추적 정리
        function clearMultiFileTracking() {
            // 모든 인터벌 정리
            multiFileTracking.intervals.forEach(interval => clearInterval(interval));
            multiFileTracking.intervals.clear();
            
            // 숨김 타이머 정리
            if (multiFileTracking.hideTimeout) {
                clearTimeout(multiFileTracking.hideTimeout);
                multiFileTracking.hideTimeout = null;
            }
            
            // 디바운싱 타이머들 정리
            if (overallProgressUpdateTimeout) {
                clearTimeout(overallProgressUpdateTimeout);
                overallProgressUpdateTimeout = null;
            }
            
            if (completionCheckTimeout) {
                clearTimeout(completionCheckTimeout);
                completionCheckTimeout = null;
            }
            
            // 파일 데이터 정리
            multiFileTracking.files.clear();
            
            // 개별 진행률 UI 정리
            const container = document.getElementById('individual-progress-container');
            if (container) container.innerHTML = '';
            
            console.log('다중 파일 추적 데이터 및 타이머 모두 정리됨');
        }
        
        // 기존 단일 파일 진행률 함수 (하위 호환성)
        function startProgressPolling(documentId) {
            const progressContainer = document.getElementById('progress-container');
            const progressBarInner = document.getElementById('progress-bar-inner');
            const progressMessage = document.getElementById('progress-message');
            progressContainer.style.display = 'block';
            progressBarInner.style.width = '0%';
            progressMessage.textContent = '처리 대기 중...';
            if(progressInterval) clearInterval(progressInterval);
            progressInterval = setInterval(async () => {
                try {
                    const res = await fetch(`/api/upload_status/${documentId}`);
                    const data = await res.json();
                    const stepInfo = progressSteps.find(s => s.step === data.step) || { percent: 0 };
                    progressBarInner.style.width = stepInfo.percent + '%';
                    progressMessage.textContent = data.message || '';
                    if(data.step === 'Done' || data.step === 'Completed') {
                        progressMessage.textContent = '✅ ' + data.message;
                        clearInterval(progressInterval);
                        // 처리 완료 시 문서 목록 자동 새로고침
                        setTimeout(() => {
                            fetchDocumentList();
                            console.log('문서 처리 완료: 문서 목록 자동 새로고침');
                        }, 1000);
                    } else if(data.step === 'Error') {
                        progressMessage.textContent = '❌ ' + data.message;
                        progressBarInner.style.background = '#dc3545';
                        clearInterval(progressInterval);
                    }
                } catch (e) {
                    progressMessage.textContent = '상태 확인 실패';
                }
            }, 1500);
        }

        // 문서 목록 불러오기 및 드롭다운 갱신
        async function fetchDocumentList() {
            try {
                const res = await fetch('/api/documents');
                const data = await res.json();
                
                // 채팅용 문서 체크박스 업데이트
                const info = document.getElementById('document-info');
                const selectAllCheckbox = document.getElementById('select-all-docs');
                const individualDocCheckboxes = document.getElementById('individual-doc-checkboxes');
                const documentList = document.getElementById('document-list');
                
                if (!individualDocCheckboxes || !documentList) {
                    console.error('Required DOM elements not found');
                    return;
                }
                
                individualDocCheckboxes.innerHTML = '';
                documentList.innerHTML = '';
                
                // 기본 전체 문서 선택
                if (selectAllCheckbox) {
                    selectAllCheckbox.checked = true;
                }
                
                // 개별 문서 체크박스 생성 (새로운 위치에)
                if (data.documents && data.documents.length > 0) {
                    // 저장된 정렬 순서가 있으면 적용
                    let documentsToDisplay = [...data.documents];
                    const savedSortOrder = localStorage.getItem('documentSortOrder');
                    const savedSortAscending = localStorage.getItem('documentSortAscending');
                    
                    if (savedSortOrder) {
                        try {
                            const sortOrder = JSON.parse(savedSortOrder);
                            window.documentSortAscending = savedSortAscending === 'true';
                            
                            // 저장된 순서대로 문서 정렬
                            documentsToDisplay.sort((a, b) => {
                                const indexA = sortOrder.indexOf(a.document_id);
                                const indexB = sortOrder.indexOf(b.document_id);
                                
                                // 둘 다 저장된 순서에 있으면 그 순서대로
                                if (indexA !== -1 && indexB !== -1) {
                                    return indexA - indexB;
                                }
                                // 하나만 저장된 순서에 있으면 저장된 것을 앞으로
                                if (indexA !== -1) return -1;
                                if (indexB !== -1) return 1;
                                // 둘 다 저장된 순서에 없으면 기본 정렬
                                return a.document_id.localeCompare(b.document_id);
                            });
                            
                            console.log('📋 저장된 정렬 순서 적용됨:', savedSortAscending === 'true' ? '오름차순' : '내림차순');
                        } catch (e) {
                            console.warn('저장된 정렬 순서 파싱 실패:', e);
                        }
                    }
                    
                    documentsToDisplay.forEach(doc => {
                        // 채팅용 체크박스 (새로운 구조)
                        const div = document.createElement('div');
                        div.style.cssText = 'margin-bottom: 6px; display: flex; align-items: center; gap: 8px; padding: 4px 8px; border-radius: 4px; transition: background-color 0.2s;';
                        div.innerHTML = `
                            <input type="checkbox" id="doc-checkbox-${doc.document_id}" value="${doc.document_id}" data-preview="${doc.first_chunk_preview || ''}" style="margin: 0; transform: scale(0.9);">
                            <label for="doc-checkbox-${doc.document_id}" style="font-size: 0.85em; color: #495057; cursor: pointer; flex: 1; margin: 0;">
                                📄 ${doc.document_id} <span style="color: #6c757d;">(${doc.chunk_count}청크)</span>
                            </label>
                        `;
                        
                        // 호버 효과
                        div.addEventListener('mouseenter', () => {
                            div.style.backgroundColor = '#f8f9fa';
                        });
                        div.addEventListener('mouseleave', () => {
                            div.style.backgroundColor = 'transparent';
                        });
                        
                        individualDocCheckboxes.appendChild(div);
                        
                        // 문서 관리 목록 (카테고리화된 정보 표시)
                        const docDiv = document.createElement('div');
                        docDiv.className = 'document-item';
                        
                        // 문서 유형 분석
                        const fileName = doc.document_id;
                        let docType = '기술문서';
                        let docCategory = '';
                        
                        if (fileName.includes('주물기술총서')) {
                            docType = '주물기술총서';
                            if (fileName.includes('Vol.')) {
                                const volMatch = fileName.match(/Vol\.\s*(\d+)/);
                                if (volMatch) {
                                    docCategory = `제${volMatch[1]}권`;
                                }
                            }
                        } else if (fileName.includes('주물')) {
                            docType = '주물기술';
                        } else if (fileName.includes('기술')) {
                            docType = '기술문서';
                        }
                        
                        // 주제 추출
                        let topic = '';
                        if (fileName.includes('결함')) topic = '결함분석';
                        else if (fileName.includes('탕구')) topic = '탕구설계';
                        else if (fileName.includes('주조')) topic = '주조공정';
                        else if (fileName.includes('시험')) topic = '시험법';
                        else if (fileName.includes('분석')) topic = '분석법';
                        else if (fileName.includes('주형')) topic = '주형기술';
                        else if (fileName.includes('원가')) topic = '원가관리';
                        else if (fileName.includes('강도')) topic = '강도측정';
                        
                        // 청크 수 기반 문서 크기
                        let sizeInfo = '';
                        if (doc.chunk_count > 100) sizeInfo = '대용량';
                        else if (doc.chunk_count > 50) sizeInfo = '중용량';
                        else if (doc.chunk_count > 20) sizeInfo = '소용량';
                        else sizeInfo = '단편';
                        
                        docDiv.innerHTML = `
                            <div class="document-info">
                                <div class="document-title">📄 ${doc.document_id}</div>
                                <div class="text-muted" style="display: flex; gap: 10px; flex-wrap: wrap; margin: 5px 0;">
                                    <span style="background: #e3f2fd; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${docType}</span>
                                    ${docCategory ? `<span style="background: #f3e5f5; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${docCategory}</span>` : ''}
                                    ${topic ? `<span style="background: #e8f5e8; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${topic}</span>` : ''}
                                    <span style="background: #fff3e0; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${sizeInfo} ${doc.chunk_count}청크</span>
                                </div>
                                ${doc.first_chunk_preview ? `<div class="document-preview" style="font-size: 0.8em; color: #666; margin-top: 5px; line-height: 1.3;">${doc.first_chunk_preview.slice(0, 120)}...</div>` : ''}
                            </div>
                            <div class="document-actions">
                                <button onclick="deleteDocument('${doc.document_id}')" class="btn btn-danger" style="padding: 6px 12px; font-size: 0.9rem;">
                                    🗑️ 삭제
                                </button>
                            </div>
                        `;
                        documentList.appendChild(docDiv);
                    });
                    
                    // 첫 문서 정보 표시
                    if (info) {
                        info.textContent = data.documents[0].first_chunk_preview ? 
                            `미리보기: ${data.documents[0].first_chunk_preview.slice(0, 60)}...` : '';
                    }
                    
                    // 폴링용 문서 개수 업데이트
                    lastDocumentCount = data.documents.length;
                } else {
                    if (info) info.textContent = '';
                    documentList.innerHTML = '<div class="text-center text-muted">📭 저장된 문서가 없습니다.</div>';
                    lastDocumentCount = 0;
                }
                
                // 이벤트 핸들러 등록
                if (selectAllCheckbox) {
                    selectAllCheckbox.addEventListener('change', () => {
                        const checked = selectAllCheckbox.checked;
                        const boxes = individualDocCheckboxes.querySelectorAll('input[type="checkbox"]');
                        boxes.forEach(cb => { 
                            cb.disabled = checked; 
                            if (checked) cb.checked = false; 
                        });
                        updateChatPreview();
                    });
                }
                
                individualDocCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.addEventListener('change', updateChatPreview);
                });
                
            } catch (e) {
                console.error('문서 목록 불러오기 실패:', e);
                const documentList = document.getElementById('document-list');
                if (documentList) {
                    documentList.innerHTML = '<div class="status-message status-error">❌ 문서 목록 불러오기 실패</div>';
                }
                if (document.getElementById('document-info')) {
                    document.getElementById('document-info').textContent = '';
                }
            }
        }
        // 챗봇용 문서 선택 미리보기 업데이트
        function updateChatPreview() {
            const info = document.getElementById('document-info');
            const selectAll = document.getElementById('select-all-docs').checked;
            if (selectAll) {
                info.textContent = '';
                return;
            }
            const checked = Array.from(
                document.querySelectorAll('#individual-doc-checkboxes input[type="checkbox"]:checked')
            );
            const previews = checked.map(cb => cb.getAttribute('data-preview')).filter(Boolean);
            info.textContent = previews.length > 0
                ? `미리보기: ${previews.map(p => p.slice(0, 60)).join(' | ')}...`
                : '';
        }
        // 선택된 문서 ID 배열 반환 (빈 배열은 전체 문서 의미)
        // 문서 선택 UI 상호작용 설정
        function setupDocumentSelectionInteraction() {
            const selectAllCheckbox = document.getElementById('select-all-docs');
            const specificDocSection = document.getElementById('specific-doc-section');
            const selectSpecificCheckbox = document.getElementById('select-specific-docs');
            const individualDocContainer = document.getElementById('individual-doc-container');

            console.log('Document selection interaction setup:', {
                selectAllCheckbox: !!selectAllCheckbox,
                specificDocSection: !!specificDocSection,
                selectSpecificCheckbox: !!selectSpecificCheckbox,
                individualDocContainer: !!individualDocContainer
            });

            if (!selectAllCheckbox || !specificDocSection || !selectSpecificCheckbox || !individualDocContainer) {
                console.error('Some document selection elements are missing');
                return;
            }

            // 전체 문서 선택 체크박스 이벤트
            selectAllCheckbox.addEventListener('change', function() {
                console.log('전체 문서 선택 변경:', this.checked);
                if (this.checked) {
                    // 전체 선택 시 특정 문서 선택 섹션 숨기기
                    specificDocSection.style.display = 'none';
                    selectSpecificCheckbox.checked = false;
                    individualDocContainer.style.display = 'none';
                } else {
                    // 전체 선택 해제 시 특정 문서 선택 섹션과 개별 문서 리스트 바로 표시
                    specificDocSection.style.display = 'block';
                    selectSpecificCheckbox.checked = true;
                    individualDocContainer.style.display = 'block';
                    console.log('개별 문서 리스트 자동 표시됨');
                }
            });

            // 특정 문서 선택 체크박스 이벤트
            selectSpecificCheckbox.addEventListener('change', function() {
                console.log('특정 문서 선택 변경:', this.checked);
                if (this.checked) {
                    // 특정 문서 선택 시 전체 선택 해제하고 리스트 표시
                    selectAllCheckbox.checked = false;
                    individualDocContainer.style.display = 'block';
                    console.log('개별 문서 리스트 표시됨');
                } else {
                    // 특정 문서 선택 해제 시 리스트 숨기기
                    individualDocContainer.style.display = 'none';
                    // 아무것도 선택되지 않았으면 전체 선택으로 복귀
                    selectAllCheckbox.checked = true;
                    specificDocSection.style.display = 'none';
                    console.log('개별 문서 리스트 숨김');
                }
            });
        }

        function getSelectedDocumentIds() {
            const selectAll = document.getElementById('select-all-docs').checked;
            if (selectAll) return [];
            const checked = document.querySelectorAll('#individual-doc-checkboxes input[type="checkbox"]:checked');
            return Array.from(checked).map(cb => cb.value);
        }

        // 문서 관리 기능들
        async function deleteDocument(documentId) {
            if (!confirm(`문서 "${documentId}"를 정말 삭제하시겠습니까?`)) {
                return;
            }
            
            // 기존 메시지 클리어
            clearManagementStatus();
            
            try {
                const response = await fetch(`/api/documents/${documentId}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `✅ 문서 "${documentId}" 삭제 완료`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // 목록 새로고침
                    
                    // 성공 메시지를 3초 후 자동으로 숨김
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 3000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `❌ 삭제 실패: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `❌ 네트워크 오류: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        // 메시지 클리어 헬퍼 함수
        function clearManagementStatus() {
            const statusEl = document.getElementById('management-status');
            statusEl.textContent = '';
            statusEl.className = 'status-message';
        }
        
        // 관리 상태 메시지 설정 함수
        function setManagementStatus(message, type = 'info') {
            const statusEl = document.getElementById('management-status');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `status-message status-${type}`;
            }
        }

        async function deleteAllDocuments() {
            if (!confirm('모든 문서를 정말 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                return;
            }
            
            // 기존 메시지 클리어
            clearManagementStatus();
            
            try {
                const response = await fetch('/api/documents', {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = 
                        `✅ 모든 문서 삭제 완료 (문서: ${result.deleted_documents_count}개, 파일: ${result.deleted_files_count}개)`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // 목록 새로고침
                    
                    // 성공 메시지를 5초 후 자동으로 숨김
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 5000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `❌ 삭제 실패: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `❌ 네트워크 오류: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        // 중복 문서 정리 함수
        async function cleanupDuplicateDocuments() {
            try {
                clearManagementStatus();
                
                // 현재 문서 목록 가져오기
                const response = await fetch('/api/documents');
                const data = await response.json();
                const documents = data.documents || data; // data.documents 또는 data 직접 사용
                
                if (!Array.isArray(documents) || documents.length === 0) {
                    setManagementStatus('📄 정리할 문서가 없습니다.', 'info');
                    return;
                }
                
                // 매우 보수적인 중복 찾기 (정확히 같은 파일만)
                const duplicateGroups = {};
                documents.forEach(doc => {
                    // 매우 엄격한 중복 기준: 거의 동일한 이름만 중복으로 처리
                    let normalizedName = doc.document_id
                        .replace(/\s*\(\d+\)$/i, '')                       // 복사본 번호만 제거 (1), (2) 등
                        .replace(/\s*-\s*copy$/i, '')                      // " - copy" 제거
                        .replace(/\s*_copy$/i, '')                         // "_copy" 제거  
                        .replace(/\s*-\s*복사본$/i, '')                      // " - 복사본" 제거
                        .replace(/\s*_복사본$/i, '')                        // "_복사본" 제거
                        .toLowerCase()
                        .trim();
                    
                    // 매우 보수적: 파일명이 거의 동일한 경우만 중복으로 간주
                    console.log(`🔍 보수적 파일명 정규화: "${doc.document_id}" → "${normalizedName}"`);
                    
                    if (!duplicateGroups[normalizedName]) {
                        duplicateGroups[normalizedName] = [];
                    }
                    duplicateGroups[normalizedName].push(doc);
                });
                
                // 중복된 그룹만 필터링 (2개 이상)
                const duplicates = Object.values(duplicateGroups).filter(group => group.length > 1);
                
                if (duplicates.length === 0) {
                    setManagementStatus('✅ 중복 파일이 발견되지 않았습니다.', 'success');
                    return;
                }
                
                // 중복 파일 정리 확인
                const duplicateCount = duplicates.reduce((sum, group) => sum + (group.length - 1), 0);
                if (!confirm(`${duplicates.length}개 그룹에서 총 ${duplicateCount}개의 중복 파일을 발견했습니다.\n\n각 그룹에서 가장 최근 파일을 제외하고 삭제하시겠습니까?`)) {
                    return;
                }
                
                setManagementStatus('🔍 중복 파일 정리 중...', 'info');
                
                let deletedCount = 0;
                let errorCount = 0;
                
                // 각 중복 그룹 처리
                for (const group of duplicates) {
                    console.log(`🔍 중복 그룹 처리:`, group.map(doc => ({
                        id: doc.document_id,
                        chunks: doc.chunk_count,
                        created: doc.created_at,
                        hasCreatedAt: !!doc.created_at
                    })));
                    
                    // 안전장치: 그룹에 최소 2개 이상의 파일이 있어야 중복으로 간주
                    if (group.length < 2) {
                        console.warn(`⚠️ 그룹에 파일이 ${group.length}개만 있음, 건너뜀`);
                        continue;
                    }
                    
                    // 정렬 기준: 
                    // 1. 청크 수가 많은 순 (더 완전한 문서)
                    // 2. created_at이 있으면 최신 순
                    // 3. document_id 알파벳 순 (fallback)
                    group.sort((a, b) => {
                        // 1순위: 청크 수 (많은 것이 더 완전한 문서)
                        const chunkDiff = (b.chunk_count || 0) - (a.chunk_count || 0);
                        if (chunkDiff !== 0) return chunkDiff;
                        
                        // 2순위: created_at (최신 것)
                        if (a.created_at && b.created_at) {
                            return new Date(b.created_at) - new Date(a.created_at);
                        }
                        
                        // 3순위: document_id (알파벳 순)
                        return a.document_id.localeCompare(b.document_id);
                    });
                    
                    const keepFile = group[0]; // 유지할 파일
                    const deleteFiles = group.slice(1); // 삭제할 파일들
                    
                    console.log(`✅ 유지할 파일:`, {
                        id: keepFile.document_id,
                        chunks: keepFile.chunk_count,
                        created: keepFile.created_at
                    });
                    console.log(`🗑️ 삭제할 파일들:`, deleteFiles.map(f => ({
                        id: f.document_id,
                        chunks: f.chunk_count,
                        created: f.created_at
                    })));
                    
                    // 삭제 실행 (첫 번째 파일 제외)
                    for (const fileToDelete of deleteFiles) {
                        try {
                            console.log(`🗑️ 삭제 중: ${fileToDelete.document_id}`);
                            const deleteResponse = await fetch(`/api/documents/${fileToDelete.document_id}`, {
                                method: 'DELETE'
                            });
                            
                            if (deleteResponse.ok) {
                                deletedCount++;
                                console.log(`✅ 삭제 성공: ${fileToDelete.document_id}`);
                            } else {
                                errorCount++;
                                console.error(`❌ 삭제 실패: ${fileToDelete.document_id}`, deleteResponse.status);
                            }
                        } catch (error) {
                            errorCount++;
                            console.error(`❌ 삭제 오류: ${fileToDelete.document_id}`, error);
                        }
                    }
                }
                
                // 결과 메시지 표시
                if (deletedCount > 0) {
                    setManagementStatus(
                        `✅ 중복 파일 정리 완료: ${deletedCount}개 삭제${errorCount > 0 ? `, ${errorCount}개 실패` : ''}`, 
                        errorCount > 0 ? 'warning' : 'success'
                    );
                    
                    // 문서 목록 새로고침
                    setTimeout(() => {
                        fetchDocumentList();
                    }, 1000);
                } else {
                    setManagementStatus('❌ 중복 파일 정리 중 오류가 발생했습니다.', 'error');
                }
                
            } catch (error) {
                console.error('중복 파일 정리 오류:', error);
                setManagementStatus(`❌ 중복 파일 정리 실패: ${error.message}`, 'error');
            }
        }
        
        // 문서 이름순 정렬 함수
        async function sortDocumentsByName() {
            try {
                clearManagementStatus();
                setManagementStatus('📝 문서 목록을 이름순으로 정렬 중...', 'info');
                
                // 현재 정렬 상태 관리 (첫 번째 실행은 항상 오름차순)
                if (window.documentSortAscending === undefined) {
                    window.documentSortAscending = true; // 첫 번째 실행은 오름차순
                } else {
                    window.documentSortAscending = !window.documentSortAscending; // 토글
                }
                
                const sortOrder = window.documentSortAscending ? '오름차순' : '내림차순';
                
                // 문서 목록 가져오기
                const response = await fetch('/api/documents');
                const data = await response.json();
                const documents = data.documents || data; // data.documents 또는 data 직접 사용
                
                if (!Array.isArray(documents) || documents.length === 0) {
                    setManagementStatus('📄 정렬할 문서가 없습니다.', 'info');
                    return;
                }
                
                // 한글명 + 숫자 정렬 (자연스러운 정렬)
                documents.sort((a, b) => {
                    const nameA = a.document_id;
                    const nameB = b.document_id;
                    
                    // 한글명과 숫자를 분리하여 정렬하는 함수
                    const naturalSort = (str1, str2) => {
                        // 정규표현식으로 텍스트와 숫자 분리
                        const chunks1 = str1.match(/(\d+|\D+)/g) || [];
                        const chunks2 = str2.match(/(\d+|\D+)/g) || [];
                        
                        const maxLength = Math.max(chunks1.length, chunks2.length);
                        
                        for (let i = 0; i < maxLength; i++) {
                            const chunk1 = chunks1[i] || '';
                            const chunk2 = chunks2[i] || '';
                            
                            // 둘 다 숫자인 경우 숫자로 비교
                            const num1 = parseInt(chunk1);
                            const num2 = parseInt(chunk2);
                            
                            if (!isNaN(num1) && !isNaN(num2)) {
                                if (num1 !== num2) {
                                    return num1 - num2;
                                }
                            } else {
                                // 텍스트 비교 (한글 포함)
                                const textCompare = chunk1.localeCompare(chunk2, 'ko', { 
                                    numeric: true, 
                                    sensitivity: 'base',
                                    ignorePunctuation: true 
                                });
                                if (textCompare !== 0) {
                                    return textCompare;
                                }
                            }
                        }
                        return 0;
                    };
                    
                    const result = naturalSort(nameA, nameB);
                    return window.documentSortAscending ? result : -result;
                });
                
                // 정렬된 순서를 저장 (localStorage에 저장하여 지속성 확보)
                const sortedOrder = documents.map(doc => doc.document_id);
                localStorage.setItem('documentSortOrder', JSON.stringify(sortedOrder));
                localStorage.setItem('documentSortAscending', window.documentSortAscending);
                
                // 정렬된 목록으로 UI 업데이트
                displayDocumentList(documents);
                
                setManagementStatus(`✅ 문서 목록이 이름순 ${sortOrder}으로 정렬되었습니다. (${documents.length}개 문서)`, 'success');
                
                // 성공 메시지를 3초 후 자동으로 숨김
                setTimeout(() => {
                    clearManagementStatus();
                }, 3000);
                
            } catch (error) {
                console.error('문서 정렬 오류:', error);
                setManagementStatus(`❌ 문서 정렬 실패: ${error.message}`, 'error');
            }
        }
        
        // 문서 목록 표시 함수 (정렬된 목록용)
        function displayDocumentList(documents) {
            const documentList = document.getElementById('document-list');
            const individualDocCheckboxes = document.getElementById('individual-doc-checkboxes');
            const info = document.getElementById('document-info');
            
            if (!documentList || !individualDocCheckboxes) {
                console.error('Required DOM elements not found');
                return;
            }
            
            // 기존 목록 클리어
            documentList.innerHTML = '';
            individualDocCheckboxes.innerHTML = '';
            
            if (documents && documents.length > 0) {
                documents.forEach(doc => {
                    // 채팅용 체크박스 생성
                    const div = document.createElement('div');
                    div.style.cssText = 'margin-bottom: 6px; display: flex; align-items: center; gap: 8px; padding: 4px 8px; border-radius: 4px; transition: background-color 0.2s;';
                    div.innerHTML = `
                        <input type="checkbox" id="doc-checkbox-${doc.document_id}" value="${doc.document_id}" data-preview="${doc.first_chunk_preview || ''}" style="margin: 0; transform: scale(0.9);">
                        <label for="doc-checkbox-${doc.document_id}" style="font-size: 0.85em; color: #495057; cursor: pointer; flex: 1; margin: 0;">
                            📄 ${doc.document_id} <span style="color: #6c757d;">(${doc.chunk_count}청크)</span>
                        </label>
                    `;
                    
                    // 호버 효과
                    div.addEventListener('mouseenter', () => {
                        div.style.backgroundColor = '#f8f9fa';
                    });
                    div.addEventListener('mouseleave', () => {
                        div.style.backgroundColor = 'transparent';
                    });
                    
                    individualDocCheckboxes.appendChild(div);
                    
                    // 문서 관리 목록
                    const docDiv = document.createElement('div');
                    docDiv.className = 'document-item';
                    
                    // 문서 유형 분석
                    const fileName = doc.document_id;
                    let docType = '기술문서';
                    let docCategory = '';
                    
                    if (fileName.includes('주물기술총서')) {
                        docType = '주물기술총서';
                        if (fileName.includes('Vol.')) {
                            const volMatch = fileName.match(/Vol\.\s*(\d+)/);
                            if (volMatch) {
                                docCategory = `제${volMatch[1]}권`;
                            }
                        }
                    } else if (fileName.includes('주물')) {
                        docType = '주물기술';
                    } else if (fileName.includes('기술')) {
                        docType = '기술문서';
                    }
                    
                    // 주제 추출
                    let topic = '';
                    if (fileName.includes('결함')) topic = '결함분석';
                    else if (fileName.includes('탕구')) topic = '탕구설계';
                    else if (fileName.includes('주조')) topic = '주조공정';
                    else if (fileName.includes('시험')) topic = '시험법';
                    else if (fileName.includes('분석')) topic = '분석법';
                    else if (fileName.includes('주형')) topic = '주형기술';
                    else if (fileName.includes('원가')) topic = '원가관리';
                    else if (fileName.includes('강도')) topic = '강도측정';
                    
                    // 청크 수 기반 문서 크기
                    let sizeInfo = '';
                    if (doc.chunk_count > 100) sizeInfo = '대용량';
                    else if (doc.chunk_count > 50) sizeInfo = '중용량';
                    else if (doc.chunk_count > 20) sizeInfo = '소용량';
                    else sizeInfo = '단편';
                    
                    docDiv.innerHTML = `
                        <div class="document-info">
                            <div class="document-title">📄 ${doc.document_id}</div>
                            <div class="text-muted" style="display: flex; gap: 10px; flex-wrap: wrap; margin: 5px 0;">
                                <span style="background: #e3f2fd; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${docType}</span>
                                ${docCategory ? `<span style="background: #f3e5f5; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${docCategory}</span>` : ''}
                                ${topic ? `<span style="background: #e8f5e8; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${topic}</span>` : ''}
                                <span style="background: #fff3e0; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">${sizeInfo} ${doc.chunk_count}청크</span>
                            </div>
                            ${doc.first_chunk_preview ? `<div class="document-preview" style="font-size: 0.8em; color: #666; margin-top: 5px; line-height: 1.3;">${doc.first_chunk_preview.slice(0, 120)}...</div>` : ''}
                        </div>
                        <div class="document-actions">
                            <button onclick="deleteDocument('${doc.document_id}')" class="btn btn-danger" style="padding: 6px 12px; font-size: 0.9rem;">
                                🗑️ 삭제
                            </button>
                        </div>
                    `;
                    documentList.appendChild(docDiv);
                });
                
                // 첫 문서 정보 표시
                if (info) {
                    info.textContent = documents[0].first_chunk_preview ? 
                        `미리보기: ${documents[0].first_chunk_preview.slice(0, 60)}...` : '';
                }
                
                // 폴링용 문서 개수 업데이트
                lastDocumentCount = documents.length;
            } else {
                if (info) info.textContent = '';
                documentList.innerHTML = '<div class="text-center text-muted">📭 저장된 문서가 없습니다.</div>';
                lastDocumentCount = 0;
            }
            
            // 이벤트 핸들러 재등록
            const selectAllCheckbox = document.getElementById('select-all-docs');
            if (selectAllCheckbox) {
                // 기존 이벤트 리스너를 제거하고 새로 등록
                selectAllCheckbox.removeEventListener('change', handleSelectAllChange);
                selectAllCheckbox.addEventListener('change', handleSelectAllChange);
            }
            
            individualDocCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.addEventListener('change', updateChatPreview);
            });
        }
        
        // 전체 선택 체크박스 핸들러 (분리)
        function handleSelectAllChange() {
            const selectAllCheckbox = document.getElementById('select-all-docs');
            const individualDocCheckboxes = document.getElementById('individual-doc-checkboxes');
            
            if (selectAllCheckbox && individualDocCheckboxes) {
                const checked = selectAllCheckbox.checked;
                const boxes = individualDocCheckboxes.querySelectorAll('input[type="checkbox"]');
                boxes.forEach(cb => { 
                    cb.disabled = checked; 
                    if (checked) cb.checked = false; 
                });
                updateChatPreview();
            }
        }
        
        // 백그라운드 환영메시지 생성 함수 (자동 실행용)
        async function generateWelcomeMessagesBackground() {
            try {
                const response = await fetch('/api/welcome-messages/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ count: 5 })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    console.log(`✅ 백그라운드 환영메시지 생성 완료: ${data.generated_count}개 생성`);
                } else {
                    console.error('백그라운드 환영메시지 생성 실패:', data.detail);
                }
                
            } catch (error) {
                console.error('백그라운드 환영메시지 생성 오류:', error);
            }
        }
        
        // 주기적 환영메시지 생성 (1시간마다)
        function startWelcomeMessageAutoGeneration() {
            // 페이지 로드 후 5분 뒤에 첫 번째 생성
            setTimeout(async () => {
                console.log('🎯 자동 환영메시지 생성 시작...');
                try {
                    await generateWelcomeMessagesBackground();
                } catch (error) {
                    console.error('자동 환영메시지 생성 실패:', error);
                }
            }, 5 * 60 * 1000); // 5분
            
            // 그 이후 1시간마다 생성
            setInterval(async () => {
                console.log('🔄 주기적 환영메시지 생성...');
                try {
                    await generateWelcomeMessagesBackground();
                } catch (error) {
                    console.error('주기적 환영메시지 생성 실패:', error);
                }
            }, 60 * 60 * 1000); // 1시간
            
            console.log('✅ 환영메시지 자동 생성 스케줄러 시작됨 (첫 실행: 5분 후, 이후: 1시간마다)');
        }
        
        async function showStorageStats() {
            try {
                const response = await fetch('/api/storage/stats');
                const result = await response.json();
                
                if (response.ok) {
                    const stats = `📊 저장소 통계:\n` +
                        `파일: ${result.file_storage.total_files}개 (${result.file_storage.total_size_mb}MB)\n` +
                        `문서: ${result.vector_db.total_documents}개\n` +
                        `청크: ${result.vector_db.total_chunks}개`;
                    alert(stats);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `❌ 통계 조회 실패: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `❌ 네트워크 오류: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        async function cleanupOrphanedFiles() {
            if (!confirm('고아 파일들을 정리하시겠습니까?')) {
                return;
            }
            
            // 기존 메시지 클리어
            clearManagementStatus();
            
            try {
                const response = await fetch('/api/documents/cleanup', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = 
                        `✅ 정리 완료: ${result.cleaned_files_count}개 파일 정리됨`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // 목록 새로고침
                    
                    // 성공 메시지를 4초 후 자동으로 숨김
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 4000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `❌ 정리 실패: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `❌ 네트워크 오류: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        // 문서 목록 자동 새로고침 간격 (30초)
        let documentListInterval = null;
        let lastDocumentCount = 0;
        
        function startDocumentListPolling() {
            // 기존 인터벌 정리
            if (documentListInterval) {
                clearInterval(documentListInterval);
            }
            
            // 30초마다 문서 목록 확인
            documentListInterval = setInterval(async () => {
                try {
                    const res = await fetch('/api/documents');
                    const data = await res.json();
                    const currentDocumentCount = data.documents ? data.documents.length : 0;
                    
                    // 문서 개수가 변경되었으면 목록 새로고침
                    if (currentDocumentCount !== lastDocumentCount) {
                        console.log(`문서 개수 변경 감지: ${lastDocumentCount} → ${currentDocumentCount}`);
                        fetchDocumentList();
                        lastDocumentCount = currentDocumentCount;
                        
                        // 자동 새로고침 표시기 업데이트
                        updateAutoRefreshIndicator('변경 감지됨');
                    }
                } catch (error) {
                    console.log('문서 목록 폴링 오류:', error);
                }
            }, 30000); // 30초 간격
        }
        
        function stopDocumentListPolling() {
            if (documentListInterval) {
                clearInterval(documentListInterval);
                documentListInterval = null;
            }
        }
        
        function updateAutoRefreshIndicator(status) {
            const indicator = document.getElementById('auto-refresh-indicator');
            if (!indicator) return;
            
            const timestamp = new Date().toLocaleTimeString();
            
            switch(status) {
                case '변경 감지됨':
                    indicator.innerHTML = `🔄 목록 업데이트됨 (${timestamp})`;
                    indicator.style.color = '#28a745';
                    setTimeout(() => {
                        indicator.innerHTML = '🔄 자동 새로고침 활성화';
                        indicator.style.color = '#28a745';
                    }, 3000);
                    break;
                case '활성화':
                    indicator.innerHTML = '🔄 자동 새로고침 활성화';
                    indicator.style.color = '#28a745';
                    break;
                case '비활성화':
                    indicator.innerHTML = '⏸️ 자동 새로고침 비활성화';
                    indicator.style.color = '#6c757d';
                    break;
                default:
                    indicator.innerHTML = `🔄 ${status}`;
                    indicator.style.color = '#17a2b8';
            }
        }

        // 이벤트 리스너 추가
        document.addEventListener('DOMContentLoaded', async () => {
            // 웰컴 메시지 표시 (동적 로드)
            await showWelcomeMessage();
            
            fetchOllamaStatusAndModels();
            fetchDocumentList();
            updateSystemStats(); // 새로 추가: 시스템 통계 초기화
            setupQuickSettings(); // 새로 추가: 빠른 설정 토글 초기화
            setupDocumentSelectionInteraction(); // 문서 선택 UI 상호작용 설정
            
            // 문서 처리 상태 초기화
            updateProcessingActivity('idle');
            
            // 문서 목록 자동 새로고침 시작
            startDocumentListPolling();
            updateAutoRefreshIndicator('활성화');
            
            // 문서 관리 버튼들
            document.getElementById('refresh-documents').addEventListener('click', fetchDocumentList);
            document.getElementById('storage-stats').addEventListener('click', showStorageStats);
            document.getElementById('cleanup-duplicates').addEventListener('click', cleanupDuplicateDocuments);
            document.getElementById('sort-documents').addEventListener('click', sortDocumentsByName);
            document.getElementById('cleanup-files').addEventListener('click', cleanupOrphanedFiles);
            document.getElementById('delete-all-documents').addEventListener('click', deleteAllDocuments);
            
            // 환영메시지 자동 생성 스케줄러 시작
            startWelcomeMessageAutoGeneration();
            
            // 처리 중단 버튼
            document.getElementById('stop-processing').addEventListener('click', () => {
                if (confirm('현재 진행 중인 모든 파일 처리를 중단하시겠습니까?\n\n⚠️ 중단된 파일들은 다시 업로드해야 합니다.')) {
                    console.log('사용자 요청으로 파일 처리 중단');
                    
                    // 모든 진행률 추적 중단
                    clearMultiFileTracking();
                    
                    // 진행률 UI 업데이트
                    const progressContainer = document.getElementById('progress-container');
                    const uploadStatus = document.getElementById('upload-status');
                    
                    // 중단 메시지 표시
                    if (uploadStatus) {
                        uploadStatus.textContent = '⏹ 사용자 요청으로 처리가 중단되었습니다.';
                        uploadStatus.className = 'status-message status-warning';
                    }
                    
                    // 전체 진행률 정리
                    updateOverallProgress(0, 0, '처리 중단됨');
                    
                    // 개별 파일 진행률 컨테이너 정리
                    const individualContainer = document.getElementById('individual-progress-container');
                    if (individualContainer) {
                        individualContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #dc3545;"><strong>⏹ 처리가 중단되었습니다</strong><br><small>새로운 파일을 업로드하려면 페이지를 새로고침하거나 새 파일을 선택하세요.</small></div>';
                    }
                    
                    // 문서 처리 상태를 idle로 변경
                    updateProcessingActivity('idle');
                    
                    // 3초 후 진행률 창 자동 숨김
                    setTimeout(() => {
                        if (progressContainer) {
                            progressContainer.style.display = 'none';
                        }
                    }, 3000);
                }
            });
            
            // 진행률 창 닫기 버튼
            document.getElementById('hide-progress').addEventListener('click', () => {
                const progressContainer = document.getElementById('progress-container');
                const selectedFilesContainer = document.getElementById('selected-files-container');
                
                progressContainer.style.display = 'none';
                clearMultiFileTracking();
                
                // 선택된 파일 목록도 숨기고 초기화
                if (selectedFilesContainer) {
                    selectedFilesContainer.style.display = 'none';
                    document.getElementById('selected-files-list').innerHTML = '';
                    selectedFilesForUpload.clear();
                    
                    // 파일 입력 초기화
                    const pdfFileInput = document.getElementById('pdf-file');
                    if (pdfFileInput) {
                        pdfFileInput.value = '';
                    }
                    
                    // 업로드 버튼 상태 초기화
                    updateSelectedCount();
                }
            });
            
            
            // 모델 선택 변경 시 스타일 업데이트
            const modelSelect = document.getElementById('ollama-models');
            modelSelect.addEventListener('change', updateSelectedModelDisplay);
        });

        // 이미지 모달 기능 임시 비활성화
        // Image modal functionality temporarily disabled
        
        // 표 확장/축소 기능
        function toggleTableExpand(tableId) {
            const table = document.getElementById(tableId);
            const hiddenRows = table.querySelectorAll('.hidden-row');
            const expandIndicator = table.querySelector('.table-expand-indicator');
            const button = table.parentElement.querySelector('.btn-small');
            
            if (table.classList.contains('collapsed')) {
                // 확장
                hiddenRows.forEach(row => row.style.display = '');
                if (expandIndicator) expandIndicator.style.display = 'none';
                button.textContent = '축소하기';
                table.classList.remove('collapsed');
            } else {
                // 축소
                hiddenRows.forEach(row => row.style.display = 'none');
                if (expandIndicator) expandIndicator.style.display = '';
                button.textContent = '전체 보기';
                table.classList.add('collapsed');
            }
        }
        
        // ESC 키 이벤트 (이미지 모달 기능 비활성화됨)
        // document.addEventListener('keydown', function(e) {
        //     if (e.key === 'Escape') {
        //         closeImageModal();
        //     }
        // });
        
        // 마크다운 렌더링(답변에 적용)
        // marked.js CDN 추가
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
        document.head.appendChild(script);
    </script>
</body>
</html>
